
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type ExamplePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Example"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["example"]>
  composites: {}
}

/**
 * Model Example
 * 
 */
export type Example = runtime.Types.DefaultSelection<ExamplePayload>
export type AccountPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Account"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }, ExtArgs["result"]["account"]>
  composites: {}
}

/**
 * Model Account
 * 
 */
export type Account = runtime.Types.DefaultSelection<AccountPayload>
export type SessionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Session"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    sessionToken: string
    userId: string
    expires: Date
  }, ExtArgs["result"]["session"]>
  composites: {}
}

/**
 * Model Session
 * 
 */
export type Session = runtime.Types.DefaultSelection<SessionPayload>
export type CompanyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Company"
  objects: {
    company_manager: UserPayload<ExtArgs> | null
    macrovesta_manager: UserPayload<ExtArgs> | null
    users: UserPayload<ExtArgs>[]
    selected_users: UserPayload<ExtArgs>[]
    producer_production_estimates: producer_production_estimatesPayload<ExtArgs>[]
    producer_cost_estimates: producer_cost_estimatesPayload<ExtArgs>[]
    producer_commercialisation_estimates: producer_commercialisation_estimatesPayload<ExtArgs>[]
    strategy_log: strategy_logPayload<ExtArgs>[]
    fixed_cotton: fixed_cottonPayload<ExtArgs>[]
    unfixed_cotton: unfixed_cottonPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    record_id: string
    name: string
    type: string
    tier: string
    access_to_marketplace: boolean | null
    created_at: Date
    company_manager_id: string | null
    macrovesta_manager_id: string | null
  }, ExtArgs["result"]["company"]>
  composites: {}
}

/**
 * Model Company
 * 
 */
export type Company = runtime.Types.DefaultSelection<CompanyPayload>
export type VerificationTokenPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "VerificationToken"
  objects: {}
  scalars: $Extensions.GetResult<{
    identifier: string
    token: string
    expires: Date
  }, ExtArgs["result"]["verificationToken"]>
  composites: {}
}

/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = runtime.Types.DefaultSelection<VerificationTokenPayload>
export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    company: CompanyPayload<ExtArgs> | null
    selected_company: CompanyPayload<ExtArgs> | null
    company_managing: CompanyPayload<ExtArgs> | null
    macrovesta_managing: CompanyPayload<ExtArgs>[]
    accounts: AccountPayload<ExtArgs>[]
    sessions: SessionPayload<ExtArgs>[]
    agents: MarketplaceAgentPayload<ExtArgs>[]
    buyers: MarketplaceBuyerPayload<ExtArgs>[]
    Marketplace: MarketplacePayload<ExtArgs>[]
    Notification: NotificationPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    role: string | null
    company_id: string | null
    selected_company_id: string | null
    submittedSurvey: boolean | null
    image: string | null
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type NotificationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Notification"
  objects: {
    user: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    record_id: string
    title: string
    description: string
    is_read: boolean
    user_id: string
    date_created: Date
  }, ExtArgs["result"]["notification"]>
  composites: {}
}

/**
 * Model Notification
 * 
 */
export type Notification = runtime.Types.DefaultSelection<NotificationPayload>
export type MarketplacePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Marketplace"
  objects: {
    reserved_by_user: UserPayload<ExtArgs> | null
    agents: MarketplaceAgentPayload<ExtArgs>[]
    buyers: MarketplaceBuyerPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    record_id: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created: Date
    expiry_date: Date
    reserved_by: string | null
  }, ExtArgs["result"]["marketplace"]>
  composites: {}
}

/**
 * Model Marketplace
 * 
 */
export type Marketplace = runtime.Types.DefaultSelection<MarketplacePayload>
export type MarketplaceAgentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "MarketplaceAgent"
  objects: {
    marketplace: MarketplacePayload<ExtArgs>
    agent: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    record_id: string
    marketplace_id: string
    agent_id: string
    date_created: Date
  }, ExtArgs["result"]["marketplaceAgent"]>
  composites: {}
}

/**
 * Model MarketplaceAgent
 * 
 */
export type MarketplaceAgent = runtime.Types.DefaultSelection<MarketplaceAgentPayload>
export type MarketplaceBuyerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "MarketplaceBuyer"
  objects: {
    buyer: UserPayload<ExtArgs>
    marketplace: MarketplacePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    record_id: string
    marketplace_id: string
    buyer_id: string
    date_created: Date
  }, ExtArgs["result"]["marketplaceBuyer"]>
  composites: {}
}

/**
 * Model MarketplaceBuyer
 * 
 */
export type MarketplaceBuyer = runtime.Types.DefaultSelection<MarketplaceBuyerPayload>
export type a_indexPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "a_index"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    date: Date
    a_index: Prisma.Decimal
    ice_highest_open_interest_17_months: Prisma.Decimal | null
    cc_index: Prisma.Decimal | null
    mcx: Prisma.Decimal | null
    cepea: Prisma.Decimal | null
  }, ExtArgs["result"]["a_index"]>
  composites: {}
}

/**
 * Model a_index
 * 
 */
export type a_index = runtime.Types.DefaultSelection<a_indexPayload>
export type fixed_cottonPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "fixed_cotton"
  objects: {
    company: CompanyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    company_id: string
    record_id: string
    contract_number: string
    futures_month: string
    basis: Prisma.Decimal | null
    fixed_price_without_basis: Prisma.Decimal | null
    amount_fixed: Prisma.Decimal | null
    added_by: string
    date_created: Date
  }, ExtArgs["result"]["fixed_cotton"]>
  composites: {}
}

/**
 * Model fixed_cotton
 * 
 */
export type fixed_cotton = runtime.Types.DefaultSelection<fixed_cottonPayload>
export type unfixed_cottonPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "unfixed_cotton"
  objects: {
    company: CompanyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    record_id: string
    company_id: string
    contract_number: string
    futures_month: string
    basis: Prisma.Decimal | null
    fix_by: Date
    total_amount: Prisma.Decimal | null
    amount_remaining: Prisma.Decimal | null
    added_by: string
    date_created: Date
  }, ExtArgs["result"]["unfixed_cotton"]>
  composites: {}
}

/**
 * Model unfixed_cotton
 * 
 */
export type unfixed_cotton = runtime.Types.DefaultSelection<unfixed_cottonPayload>
export type strategy_logPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "strategy_log"
  objects: {
    company: CompanyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    record_id: string
    company_id: string
    title: string | null
    text: string | null
    added_by: string | null
    date_created: Date
  }, ExtArgs["result"]["strategy_log"]>
  composites: {}
}

/**
 * Model strategy_log
 * 
 */
export type strategy_log = runtime.Types.DefaultSelection<strategy_logPayload>
export type producer_production_estimatesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "producer_production_estimates"
  objects: {
    company: CompanyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    record_id: string
    company_id: string
    season: string
    production_estimate: Prisma.Decimal
    yield_estimate: Prisma.Decimal
    added_by: string | null
    date_created: Date
  }, ExtArgs["result"]["producer_production_estimates"]>
  composites: {}
}

/**
 * Model producer_production_estimates
 * 
 */
export type producer_production_estimates = runtime.Types.DefaultSelection<producer_production_estimatesPayload>
export type producer_cost_estimatesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "producer_cost_estimates"
  objects: {
    company: CompanyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    record_id: string
    company_id: string
    season: string
    cost_estimate_dollar_per_hectare: Prisma.Decimal
    cost_estimate_cent_per_pound: Prisma.Decimal
    added_by: string | null
    date_created: Date
  }, ExtArgs["result"]["producer_cost_estimates"]>
  composites: {}
}

/**
 * Model producer_cost_estimates
 * 
 */
export type producer_cost_estimates = runtime.Types.DefaultSelection<producer_cost_estimatesPayload>
export type producer_commercialisation_estimatesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "producer_commercialisation_estimates"
  objects: {
    company: CompanyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    record_id: string
    company_id: string
    season: string
    percentage_sold: Prisma.Decimal
    added_by: string | null
    date_created: Date
  }, ExtArgs["result"]["producer_commercialisation_estimates"]>
  composites: {}
}

/**
 * Model producer_commercialisation_estimates
 * 
 */
export type producer_commercialisation_estimates = runtime.Types.DefaultSelection<producer_commercialisation_estimatesPayload>
export type bug_reportPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "bug_report"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    type: string | null
    title: string | null
    text: string | null
    added_by: string | null
    date_created: Date
  }, ExtArgs["result"]["bug_report"]>
  composites: {}
}

/**
 * Model bug_report
 * 
 */
export type bug_report = runtime.Types.DefaultSelection<bug_reportPayload>
export type suggestionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "suggestions"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    type: string | null
    text: string | null
    added_by: string | null
    date_created: Date
  }, ExtArgs["result"]["suggestions"]>
  composites: {}
}

/**
 * Model suggestions
 * 
 */
export type suggestions = runtime.Types.DefaultSelection<suggestionsPayload>
export type upcoming_changesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "upcoming_changes"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    type: string | null
    title: string | null
    text: string
    image: string | null
    planned_released_date: Date | null
  }, ExtArgs["result"]["upcoming_changes"]>
  composites: {}
}

/**
 * Model upcoming_changes
 * 
 */
export type upcoming_changes = runtime.Types.DefaultSelection<upcoming_changesPayload>
export type conclusionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "conclusion"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    text: string
    date_created: Date
  }, ExtArgs["result"]["conclusion"]>
  composites: {}
}

/**
 * Model conclusion
 * 
 */
export type conclusion = runtime.Types.DefaultSelection<conclusionPayload>
export type Demo_RequestsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Demo_Requests"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    first_name: string
    last_name: string
    email: string
    company_name: string | null
    company_type: string | null
    preferred_date: Date | null
    preferred_time: Date | null
    date_created: Date
  }, ExtArgs["result"]["demo_Requests"]>
  composites: {}
}

/**
 * Model Demo_Requests
 * 
 */
export type Demo_Requests = runtime.Types.DefaultSelection<Demo_RequestsPayload>
export type General_InquiriesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "General_Inquiries"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    name: string | null
    email: string | null
    company: string | null
    message: string | null
    date_created: Date
  }, ExtArgs["result"]["general_Inquiries"]>
  composites: {}
}

/**
 * Model General_Inquiries
 * 
 */
export type General_Inquiries = runtime.Types.DefaultSelection<General_InquiriesPayload>
export type things_to_reviewPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "things_to_review"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    added_by: string
    table: string
    type: string
    thing_id: string | null
    information: string
    date_created: Date
  }, ExtArgs["result"]["things_to_review"]>
  composites: {}
}

/**
 * Model things_to_review
 * 
 */
export type things_to_review = runtime.Types.DefaultSelection<things_to_reviewPayload>
export type External_LinksPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "External_Links"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    type: string
    url: string
    language: string | null
    date_created: Date
  }, ExtArgs["result"]["external_Links"]>
  composites: {}
}

/**
 * Model External_Links
 * 
 */
export type External_Links = runtime.Types.DefaultSelection<External_LinksPayload>
export type supply_and_demandPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "supply_and_demand"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    date: Date
    season: string | null
    country: string | null
    beginning_stocks_usda: Prisma.Decimal | null
    beginning_stocks_eap: Prisma.Decimal | null
    production_usda: Prisma.Decimal | null
    production_eap: Prisma.Decimal | null
    imports_usda: Prisma.Decimal | null
    imports_eap: Prisma.Decimal | null
    domestic_use_usda: Prisma.Decimal | null
    domestic_use_eap: Prisma.Decimal | null
    exports_usda: Prisma.Decimal | null
    exports_eap: Prisma.Decimal | null
    ending_stocks_usda: Prisma.Decimal | null
    ending_stocks_eap: Prisma.Decimal | null
    projected: boolean | null
  }, ExtArgs["result"]["supply_and_demand"]>
  composites: {}
}

/**
 * Model supply_and_demand
 * 
 */
export type supply_and_demand = runtime.Types.DefaultSelection<supply_and_demandPayload>
export type us_export_salesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "us_export_sales"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    week_ending: Date
    weekly_exports: number | null
    accumulated_exports: number | null
    net_sales: number | null
    outstanding_sales: number | null
    next_marketing_year_net_sales: number | null
    next_marketing_year_outstanding_sales: number | null
  }, ExtArgs["result"]["us_export_sales"]>
  composites: {}
}

/**
 * Model us_export_sales
 * 
 */
export type us_export_sales = runtime.Types.DefaultSelection<us_export_salesPayload>
export type commitment_of_tradersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "commitment_of_traders"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    calendar_year: number
    crop_year: string
    month: string
    week: number | null
    report_date_as_dd_mm_yyyy: Date
    open_interest_all: number | null
    producer_merchant_net: number | null
    swap_position_net: number | null
    managed_money_long: number | null
    managed_money_short: number | null
    managed_money_net: number | null
    other_reportables_net: number | null
    total_reportables_net: number | null
    non_reportables_net: number | null
    specs_net: number | null
  }, ExtArgs["result"]["commitment_of_traders"]>
  composites: {}
}

/**
 * Model commitment_of_traders
 * 
 */
export type commitment_of_traders = runtime.Types.DefaultSelection<commitment_of_tradersPayload>
export type cotton_on_callPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "cotton_on_call"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    date: Date
    season_week: number | null
    week: number
    season: string
    october_sales: number | null
    december_sales: number | null
    march_sales: number | null
    may_sales: number | null
    july_sales: number | null
    total_on_call_sales: number | null
    october_purchases: number | null
    december_purchases: number | null
    march_purchases: number | null
    may_purchases: number | null
    july_purchases: number | null
    total_on_call_purchases: number | null
    total_net_u_oc_position: number | null
    total_net_change: number | null
  }, ExtArgs["result"]["cotton_on_call"]>
  composites: {}
}

/**
 * Model cotton_on_call
 * 
 */
export type cotton_on_call = runtime.Types.DefaultSelection<cotton_on_callPayload>
export type commentsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "comments"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    comment: string
    section: string
    date_of_comment: Date
    added_by: string
  }, ExtArgs["result"]["comments"]>
  composites: {}
}

/**
 * Model comments
 * 
 */
export type comments = runtime.Types.DefaultSelection<commentsPayload>
export type future_contracts_studyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "future_contracts_study"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    year: string
    month_of_high: number | null
    date_of_high: Date | null
    high: Prisma.Decimal | null
    month_of_low: number | null
    date_of_low: Date | null
    low: Prisma.Decimal | null
    price_range_between_high_and_low: Prisma.Decimal | null
    day_range_between_high_and_low: Prisma.Decimal | null
    inverse: string | null
    comments: string | null
  }, ExtArgs["result"]["future_contracts_study"]>
  composites: {}
}

/**
 * Model future_contracts_study
 * 
 */
export type future_contracts_study = runtime.Types.DefaultSelection<future_contracts_studyPayload>
export type cotton_contractsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "cotton_contracts"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    datetime: Date
    contract: string
    high: Prisma.Decimal | null
    low: Prisma.Decimal | null
    open: Prisma.Decimal | null
    close: Prisma.Decimal | null
    change: Prisma.Decimal | null
    rolling_average_200_day: Prisma.Decimal | null
    rolling_average_100_day: Prisma.Decimal | null
    rolling_average_50_day: Prisma.Decimal | null
  }, ExtArgs["result"]["cotton_contracts"]>
  composites: {}
}

/**
 * Model cotton_contracts
 * 
 */
export type cotton_contracts = runtime.Types.DefaultSelection<cotton_contractsPayload>
export type monthly_indexPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "monthly_index"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    month: string
    year: number
    inverse_month: string
    probability_rate: string
  }, ExtArgs["result"]["monthly_index"]>
  composites: {}
}

/**
 * Model monthly_index
 * 
 */
export type monthly_index = runtime.Types.DefaultSelection<monthly_indexPayload>
export type seasonal_indexPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "seasonal_index"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    season: string
    inverse_year: string
    probability_rate: string
  }, ExtArgs["result"]["seasonal_index"]>
  composites: {}
}

/**
 * Model seasonal_index
 * 
 */
export type seasonal_index = runtime.Types.DefaultSelection<seasonal_indexPayload>
export type comparison_chartPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "comparison_chart"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    date_of_close: Date
    cotton_spot_price: Prisma.Decimal | null
    dollar_basket_spot_price: Prisma.Decimal | null
    crude_oil_spot_price: Prisma.Decimal | null
  }, ExtArgs["result"]["comparison_chart"]>
  composites: {}
}

/**
 * Model comparison_chart
 * 
 */
export type comparison_chart = runtime.Types.DefaultSelection<comparison_chartPayload>
export type snapshot_strategyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "snapshot_strategy"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    title_of_snapshot_strategy: string
    image_of_snapshot_strategy: string | null
    text_of_snapshot_strategy: string
    date_of_snapshot_strategy: Date
    valid: boolean
    news_type: string
    impact: string | null
    added_by: string
    verified: boolean
  }, ExtArgs["result"]["snapshot_strategy"]>
  composites: {}
}

/**
 * Model snapshot_strategy
 * 
 */
export type snapshot_strategy = runtime.Types.DefaultSelection<snapshot_strategyPayload>
export type basis_comparisonPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "basis_comparison"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    date_of_basis_report: Date
    country: string
    cost_type: string
    contract_december_2023: number
    contract_december_2024: number
    added_by: string
  }, ExtArgs["result"]["basis_comparison"]>
  composites: {}
}

/**
 * Model basis_comparison
 * 
 */
export type basis_comparison = runtime.Types.DefaultSelection<basis_comparisonPayload>
export type in_country_newsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "in_country_news"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    country: string | null
    image_of_in_country_news: string | null
    title_of_in_country_news: string
    text_of_in_country_news: string
    date_of_in_country_news: Date
    impact: string | null
    added_by: string
    verified: boolean
  }, ExtArgs["result"]["in_country_news"]>
  composites: {}
}

/**
 * Model in_country_news
 * 
 */
export type in_country_news = runtime.Types.DefaultSelection<in_country_newsPayload>
export type sentiment_surveyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "sentiment_survey"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    bullish_or_bearish: string
    bullish_or_bearish_value: Prisma.Decimal | null
    high: Prisma.Decimal | null
    low: Prisma.Decimal | null
    intraday_average_points: Prisma.Decimal | null
    open_interest: Prisma.Decimal | null
    date_of_survey: Date | null
    added_by: string
  }, ExtArgs["result"]["sentiment_survey"]>
  composites: {}
}

/**
 * Model sentiment_survey
 * 
 */
export type sentiment_survey = runtime.Types.DefaultSelection<sentiment_surveyPayload>
export type comparison_charts_with_17_months_yearPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "comparison_charts_with_17_months_year"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    season: string
    low_price: Prisma.Decimal | null
    date_of_low: Date
    month_of_low: number
    calendar_week_of_low: number
    high_price: Prisma.Decimal | null
    date_of_high: Date
    month_of_high: number
    calendar_week_of_high: number
    range_between_high_low: Prisma.Decimal | null
    rank_of_price_range: number
    percentage_rate_to_low: Prisma.Decimal | null
    day_range_between_high_low: number
    rank_between_high_low: number
    inverse_season: string
    us_seasonal_inflation: Prisma.Decimal | null
    us_inflation_cumm: Prisma.Decimal | null
    us_interest_rate_mov: Prisma.Decimal | null
    us_interest_cumm: Prisma.Decimal | null
    world_population_cumm: number
    world_population_mov: number
    world_acreage: number
    world_acreage_movement: number
  }, ExtArgs["result"]["comparison_charts_with_17_months_year"]>
  composites: {}
}

/**
 * Model comparison_charts_with_17_months_year
 * 
 */
export type comparison_charts_with_17_months_year = runtime.Types.DefaultSelection<comparison_charts_with_17_months_yearPayload>
export type Temporary_StoragePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Temporary_Storage"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    data: string
    created_at: Date
  }, ExtArgs["result"]["temporary_Storage"]>
  composites: {}
}

/**
 * Model Temporary_Storage
 * 
 */
export type Temporary_Storage = runtime.Types.DefaultSelection<Temporary_StoragePayload>
export type Report_TemplatesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Report_Templates"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    name: string
    data: string
    company: string
    created_at: Date
  }, ExtArgs["result"]["report_Templates"]>
  composites: {}
}

/**
 * Model Report_Templates
 * 
 */
export type Report_Templates = runtime.Types.DefaultSelection<Report_TemplatesPayload>
export type Dashboard_TemplatesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Dashboard_Templates"
  objects: {}
  scalars: $Extensions.GetResult<{
    record_id: string
    data: string
    company: string
    created_at: Date
  }, ExtArgs["result"]["dashboard_Templates"]>
  composites: {}
}

/**
 * Model Dashboard_Templates
 * 
 */
export type Dashboard_Templates = runtime.Types.DefaultSelection<Dashboard_TemplatesPayload>
export type DocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Document"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    company: string
    user_id: string | null
    filetype: string
    linkedType: string
    fileName: string | null
    createdAt: Date | null
  }, ExtArgs["result"]["document"]>
  composites: {}
}

/**
 * Model Document
 * 
 */
export type Document = runtime.Types.DefaultSelection<DocumentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Examples
 * const examples = await prisma.example.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Examples
   * const examples = await prisma.example.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.example`: Exposes CRUD operations for the **Example** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Examples
    * const examples = await prisma.example.findMany()
    * ```
    */
  get example(): Prisma.ExampleDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.marketplace`: Exposes CRUD operations for the **Marketplace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marketplaces
    * const marketplaces = await prisma.marketplace.findMany()
    * ```
    */
  get marketplace(): Prisma.MarketplaceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.marketplaceAgent`: Exposes CRUD operations for the **MarketplaceAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceAgents
    * const marketplaceAgents = await prisma.marketplaceAgent.findMany()
    * ```
    */
  get marketplaceAgent(): Prisma.MarketplaceAgentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.marketplaceBuyer`: Exposes CRUD operations for the **MarketplaceBuyer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceBuyers
    * const marketplaceBuyers = await prisma.marketplaceBuyer.findMany()
    * ```
    */
  get marketplaceBuyer(): Prisma.MarketplaceBuyerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.a_index`: Exposes CRUD operations for the **a_index** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more A_indices
    * const a_indices = await prisma.a_index.findMany()
    * ```
    */
  get a_index(): Prisma.a_indexDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.fixed_cotton`: Exposes CRUD operations for the **fixed_cotton** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fixed_cottons
    * const fixed_cottons = await prisma.fixed_cotton.findMany()
    * ```
    */
  get fixed_cotton(): Prisma.fixed_cottonDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.unfixed_cotton`: Exposes CRUD operations for the **unfixed_cotton** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Unfixed_cottons
    * const unfixed_cottons = await prisma.unfixed_cotton.findMany()
    * ```
    */
  get unfixed_cotton(): Prisma.unfixed_cottonDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.strategy_log`: Exposes CRUD operations for the **strategy_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Strategy_logs
    * const strategy_logs = await prisma.strategy_log.findMany()
    * ```
    */
  get strategy_log(): Prisma.strategy_logDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.producer_production_estimates`: Exposes CRUD operations for the **producer_production_estimates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Producer_production_estimates
    * const producer_production_estimates = await prisma.producer_production_estimates.findMany()
    * ```
    */
  get producer_production_estimates(): Prisma.producer_production_estimatesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.producer_cost_estimates`: Exposes CRUD operations for the **producer_cost_estimates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Producer_cost_estimates
    * const producer_cost_estimates = await prisma.producer_cost_estimates.findMany()
    * ```
    */
  get producer_cost_estimates(): Prisma.producer_cost_estimatesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.producer_commercialisation_estimates`: Exposes CRUD operations for the **producer_commercialisation_estimates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Producer_commercialisation_estimates
    * const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.findMany()
    * ```
    */
  get producer_commercialisation_estimates(): Prisma.producer_commercialisation_estimatesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.bug_report`: Exposes CRUD operations for the **bug_report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bug_reports
    * const bug_reports = await prisma.bug_report.findMany()
    * ```
    */
  get bug_report(): Prisma.bug_reportDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.suggestions`: Exposes CRUD operations for the **suggestions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suggestions
    * const suggestions = await prisma.suggestions.findMany()
    * ```
    */
  get suggestions(): Prisma.suggestionsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.upcoming_changes`: Exposes CRUD operations for the **upcoming_changes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Upcoming_changes
    * const upcoming_changes = await prisma.upcoming_changes.findMany()
    * ```
    */
  get upcoming_changes(): Prisma.upcoming_changesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.conclusion`: Exposes CRUD operations for the **conclusion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conclusions
    * const conclusions = await prisma.conclusion.findMany()
    * ```
    */
  get conclusion(): Prisma.conclusionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.demo_Requests`: Exposes CRUD operations for the **Demo_Requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Demo_Requests
    * const demo_Requests = await prisma.demo_Requests.findMany()
    * ```
    */
  get demo_Requests(): Prisma.Demo_RequestsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.general_Inquiries`: Exposes CRUD operations for the **General_Inquiries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more General_Inquiries
    * const general_Inquiries = await prisma.general_Inquiries.findMany()
    * ```
    */
  get general_Inquiries(): Prisma.General_InquiriesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.things_to_review`: Exposes CRUD operations for the **things_to_review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Things_to_reviews
    * const things_to_reviews = await prisma.things_to_review.findMany()
    * ```
    */
  get things_to_review(): Prisma.things_to_reviewDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.external_Links`: Exposes CRUD operations for the **External_Links** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more External_Links
    * const external_Links = await prisma.external_Links.findMany()
    * ```
    */
  get external_Links(): Prisma.External_LinksDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.supply_and_demand`: Exposes CRUD operations for the **supply_and_demand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supply_and_demands
    * const supply_and_demands = await prisma.supply_and_demand.findMany()
    * ```
    */
  get supply_and_demand(): Prisma.supply_and_demandDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.us_export_sales`: Exposes CRUD operations for the **us_export_sales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Us_export_sales
    * const us_export_sales = await prisma.us_export_sales.findMany()
    * ```
    */
  get us_export_sales(): Prisma.us_export_salesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.commitment_of_traders`: Exposes CRUD operations for the **commitment_of_traders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commitment_of_traders
    * const commitment_of_traders = await prisma.commitment_of_traders.findMany()
    * ```
    */
  get commitment_of_traders(): Prisma.commitment_of_tradersDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.cotton_on_call`: Exposes CRUD operations for the **cotton_on_call** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cotton_on_calls
    * const cotton_on_calls = await prisma.cotton_on_call.findMany()
    * ```
    */
  get cotton_on_call(): Prisma.cotton_on_callDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.commentsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.future_contracts_study`: Exposes CRUD operations for the **future_contracts_study** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Future_contracts_studies
    * const future_contracts_studies = await prisma.future_contracts_study.findMany()
    * ```
    */
  get future_contracts_study(): Prisma.future_contracts_studyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.cotton_contracts`: Exposes CRUD operations for the **cotton_contracts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cotton_contracts
    * const cotton_contracts = await prisma.cotton_contracts.findMany()
    * ```
    */
  get cotton_contracts(): Prisma.cotton_contractsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.monthly_index`: Exposes CRUD operations for the **monthly_index** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monthly_indices
    * const monthly_indices = await prisma.monthly_index.findMany()
    * ```
    */
  get monthly_index(): Prisma.monthly_indexDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.seasonal_index`: Exposes CRUD operations for the **seasonal_index** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasonal_indices
    * const seasonal_indices = await prisma.seasonal_index.findMany()
    * ```
    */
  get seasonal_index(): Prisma.seasonal_indexDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.comparison_chart`: Exposes CRUD operations for the **comparison_chart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comparison_charts
    * const comparison_charts = await prisma.comparison_chart.findMany()
    * ```
    */
  get comparison_chart(): Prisma.comparison_chartDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.snapshot_strategy`: Exposes CRUD operations for the **snapshot_strategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Snapshot_strategies
    * const snapshot_strategies = await prisma.snapshot_strategy.findMany()
    * ```
    */
  get snapshot_strategy(): Prisma.snapshot_strategyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.basis_comparison`: Exposes CRUD operations for the **basis_comparison** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Basis_comparisons
    * const basis_comparisons = await prisma.basis_comparison.findMany()
    * ```
    */
  get basis_comparison(): Prisma.basis_comparisonDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.in_country_news`: Exposes CRUD operations for the **in_country_news** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more In_country_news
    * const in_country_news = await prisma.in_country_news.findMany()
    * ```
    */
  get in_country_news(): Prisma.in_country_newsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.sentiment_survey`: Exposes CRUD operations for the **sentiment_survey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sentiment_surveys
    * const sentiment_surveys = await prisma.sentiment_survey.findMany()
    * ```
    */
  get sentiment_survey(): Prisma.sentiment_surveyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.comparison_charts_with_17_months_year`: Exposes CRUD operations for the **comparison_charts_with_17_months_year** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comparison_charts_with_17_months_years
    * const comparison_charts_with_17_months_years = await prisma.comparison_charts_with_17_months_year.findMany()
    * ```
    */
  get comparison_charts_with_17_months_year(): Prisma.comparison_charts_with_17_months_yearDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.temporary_Storage`: Exposes CRUD operations for the **Temporary_Storage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Temporary_Storages
    * const temporary_Storages = await prisma.temporary_Storage.findMany()
    * ```
    */
  get temporary_Storage(): Prisma.Temporary_StorageDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.report_Templates`: Exposes CRUD operations for the **Report_Templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Report_Templates
    * const report_Templates = await prisma.report_Templates.findMany()
    * ```
    */
  get report_Templates(): Prisma.Report_TemplatesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.dashboard_Templates`: Exposes CRUD operations for the **Dashboard_Templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dashboard_Templates
    * const dashboard_Templates = await prisma.dashboard_Templates.findMany()
    * ```
    */
  get dashboard_Templates(): Prisma.Dashboard_TemplatesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Example: 'Example',
    Account: 'Account',
    Session: 'Session',
    Company: 'Company',
    VerificationToken: 'VerificationToken',
    User: 'User',
    Notification: 'Notification',
    Marketplace: 'Marketplace',
    MarketplaceAgent: 'MarketplaceAgent',
    MarketplaceBuyer: 'MarketplaceBuyer',
    a_index: 'a_index',
    fixed_cotton: 'fixed_cotton',
    unfixed_cotton: 'unfixed_cotton',
    strategy_log: 'strategy_log',
    producer_production_estimates: 'producer_production_estimates',
    producer_cost_estimates: 'producer_cost_estimates',
    producer_commercialisation_estimates: 'producer_commercialisation_estimates',
    bug_report: 'bug_report',
    suggestions: 'suggestions',
    upcoming_changes: 'upcoming_changes',
    conclusion: 'conclusion',
    Demo_Requests: 'Demo_Requests',
    General_Inquiries: 'General_Inquiries',
    things_to_review: 'things_to_review',
    External_Links: 'External_Links',
    supply_and_demand: 'supply_and_demand',
    us_export_sales: 'us_export_sales',
    commitment_of_traders: 'commitment_of_traders',
    cotton_on_call: 'cotton_on_call',
    comments: 'comments',
    future_contracts_study: 'future_contracts_study',
    cotton_contracts: 'cotton_contracts',
    monthly_index: 'monthly_index',
    seasonal_index: 'seasonal_index',
    comparison_chart: 'comparison_chart',
    snapshot_strategy: 'snapshot_strategy',
    basis_comparison: 'basis_comparison',
    in_country_news: 'in_country_news',
    sentiment_survey: 'sentiment_survey',
    comparison_charts_with_17_months_year: 'comparison_charts_with_17_months_year',
    Temporary_Storage: 'Temporary_Storage',
    Report_Templates: 'Report_Templates',
    Dashboard_Templates: 'Dashboard_Templates',
    Document: 'Document'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'example' | 'account' | 'session' | 'company' | 'verificationToken' | 'user' | 'notification' | 'marketplace' | 'marketplaceAgent' | 'marketplaceBuyer' | 'a_index' | 'fixed_cotton' | 'unfixed_cotton' | 'strategy_log' | 'producer_production_estimates' | 'producer_cost_estimates' | 'producer_commercialisation_estimates' | 'bug_report' | 'suggestions' | 'upcoming_changes' | 'conclusion' | 'demo_Requests' | 'general_Inquiries' | 'things_to_review' | 'external_Links' | 'supply_and_demand' | 'us_export_sales' | 'commitment_of_traders' | 'cotton_on_call' | 'comments' | 'future_contracts_study' | 'cotton_contracts' | 'monthly_index' | 'seasonal_index' | 'comparison_chart' | 'snapshot_strategy' | 'basis_comparison' | 'in_country_news' | 'sentiment_survey' | 'comparison_charts_with_17_months_year' | 'temporary_Storage' | 'report_Templates' | 'dashboard_Templates' | 'document'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Example: {
        payload: ExamplePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ExampleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExampleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExamplePayload>
          }
          findFirst: {
            args: Prisma.ExampleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExampleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExamplePayload>
          }
          findMany: {
            args: Prisma.ExampleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExamplePayload>[]
          }
          create: {
            args: Prisma.ExampleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExamplePayload>
          }
          createMany: {
            args: Prisma.ExampleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ExampleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExamplePayload>
          }
          update: {
            args: Prisma.ExampleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExamplePayload>
          }
          deleteMany: {
            args: Prisma.ExampleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ExampleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ExampleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExamplePayload>
          }
          aggregate: {
            args: Prisma.ExampleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExample>
          }
          groupBy: {
            args: Prisma.ExampleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExampleCountArgs<ExtArgs>,
            result: $Utils.Optional<ExampleCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: AccountPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: SessionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: CompanyPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: VerificationTokenPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: NotificationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Marketplace: {
        payload: MarketplacePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.MarketplaceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplacePayload>
          }
          findFirst: {
            args: Prisma.MarketplaceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplacePayload>
          }
          findMany: {
            args: Prisma.MarketplaceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplacePayload>[]
          }
          create: {
            args: Prisma.MarketplaceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplacePayload>
          }
          createMany: {
            args: Prisma.MarketplaceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MarketplaceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplacePayload>
          }
          update: {
            args: Prisma.MarketplaceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplacePayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MarketplaceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplacePayload>
          }
          aggregate: {
            args: Prisma.MarketplaceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMarketplace>
          }
          groupBy: {
            args: Prisma.MarketplaceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MarketplaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceCountArgs<ExtArgs>,
            result: $Utils.Optional<MarketplaceCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceAgent: {
        payload: MarketplaceAgentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.MarketplaceAgentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceAgentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceAgentPayload>
          }
          findFirst: {
            args: Prisma.MarketplaceAgentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceAgentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceAgentPayload>
          }
          findMany: {
            args: Prisma.MarketplaceAgentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceAgentPayload>[]
          }
          create: {
            args: Prisma.MarketplaceAgentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceAgentPayload>
          }
          createMany: {
            args: Prisma.MarketplaceAgentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MarketplaceAgentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceAgentPayload>
          }
          update: {
            args: Prisma.MarketplaceAgentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceAgentPayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceAgentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceAgentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MarketplaceAgentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceAgentPayload>
          }
          aggregate: {
            args: Prisma.MarketplaceAgentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMarketplaceAgent>
          }
          groupBy: {
            args: Prisma.MarketplaceAgentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MarketplaceAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceAgentCountArgs<ExtArgs>,
            result: $Utils.Optional<MarketplaceAgentCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceBuyer: {
        payload: MarketplaceBuyerPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.MarketplaceBuyerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceBuyerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceBuyerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceBuyerPayload>
          }
          findFirst: {
            args: Prisma.MarketplaceBuyerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceBuyerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceBuyerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceBuyerPayload>
          }
          findMany: {
            args: Prisma.MarketplaceBuyerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceBuyerPayload>[]
          }
          create: {
            args: Prisma.MarketplaceBuyerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceBuyerPayload>
          }
          createMany: {
            args: Prisma.MarketplaceBuyerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MarketplaceBuyerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceBuyerPayload>
          }
          update: {
            args: Prisma.MarketplaceBuyerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceBuyerPayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceBuyerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceBuyerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MarketplaceBuyerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MarketplaceBuyerPayload>
          }
          aggregate: {
            args: Prisma.MarketplaceBuyerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMarketplaceBuyer>
          }
          groupBy: {
            args: Prisma.MarketplaceBuyerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MarketplaceBuyerGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceBuyerCountArgs<ExtArgs>,
            result: $Utils.Optional<MarketplaceBuyerCountAggregateOutputType> | number
          }
        }
      }
      a_index: {
        payload: a_indexPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.a_indexFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<a_indexPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.a_indexFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<a_indexPayload>
          }
          findFirst: {
            args: Prisma.a_indexFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<a_indexPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.a_indexFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<a_indexPayload>
          }
          findMany: {
            args: Prisma.a_indexFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<a_indexPayload>[]
          }
          create: {
            args: Prisma.a_indexCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<a_indexPayload>
          }
          createMany: {
            args: Prisma.a_indexCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.a_indexDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<a_indexPayload>
          }
          update: {
            args: Prisma.a_indexUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<a_indexPayload>
          }
          deleteMany: {
            args: Prisma.a_indexDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.a_indexUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.a_indexUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<a_indexPayload>
          }
          aggregate: {
            args: Prisma.A_indexAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateA_index>
          }
          groupBy: {
            args: Prisma.A_indexGroupByArgs<ExtArgs>,
            result: $Utils.Optional<A_indexGroupByOutputType>[]
          }
          count: {
            args: Prisma.a_indexCountArgs<ExtArgs>,
            result: $Utils.Optional<A_indexCountAggregateOutputType> | number
          }
        }
      }
      fixed_cotton: {
        payload: fixed_cottonPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.fixed_cottonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixed_cottonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fixed_cottonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixed_cottonPayload>
          }
          findFirst: {
            args: Prisma.fixed_cottonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixed_cottonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fixed_cottonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixed_cottonPayload>
          }
          findMany: {
            args: Prisma.fixed_cottonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixed_cottonPayload>[]
          }
          create: {
            args: Prisma.fixed_cottonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixed_cottonPayload>
          }
          createMany: {
            args: Prisma.fixed_cottonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.fixed_cottonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixed_cottonPayload>
          }
          update: {
            args: Prisma.fixed_cottonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixed_cottonPayload>
          }
          deleteMany: {
            args: Prisma.fixed_cottonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.fixed_cottonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.fixed_cottonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fixed_cottonPayload>
          }
          aggregate: {
            args: Prisma.Fixed_cottonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFixed_cotton>
          }
          groupBy: {
            args: Prisma.Fixed_cottonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Fixed_cottonGroupByOutputType>[]
          }
          count: {
            args: Prisma.fixed_cottonCountArgs<ExtArgs>,
            result: $Utils.Optional<Fixed_cottonCountAggregateOutputType> | number
          }
        }
      }
      unfixed_cotton: {
        payload: unfixed_cottonPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.unfixed_cottonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<unfixed_cottonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.unfixed_cottonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<unfixed_cottonPayload>
          }
          findFirst: {
            args: Prisma.unfixed_cottonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<unfixed_cottonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.unfixed_cottonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<unfixed_cottonPayload>
          }
          findMany: {
            args: Prisma.unfixed_cottonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<unfixed_cottonPayload>[]
          }
          create: {
            args: Prisma.unfixed_cottonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<unfixed_cottonPayload>
          }
          createMany: {
            args: Prisma.unfixed_cottonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.unfixed_cottonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<unfixed_cottonPayload>
          }
          update: {
            args: Prisma.unfixed_cottonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<unfixed_cottonPayload>
          }
          deleteMany: {
            args: Prisma.unfixed_cottonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.unfixed_cottonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.unfixed_cottonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<unfixed_cottonPayload>
          }
          aggregate: {
            args: Prisma.Unfixed_cottonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUnfixed_cotton>
          }
          groupBy: {
            args: Prisma.Unfixed_cottonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Unfixed_cottonGroupByOutputType>[]
          }
          count: {
            args: Prisma.unfixed_cottonCountArgs<ExtArgs>,
            result: $Utils.Optional<Unfixed_cottonCountAggregateOutputType> | number
          }
        }
      }
      strategy_log: {
        payload: strategy_logPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.strategy_logFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<strategy_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.strategy_logFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<strategy_logPayload>
          }
          findFirst: {
            args: Prisma.strategy_logFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<strategy_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.strategy_logFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<strategy_logPayload>
          }
          findMany: {
            args: Prisma.strategy_logFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<strategy_logPayload>[]
          }
          create: {
            args: Prisma.strategy_logCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<strategy_logPayload>
          }
          createMany: {
            args: Prisma.strategy_logCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.strategy_logDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<strategy_logPayload>
          }
          update: {
            args: Prisma.strategy_logUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<strategy_logPayload>
          }
          deleteMany: {
            args: Prisma.strategy_logDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.strategy_logUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.strategy_logUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<strategy_logPayload>
          }
          aggregate: {
            args: Prisma.Strategy_logAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStrategy_log>
          }
          groupBy: {
            args: Prisma.Strategy_logGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Strategy_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.strategy_logCountArgs<ExtArgs>,
            result: $Utils.Optional<Strategy_logCountAggregateOutputType> | number
          }
        }
      }
      producer_production_estimates: {
        payload: producer_production_estimatesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.producer_production_estimatesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_production_estimatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.producer_production_estimatesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_production_estimatesPayload>
          }
          findFirst: {
            args: Prisma.producer_production_estimatesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_production_estimatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.producer_production_estimatesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_production_estimatesPayload>
          }
          findMany: {
            args: Prisma.producer_production_estimatesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_production_estimatesPayload>[]
          }
          create: {
            args: Prisma.producer_production_estimatesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_production_estimatesPayload>
          }
          createMany: {
            args: Prisma.producer_production_estimatesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.producer_production_estimatesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_production_estimatesPayload>
          }
          update: {
            args: Prisma.producer_production_estimatesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_production_estimatesPayload>
          }
          deleteMany: {
            args: Prisma.producer_production_estimatesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.producer_production_estimatesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.producer_production_estimatesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_production_estimatesPayload>
          }
          aggregate: {
            args: Prisma.Producer_production_estimatesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProducer_production_estimates>
          }
          groupBy: {
            args: Prisma.Producer_production_estimatesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Producer_production_estimatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.producer_production_estimatesCountArgs<ExtArgs>,
            result: $Utils.Optional<Producer_production_estimatesCountAggregateOutputType> | number
          }
        }
      }
      producer_cost_estimates: {
        payload: producer_cost_estimatesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.producer_cost_estimatesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_cost_estimatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.producer_cost_estimatesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_cost_estimatesPayload>
          }
          findFirst: {
            args: Prisma.producer_cost_estimatesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_cost_estimatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.producer_cost_estimatesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_cost_estimatesPayload>
          }
          findMany: {
            args: Prisma.producer_cost_estimatesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_cost_estimatesPayload>[]
          }
          create: {
            args: Prisma.producer_cost_estimatesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_cost_estimatesPayload>
          }
          createMany: {
            args: Prisma.producer_cost_estimatesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.producer_cost_estimatesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_cost_estimatesPayload>
          }
          update: {
            args: Prisma.producer_cost_estimatesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_cost_estimatesPayload>
          }
          deleteMany: {
            args: Prisma.producer_cost_estimatesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.producer_cost_estimatesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.producer_cost_estimatesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_cost_estimatesPayload>
          }
          aggregate: {
            args: Prisma.Producer_cost_estimatesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProducer_cost_estimates>
          }
          groupBy: {
            args: Prisma.Producer_cost_estimatesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Producer_cost_estimatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.producer_cost_estimatesCountArgs<ExtArgs>,
            result: $Utils.Optional<Producer_cost_estimatesCountAggregateOutputType> | number
          }
        }
      }
      producer_commercialisation_estimates: {
        payload: producer_commercialisation_estimatesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.producer_commercialisation_estimatesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_commercialisation_estimatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.producer_commercialisation_estimatesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_commercialisation_estimatesPayload>
          }
          findFirst: {
            args: Prisma.producer_commercialisation_estimatesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_commercialisation_estimatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.producer_commercialisation_estimatesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_commercialisation_estimatesPayload>
          }
          findMany: {
            args: Prisma.producer_commercialisation_estimatesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_commercialisation_estimatesPayload>[]
          }
          create: {
            args: Prisma.producer_commercialisation_estimatesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_commercialisation_estimatesPayload>
          }
          createMany: {
            args: Prisma.producer_commercialisation_estimatesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.producer_commercialisation_estimatesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_commercialisation_estimatesPayload>
          }
          update: {
            args: Prisma.producer_commercialisation_estimatesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_commercialisation_estimatesPayload>
          }
          deleteMany: {
            args: Prisma.producer_commercialisation_estimatesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.producer_commercialisation_estimatesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.producer_commercialisation_estimatesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<producer_commercialisation_estimatesPayload>
          }
          aggregate: {
            args: Prisma.Producer_commercialisation_estimatesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProducer_commercialisation_estimates>
          }
          groupBy: {
            args: Prisma.Producer_commercialisation_estimatesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Producer_commercialisation_estimatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.producer_commercialisation_estimatesCountArgs<ExtArgs>,
            result: $Utils.Optional<Producer_commercialisation_estimatesCountAggregateOutputType> | number
          }
        }
      }
      bug_report: {
        payload: bug_reportPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.bug_reportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bug_reportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bug_reportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bug_reportPayload>
          }
          findFirst: {
            args: Prisma.bug_reportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bug_reportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bug_reportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bug_reportPayload>
          }
          findMany: {
            args: Prisma.bug_reportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bug_reportPayload>[]
          }
          create: {
            args: Prisma.bug_reportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bug_reportPayload>
          }
          createMany: {
            args: Prisma.bug_reportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bug_reportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bug_reportPayload>
          }
          update: {
            args: Prisma.bug_reportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bug_reportPayload>
          }
          deleteMany: {
            args: Prisma.bug_reportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bug_reportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bug_reportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bug_reportPayload>
          }
          aggregate: {
            args: Prisma.Bug_reportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBug_report>
          }
          groupBy: {
            args: Prisma.Bug_reportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bug_reportGroupByOutputType>[]
          }
          count: {
            args: Prisma.bug_reportCountArgs<ExtArgs>,
            result: $Utils.Optional<Bug_reportCountAggregateOutputType> | number
          }
        }
      }
      suggestions: {
        payload: suggestionsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.suggestionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<suggestionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.suggestionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<suggestionsPayload>
          }
          findFirst: {
            args: Prisma.suggestionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<suggestionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.suggestionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<suggestionsPayload>
          }
          findMany: {
            args: Prisma.suggestionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<suggestionsPayload>[]
          }
          create: {
            args: Prisma.suggestionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<suggestionsPayload>
          }
          createMany: {
            args: Prisma.suggestionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.suggestionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<suggestionsPayload>
          }
          update: {
            args: Prisma.suggestionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<suggestionsPayload>
          }
          deleteMany: {
            args: Prisma.suggestionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.suggestionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.suggestionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<suggestionsPayload>
          }
          aggregate: {
            args: Prisma.SuggestionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSuggestions>
          }
          groupBy: {
            args: Prisma.SuggestionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SuggestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.suggestionsCountArgs<ExtArgs>,
            result: $Utils.Optional<SuggestionsCountAggregateOutputType> | number
          }
        }
      }
      upcoming_changes: {
        payload: upcoming_changesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.upcoming_changesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<upcoming_changesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.upcoming_changesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<upcoming_changesPayload>
          }
          findFirst: {
            args: Prisma.upcoming_changesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<upcoming_changesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.upcoming_changesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<upcoming_changesPayload>
          }
          findMany: {
            args: Prisma.upcoming_changesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<upcoming_changesPayload>[]
          }
          create: {
            args: Prisma.upcoming_changesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<upcoming_changesPayload>
          }
          createMany: {
            args: Prisma.upcoming_changesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.upcoming_changesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<upcoming_changesPayload>
          }
          update: {
            args: Prisma.upcoming_changesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<upcoming_changesPayload>
          }
          deleteMany: {
            args: Prisma.upcoming_changesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.upcoming_changesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.upcoming_changesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<upcoming_changesPayload>
          }
          aggregate: {
            args: Prisma.Upcoming_changesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUpcoming_changes>
          }
          groupBy: {
            args: Prisma.Upcoming_changesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Upcoming_changesGroupByOutputType>[]
          }
          count: {
            args: Prisma.upcoming_changesCountArgs<ExtArgs>,
            result: $Utils.Optional<Upcoming_changesCountAggregateOutputType> | number
          }
        }
      }
      conclusion: {
        payload: conclusionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.conclusionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conclusionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conclusionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conclusionPayload>
          }
          findFirst: {
            args: Prisma.conclusionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conclusionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conclusionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conclusionPayload>
          }
          findMany: {
            args: Prisma.conclusionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conclusionPayload>[]
          }
          create: {
            args: Prisma.conclusionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conclusionPayload>
          }
          createMany: {
            args: Prisma.conclusionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.conclusionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conclusionPayload>
          }
          update: {
            args: Prisma.conclusionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conclusionPayload>
          }
          deleteMany: {
            args: Prisma.conclusionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.conclusionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.conclusionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conclusionPayload>
          }
          aggregate: {
            args: Prisma.ConclusionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConclusion>
          }
          groupBy: {
            args: Prisma.ConclusionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConclusionGroupByOutputType>[]
          }
          count: {
            args: Prisma.conclusionCountArgs<ExtArgs>,
            result: $Utils.Optional<ConclusionCountAggregateOutputType> | number
          }
        }
      }
      Demo_Requests: {
        payload: Demo_RequestsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.Demo_RequestsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Demo_RequestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Demo_RequestsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Demo_RequestsPayload>
          }
          findFirst: {
            args: Prisma.Demo_RequestsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Demo_RequestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Demo_RequestsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Demo_RequestsPayload>
          }
          findMany: {
            args: Prisma.Demo_RequestsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Demo_RequestsPayload>[]
          }
          create: {
            args: Prisma.Demo_RequestsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Demo_RequestsPayload>
          }
          createMany: {
            args: Prisma.Demo_RequestsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Demo_RequestsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Demo_RequestsPayload>
          }
          update: {
            args: Prisma.Demo_RequestsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Demo_RequestsPayload>
          }
          deleteMany: {
            args: Prisma.Demo_RequestsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Demo_RequestsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Demo_RequestsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Demo_RequestsPayload>
          }
          aggregate: {
            args: Prisma.Demo_RequestsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDemo_Requests>
          }
          groupBy: {
            args: Prisma.Demo_RequestsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Demo_RequestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Demo_RequestsCountArgs<ExtArgs>,
            result: $Utils.Optional<Demo_RequestsCountAggregateOutputType> | number
          }
        }
      }
      General_Inquiries: {
        payload: General_InquiriesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.General_InquiriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<General_InquiriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.General_InquiriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<General_InquiriesPayload>
          }
          findFirst: {
            args: Prisma.General_InquiriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<General_InquiriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.General_InquiriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<General_InquiriesPayload>
          }
          findMany: {
            args: Prisma.General_InquiriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<General_InquiriesPayload>[]
          }
          create: {
            args: Prisma.General_InquiriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<General_InquiriesPayload>
          }
          createMany: {
            args: Prisma.General_InquiriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.General_InquiriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<General_InquiriesPayload>
          }
          update: {
            args: Prisma.General_InquiriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<General_InquiriesPayload>
          }
          deleteMany: {
            args: Prisma.General_InquiriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.General_InquiriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.General_InquiriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<General_InquiriesPayload>
          }
          aggregate: {
            args: Prisma.General_InquiriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGeneral_Inquiries>
          }
          groupBy: {
            args: Prisma.General_InquiriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<General_InquiriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.General_InquiriesCountArgs<ExtArgs>,
            result: $Utils.Optional<General_InquiriesCountAggregateOutputType> | number
          }
        }
      }
      things_to_review: {
        payload: things_to_reviewPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.things_to_reviewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<things_to_reviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.things_to_reviewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<things_to_reviewPayload>
          }
          findFirst: {
            args: Prisma.things_to_reviewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<things_to_reviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.things_to_reviewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<things_to_reviewPayload>
          }
          findMany: {
            args: Prisma.things_to_reviewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<things_to_reviewPayload>[]
          }
          create: {
            args: Prisma.things_to_reviewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<things_to_reviewPayload>
          }
          createMany: {
            args: Prisma.things_to_reviewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.things_to_reviewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<things_to_reviewPayload>
          }
          update: {
            args: Prisma.things_to_reviewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<things_to_reviewPayload>
          }
          deleteMany: {
            args: Prisma.things_to_reviewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.things_to_reviewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.things_to_reviewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<things_to_reviewPayload>
          }
          aggregate: {
            args: Prisma.Things_to_reviewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateThings_to_review>
          }
          groupBy: {
            args: Prisma.Things_to_reviewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Things_to_reviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.things_to_reviewCountArgs<ExtArgs>,
            result: $Utils.Optional<Things_to_reviewCountAggregateOutputType> | number
          }
        }
      }
      External_Links: {
        payload: External_LinksPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.External_LinksFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<External_LinksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.External_LinksFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<External_LinksPayload>
          }
          findFirst: {
            args: Prisma.External_LinksFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<External_LinksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.External_LinksFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<External_LinksPayload>
          }
          findMany: {
            args: Prisma.External_LinksFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<External_LinksPayload>[]
          }
          create: {
            args: Prisma.External_LinksCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<External_LinksPayload>
          }
          createMany: {
            args: Prisma.External_LinksCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.External_LinksDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<External_LinksPayload>
          }
          update: {
            args: Prisma.External_LinksUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<External_LinksPayload>
          }
          deleteMany: {
            args: Prisma.External_LinksDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.External_LinksUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.External_LinksUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<External_LinksPayload>
          }
          aggregate: {
            args: Prisma.External_LinksAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExternal_Links>
          }
          groupBy: {
            args: Prisma.External_LinksGroupByArgs<ExtArgs>,
            result: $Utils.Optional<External_LinksGroupByOutputType>[]
          }
          count: {
            args: Prisma.External_LinksCountArgs<ExtArgs>,
            result: $Utils.Optional<External_LinksCountAggregateOutputType> | number
          }
        }
      }
      supply_and_demand: {
        payload: supply_and_demandPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.supply_and_demandFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<supply_and_demandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supply_and_demandFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<supply_and_demandPayload>
          }
          findFirst: {
            args: Prisma.supply_and_demandFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<supply_and_demandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supply_and_demandFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<supply_and_demandPayload>
          }
          findMany: {
            args: Prisma.supply_and_demandFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<supply_and_demandPayload>[]
          }
          create: {
            args: Prisma.supply_and_demandCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<supply_and_demandPayload>
          }
          createMany: {
            args: Prisma.supply_and_demandCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.supply_and_demandDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<supply_and_demandPayload>
          }
          update: {
            args: Prisma.supply_and_demandUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<supply_and_demandPayload>
          }
          deleteMany: {
            args: Prisma.supply_and_demandDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.supply_and_demandUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.supply_and_demandUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<supply_and_demandPayload>
          }
          aggregate: {
            args: Prisma.Supply_and_demandAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupply_and_demand>
          }
          groupBy: {
            args: Prisma.Supply_and_demandGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Supply_and_demandGroupByOutputType>[]
          }
          count: {
            args: Prisma.supply_and_demandCountArgs<ExtArgs>,
            result: $Utils.Optional<Supply_and_demandCountAggregateOutputType> | number
          }
        }
      }
      us_export_sales: {
        payload: us_export_salesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.us_export_salesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<us_export_salesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.us_export_salesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<us_export_salesPayload>
          }
          findFirst: {
            args: Prisma.us_export_salesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<us_export_salesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.us_export_salesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<us_export_salesPayload>
          }
          findMany: {
            args: Prisma.us_export_salesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<us_export_salesPayload>[]
          }
          create: {
            args: Prisma.us_export_salesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<us_export_salesPayload>
          }
          createMany: {
            args: Prisma.us_export_salesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.us_export_salesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<us_export_salesPayload>
          }
          update: {
            args: Prisma.us_export_salesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<us_export_salesPayload>
          }
          deleteMany: {
            args: Prisma.us_export_salesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.us_export_salesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.us_export_salesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<us_export_salesPayload>
          }
          aggregate: {
            args: Prisma.Us_export_salesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUs_export_sales>
          }
          groupBy: {
            args: Prisma.Us_export_salesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Us_export_salesGroupByOutputType>[]
          }
          count: {
            args: Prisma.us_export_salesCountArgs<ExtArgs>,
            result: $Utils.Optional<Us_export_salesCountAggregateOutputType> | number
          }
        }
      }
      commitment_of_traders: {
        payload: commitment_of_tradersPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.commitment_of_tradersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commitment_of_tradersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commitment_of_tradersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commitment_of_tradersPayload>
          }
          findFirst: {
            args: Prisma.commitment_of_tradersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commitment_of_tradersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commitment_of_tradersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commitment_of_tradersPayload>
          }
          findMany: {
            args: Prisma.commitment_of_tradersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commitment_of_tradersPayload>[]
          }
          create: {
            args: Prisma.commitment_of_tradersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commitment_of_tradersPayload>
          }
          createMany: {
            args: Prisma.commitment_of_tradersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.commitment_of_tradersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commitment_of_tradersPayload>
          }
          update: {
            args: Prisma.commitment_of_tradersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commitment_of_tradersPayload>
          }
          deleteMany: {
            args: Prisma.commitment_of_tradersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.commitment_of_tradersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.commitment_of_tradersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commitment_of_tradersPayload>
          }
          aggregate: {
            args: Prisma.Commitment_of_tradersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommitment_of_traders>
          }
          groupBy: {
            args: Prisma.Commitment_of_tradersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Commitment_of_tradersGroupByOutputType>[]
          }
          count: {
            args: Prisma.commitment_of_tradersCountArgs<ExtArgs>,
            result: $Utils.Optional<Commitment_of_tradersCountAggregateOutputType> | number
          }
        }
      }
      cotton_on_call: {
        payload: cotton_on_callPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.cotton_on_callFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_on_callPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cotton_on_callFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_on_callPayload>
          }
          findFirst: {
            args: Prisma.cotton_on_callFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_on_callPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cotton_on_callFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_on_callPayload>
          }
          findMany: {
            args: Prisma.cotton_on_callFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_on_callPayload>[]
          }
          create: {
            args: Prisma.cotton_on_callCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_on_callPayload>
          }
          createMany: {
            args: Prisma.cotton_on_callCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.cotton_on_callDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_on_callPayload>
          }
          update: {
            args: Prisma.cotton_on_callUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_on_callPayload>
          }
          deleteMany: {
            args: Prisma.cotton_on_callDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.cotton_on_callUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.cotton_on_callUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_on_callPayload>
          }
          aggregate: {
            args: Prisma.Cotton_on_callAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCotton_on_call>
          }
          groupBy: {
            args: Prisma.Cotton_on_callGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Cotton_on_callGroupByOutputType>[]
          }
          count: {
            args: Prisma.cotton_on_callCountArgs<ExtArgs>,
            result: $Utils.Optional<Cotton_on_callCountAggregateOutputType> | number
          }
        }
      }
      comments: {
        payload: commentsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.commentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          findFirst: {
            args: Prisma.commentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          findMany: {
            args: Prisma.commentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>[]
          }
          create: {
            args: Prisma.commentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          createMany: {
            args: Prisma.commentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.commentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          update: {
            args: Prisma.commentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          deleteMany: {
            args: Prisma.commentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.commentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.commentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<commentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.CommentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentsCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      future_contracts_study: {
        payload: future_contracts_studyPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.future_contracts_studyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<future_contracts_studyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.future_contracts_studyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<future_contracts_studyPayload>
          }
          findFirst: {
            args: Prisma.future_contracts_studyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<future_contracts_studyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.future_contracts_studyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<future_contracts_studyPayload>
          }
          findMany: {
            args: Prisma.future_contracts_studyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<future_contracts_studyPayload>[]
          }
          create: {
            args: Prisma.future_contracts_studyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<future_contracts_studyPayload>
          }
          createMany: {
            args: Prisma.future_contracts_studyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.future_contracts_studyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<future_contracts_studyPayload>
          }
          update: {
            args: Prisma.future_contracts_studyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<future_contracts_studyPayload>
          }
          deleteMany: {
            args: Prisma.future_contracts_studyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.future_contracts_studyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.future_contracts_studyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<future_contracts_studyPayload>
          }
          aggregate: {
            args: Prisma.Future_contracts_studyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFuture_contracts_study>
          }
          groupBy: {
            args: Prisma.Future_contracts_studyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Future_contracts_studyGroupByOutputType>[]
          }
          count: {
            args: Prisma.future_contracts_studyCountArgs<ExtArgs>,
            result: $Utils.Optional<Future_contracts_studyCountAggregateOutputType> | number
          }
        }
      }
      cotton_contracts: {
        payload: cotton_contractsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.cotton_contractsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_contractsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cotton_contractsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_contractsPayload>
          }
          findFirst: {
            args: Prisma.cotton_contractsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_contractsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cotton_contractsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_contractsPayload>
          }
          findMany: {
            args: Prisma.cotton_contractsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_contractsPayload>[]
          }
          create: {
            args: Prisma.cotton_contractsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_contractsPayload>
          }
          createMany: {
            args: Prisma.cotton_contractsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.cotton_contractsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_contractsPayload>
          }
          update: {
            args: Prisma.cotton_contractsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_contractsPayload>
          }
          deleteMany: {
            args: Prisma.cotton_contractsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.cotton_contractsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.cotton_contractsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<cotton_contractsPayload>
          }
          aggregate: {
            args: Prisma.Cotton_contractsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCotton_contracts>
          }
          groupBy: {
            args: Prisma.Cotton_contractsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Cotton_contractsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cotton_contractsCountArgs<ExtArgs>,
            result: $Utils.Optional<Cotton_contractsCountAggregateOutputType> | number
          }
        }
      }
      monthly_index: {
        payload: monthly_indexPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.monthly_indexFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<monthly_indexPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monthly_indexFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<monthly_indexPayload>
          }
          findFirst: {
            args: Prisma.monthly_indexFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<monthly_indexPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monthly_indexFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<monthly_indexPayload>
          }
          findMany: {
            args: Prisma.monthly_indexFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<monthly_indexPayload>[]
          }
          create: {
            args: Prisma.monthly_indexCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<monthly_indexPayload>
          }
          createMany: {
            args: Prisma.monthly_indexCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.monthly_indexDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<monthly_indexPayload>
          }
          update: {
            args: Prisma.monthly_indexUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<monthly_indexPayload>
          }
          deleteMany: {
            args: Prisma.monthly_indexDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.monthly_indexUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.monthly_indexUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<monthly_indexPayload>
          }
          aggregate: {
            args: Prisma.Monthly_indexAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMonthly_index>
          }
          groupBy: {
            args: Prisma.Monthly_indexGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Monthly_indexGroupByOutputType>[]
          }
          count: {
            args: Prisma.monthly_indexCountArgs<ExtArgs>,
            result: $Utils.Optional<Monthly_indexCountAggregateOutputType> | number
          }
        }
      }
      seasonal_index: {
        payload: seasonal_indexPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.seasonal_indexFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonal_indexPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.seasonal_indexFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonal_indexPayload>
          }
          findFirst: {
            args: Prisma.seasonal_indexFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonal_indexPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.seasonal_indexFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonal_indexPayload>
          }
          findMany: {
            args: Prisma.seasonal_indexFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonal_indexPayload>[]
          }
          create: {
            args: Prisma.seasonal_indexCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonal_indexPayload>
          }
          createMany: {
            args: Prisma.seasonal_indexCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.seasonal_indexDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonal_indexPayload>
          }
          update: {
            args: Prisma.seasonal_indexUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonal_indexPayload>
          }
          deleteMany: {
            args: Prisma.seasonal_indexDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.seasonal_indexUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.seasonal_indexUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<seasonal_indexPayload>
          }
          aggregate: {
            args: Prisma.Seasonal_indexAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSeasonal_index>
          }
          groupBy: {
            args: Prisma.Seasonal_indexGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Seasonal_indexGroupByOutputType>[]
          }
          count: {
            args: Prisma.seasonal_indexCountArgs<ExtArgs>,
            result: $Utils.Optional<Seasonal_indexCountAggregateOutputType> | number
          }
        }
      }
      comparison_chart: {
        payload: comparison_chartPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.comparison_chartFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_chartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comparison_chartFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_chartPayload>
          }
          findFirst: {
            args: Prisma.comparison_chartFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_chartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comparison_chartFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_chartPayload>
          }
          findMany: {
            args: Prisma.comparison_chartFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_chartPayload>[]
          }
          create: {
            args: Prisma.comparison_chartCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_chartPayload>
          }
          createMany: {
            args: Prisma.comparison_chartCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.comparison_chartDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_chartPayload>
          }
          update: {
            args: Prisma.comparison_chartUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_chartPayload>
          }
          deleteMany: {
            args: Prisma.comparison_chartDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.comparison_chartUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.comparison_chartUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_chartPayload>
          }
          aggregate: {
            args: Prisma.Comparison_chartAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComparison_chart>
          }
          groupBy: {
            args: Prisma.Comparison_chartGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Comparison_chartGroupByOutputType>[]
          }
          count: {
            args: Prisma.comparison_chartCountArgs<ExtArgs>,
            result: $Utils.Optional<Comparison_chartCountAggregateOutputType> | number
          }
        }
      }
      snapshot_strategy: {
        payload: snapshot_strategyPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.snapshot_strategyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<snapshot_strategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.snapshot_strategyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<snapshot_strategyPayload>
          }
          findFirst: {
            args: Prisma.snapshot_strategyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<snapshot_strategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.snapshot_strategyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<snapshot_strategyPayload>
          }
          findMany: {
            args: Prisma.snapshot_strategyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<snapshot_strategyPayload>[]
          }
          create: {
            args: Prisma.snapshot_strategyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<snapshot_strategyPayload>
          }
          createMany: {
            args: Prisma.snapshot_strategyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.snapshot_strategyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<snapshot_strategyPayload>
          }
          update: {
            args: Prisma.snapshot_strategyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<snapshot_strategyPayload>
          }
          deleteMany: {
            args: Prisma.snapshot_strategyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.snapshot_strategyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.snapshot_strategyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<snapshot_strategyPayload>
          }
          aggregate: {
            args: Prisma.Snapshot_strategyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSnapshot_strategy>
          }
          groupBy: {
            args: Prisma.Snapshot_strategyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Snapshot_strategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.snapshot_strategyCountArgs<ExtArgs>,
            result: $Utils.Optional<Snapshot_strategyCountAggregateOutputType> | number
          }
        }
      }
      basis_comparison: {
        payload: basis_comparisonPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.basis_comparisonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<basis_comparisonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.basis_comparisonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<basis_comparisonPayload>
          }
          findFirst: {
            args: Prisma.basis_comparisonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<basis_comparisonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.basis_comparisonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<basis_comparisonPayload>
          }
          findMany: {
            args: Prisma.basis_comparisonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<basis_comparisonPayload>[]
          }
          create: {
            args: Prisma.basis_comparisonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<basis_comparisonPayload>
          }
          createMany: {
            args: Prisma.basis_comparisonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.basis_comparisonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<basis_comparisonPayload>
          }
          update: {
            args: Prisma.basis_comparisonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<basis_comparisonPayload>
          }
          deleteMany: {
            args: Prisma.basis_comparisonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.basis_comparisonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.basis_comparisonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<basis_comparisonPayload>
          }
          aggregate: {
            args: Prisma.Basis_comparisonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBasis_comparison>
          }
          groupBy: {
            args: Prisma.Basis_comparisonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Basis_comparisonGroupByOutputType>[]
          }
          count: {
            args: Prisma.basis_comparisonCountArgs<ExtArgs>,
            result: $Utils.Optional<Basis_comparisonCountAggregateOutputType> | number
          }
        }
      }
      in_country_news: {
        payload: in_country_newsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.in_country_newsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<in_country_newsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.in_country_newsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<in_country_newsPayload>
          }
          findFirst: {
            args: Prisma.in_country_newsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<in_country_newsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.in_country_newsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<in_country_newsPayload>
          }
          findMany: {
            args: Prisma.in_country_newsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<in_country_newsPayload>[]
          }
          create: {
            args: Prisma.in_country_newsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<in_country_newsPayload>
          }
          createMany: {
            args: Prisma.in_country_newsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.in_country_newsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<in_country_newsPayload>
          }
          update: {
            args: Prisma.in_country_newsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<in_country_newsPayload>
          }
          deleteMany: {
            args: Prisma.in_country_newsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.in_country_newsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.in_country_newsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<in_country_newsPayload>
          }
          aggregate: {
            args: Prisma.In_country_newsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIn_country_news>
          }
          groupBy: {
            args: Prisma.In_country_newsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<In_country_newsGroupByOutputType>[]
          }
          count: {
            args: Prisma.in_country_newsCountArgs<ExtArgs>,
            result: $Utils.Optional<In_country_newsCountAggregateOutputType> | number
          }
        }
      }
      sentiment_survey: {
        payload: sentiment_surveyPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.sentiment_surveyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sentiment_surveyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sentiment_surveyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sentiment_surveyPayload>
          }
          findFirst: {
            args: Prisma.sentiment_surveyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sentiment_surveyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sentiment_surveyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sentiment_surveyPayload>
          }
          findMany: {
            args: Prisma.sentiment_surveyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sentiment_surveyPayload>[]
          }
          create: {
            args: Prisma.sentiment_surveyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sentiment_surveyPayload>
          }
          createMany: {
            args: Prisma.sentiment_surveyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sentiment_surveyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sentiment_surveyPayload>
          }
          update: {
            args: Prisma.sentiment_surveyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sentiment_surveyPayload>
          }
          deleteMany: {
            args: Prisma.sentiment_surveyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sentiment_surveyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sentiment_surveyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sentiment_surveyPayload>
          }
          aggregate: {
            args: Prisma.Sentiment_surveyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSentiment_survey>
          }
          groupBy: {
            args: Prisma.Sentiment_surveyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Sentiment_surveyGroupByOutputType>[]
          }
          count: {
            args: Prisma.sentiment_surveyCountArgs<ExtArgs>,
            result: $Utils.Optional<Sentiment_surveyCountAggregateOutputType> | number
          }
        }
      }
      comparison_charts_with_17_months_year: {
        payload: comparison_charts_with_17_months_yearPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.comparison_charts_with_17_months_yearFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_charts_with_17_months_yearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comparison_charts_with_17_months_yearFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_charts_with_17_months_yearPayload>
          }
          findFirst: {
            args: Prisma.comparison_charts_with_17_months_yearFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_charts_with_17_months_yearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comparison_charts_with_17_months_yearFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_charts_with_17_months_yearPayload>
          }
          findMany: {
            args: Prisma.comparison_charts_with_17_months_yearFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_charts_with_17_months_yearPayload>[]
          }
          create: {
            args: Prisma.comparison_charts_with_17_months_yearCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_charts_with_17_months_yearPayload>
          }
          createMany: {
            args: Prisma.comparison_charts_with_17_months_yearCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.comparison_charts_with_17_months_yearDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_charts_with_17_months_yearPayload>
          }
          update: {
            args: Prisma.comparison_charts_with_17_months_yearUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_charts_with_17_months_yearPayload>
          }
          deleteMany: {
            args: Prisma.comparison_charts_with_17_months_yearDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.comparison_charts_with_17_months_yearUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.comparison_charts_with_17_months_yearUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<comparison_charts_with_17_months_yearPayload>
          }
          aggregate: {
            args: Prisma.Comparison_charts_with_17_months_yearAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComparison_charts_with_17_months_year>
          }
          groupBy: {
            args: Prisma.Comparison_charts_with_17_months_yearGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Comparison_charts_with_17_months_yearGroupByOutputType>[]
          }
          count: {
            args: Prisma.comparison_charts_with_17_months_yearCountArgs<ExtArgs>,
            result: $Utils.Optional<Comparison_charts_with_17_months_yearCountAggregateOutputType> | number
          }
        }
      }
      Temporary_Storage: {
        payload: Temporary_StoragePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.Temporary_StorageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Temporary_StoragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Temporary_StorageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Temporary_StoragePayload>
          }
          findFirst: {
            args: Prisma.Temporary_StorageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Temporary_StoragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Temporary_StorageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Temporary_StoragePayload>
          }
          findMany: {
            args: Prisma.Temporary_StorageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Temporary_StoragePayload>[]
          }
          create: {
            args: Prisma.Temporary_StorageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Temporary_StoragePayload>
          }
          createMany: {
            args: Prisma.Temporary_StorageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Temporary_StorageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Temporary_StoragePayload>
          }
          update: {
            args: Prisma.Temporary_StorageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Temporary_StoragePayload>
          }
          deleteMany: {
            args: Prisma.Temporary_StorageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Temporary_StorageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Temporary_StorageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Temporary_StoragePayload>
          }
          aggregate: {
            args: Prisma.Temporary_StorageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTemporary_Storage>
          }
          groupBy: {
            args: Prisma.Temporary_StorageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Temporary_StorageGroupByOutputType>[]
          }
          count: {
            args: Prisma.Temporary_StorageCountArgs<ExtArgs>,
            result: $Utils.Optional<Temporary_StorageCountAggregateOutputType> | number
          }
        }
      }
      Report_Templates: {
        payload: Report_TemplatesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.Report_TemplatesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Report_TemplatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Report_TemplatesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Report_TemplatesPayload>
          }
          findFirst: {
            args: Prisma.Report_TemplatesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Report_TemplatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Report_TemplatesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Report_TemplatesPayload>
          }
          findMany: {
            args: Prisma.Report_TemplatesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Report_TemplatesPayload>[]
          }
          create: {
            args: Prisma.Report_TemplatesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Report_TemplatesPayload>
          }
          createMany: {
            args: Prisma.Report_TemplatesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Report_TemplatesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Report_TemplatesPayload>
          }
          update: {
            args: Prisma.Report_TemplatesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Report_TemplatesPayload>
          }
          deleteMany: {
            args: Prisma.Report_TemplatesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Report_TemplatesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Report_TemplatesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Report_TemplatesPayload>
          }
          aggregate: {
            args: Prisma.Report_TemplatesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReport_Templates>
          }
          groupBy: {
            args: Prisma.Report_TemplatesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Report_TemplatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.Report_TemplatesCountArgs<ExtArgs>,
            result: $Utils.Optional<Report_TemplatesCountAggregateOutputType> | number
          }
        }
      }
      Dashboard_Templates: {
        payload: Dashboard_TemplatesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.Dashboard_TemplatesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Dashboard_TemplatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Dashboard_TemplatesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Dashboard_TemplatesPayload>
          }
          findFirst: {
            args: Prisma.Dashboard_TemplatesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Dashboard_TemplatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Dashboard_TemplatesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Dashboard_TemplatesPayload>
          }
          findMany: {
            args: Prisma.Dashboard_TemplatesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Dashboard_TemplatesPayload>[]
          }
          create: {
            args: Prisma.Dashboard_TemplatesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Dashboard_TemplatesPayload>
          }
          createMany: {
            args: Prisma.Dashboard_TemplatesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Dashboard_TemplatesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Dashboard_TemplatesPayload>
          }
          update: {
            args: Prisma.Dashboard_TemplatesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Dashboard_TemplatesPayload>
          }
          deleteMany: {
            args: Prisma.Dashboard_TemplatesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Dashboard_TemplatesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Dashboard_TemplatesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Dashboard_TemplatesPayload>
          }
          aggregate: {
            args: Prisma.Dashboard_TemplatesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDashboard_Templates>
          }
          groupBy: {
            args: Prisma.Dashboard_TemplatesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Dashboard_TemplatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.Dashboard_TemplatesCountArgs<ExtArgs>,
            result: $Utils.Optional<Dashboard_TemplatesCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: DocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */


  export type CompanyCountOutputType = {
    users: number
    selected_users: number
    producer_production_estimates: number
    producer_cost_estimates: number
    producer_commercialisation_estimates: number
    strategy_log: number
    fixed_cotton: number
    unfixed_cotton: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    selected_users?: boolean | CompanyCountOutputTypeCountSelected_usersArgs
    producer_production_estimates?: boolean | CompanyCountOutputTypeCountProducer_production_estimatesArgs
    producer_cost_estimates?: boolean | CompanyCountOutputTypeCountProducer_cost_estimatesArgs
    producer_commercialisation_estimates?: boolean | CompanyCountOutputTypeCountProducer_commercialisation_estimatesArgs
    strategy_log?: boolean | CompanyCountOutputTypeCountStrategy_logArgs
    fixed_cotton?: boolean | CompanyCountOutputTypeCountFixed_cottonArgs
    unfixed_cotton?: boolean | CompanyCountOutputTypeCountUnfixed_cottonArgs
  }

  // Custom InputTypes

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSelected_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProducer_production_estimatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: producer_production_estimatesWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProducer_cost_estimatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: producer_cost_estimatesWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProducer_commercialisation_estimatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: producer_commercialisation_estimatesWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountStrategy_logArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: strategy_logWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFixed_cottonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fixed_cottonWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUnfixed_cottonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: unfixed_cottonWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    macrovesta_managing: number
    accounts: number
    sessions: number
    agents: number
    buyers: number
    Marketplace: number
    Notification: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    macrovesta_managing?: boolean | UserCountOutputTypeCountMacrovesta_managingArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    agents?: boolean | UserCountOutputTypeCountAgentsArgs
    buyers?: boolean | UserCountOutputTypeCountBuyersArgs
    Marketplace?: boolean | UserCountOutputTypeCountMarketplaceArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMacrovesta_managingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MarketplaceAgentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuyersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MarketplaceBuyerWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMarketplaceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MarketplaceWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }



  /**
   * Count Type MarketplaceCountOutputType
   */


  export type MarketplaceCountOutputType = {
    agents: number
    buyers: number
  }

  export type MarketplaceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    agents?: boolean | MarketplaceCountOutputTypeCountAgentsArgs
    buyers?: boolean | MarketplaceCountOutputTypeCountBuyersArgs
  }

  // Custom InputTypes

  /**
   * MarketplaceCountOutputType without action
   */
  export type MarketplaceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceCountOutputType
     */
    select?: MarketplaceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MarketplaceCountOutputType without action
   */
  export type MarketplaceCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MarketplaceAgentWhereInput
  }


  /**
   * MarketplaceCountOutputType without action
   */
  export type MarketplaceCountOutputTypeCountBuyersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MarketplaceBuyerWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Example
   */


  export type AggregateExample = {
    _count: ExampleCountAggregateOutputType | null
    _min: ExampleMinAggregateOutputType | null
    _max: ExampleMaxAggregateOutputType | null
  }

  export type ExampleMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExampleMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExampleCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExampleMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExampleMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExampleCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExampleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Example to aggregate.
     */
    where?: ExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examples to fetch.
     */
    orderBy?: Enumerable<ExampleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Examples
    **/
    _count?: true | ExampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExampleMaxAggregateInputType
  }

  export type GetExampleAggregateType<T extends ExampleAggregateArgs> = {
        [P in keyof T & keyof AggregateExample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExample[P]>
      : GetScalarType<T[P], AggregateExample[P]>
  }




  export type ExampleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ExampleWhereInput
    orderBy?: Enumerable<ExampleOrderByWithAggregationInput>
    by: ExampleScalarFieldEnum[]
    having?: ExampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExampleCountAggregateInputType | true
    _min?: ExampleMinAggregateInputType
    _max?: ExampleMaxAggregateInputType
  }


  export type ExampleGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: ExampleCountAggregateOutputType | null
    _min: ExampleMinAggregateOutputType | null
    _max: ExampleMaxAggregateOutputType | null
  }

  type GetExampleGroupByPayload<T extends ExampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ExampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExampleGroupByOutputType[P]>
            : GetScalarType<T[P], ExampleGroupByOutputType[P]>
        }
      >
    >


  export type ExampleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["example"]>

  export type ExampleSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type ExampleGetPayload<S extends boolean | null | undefined | ExampleArgs> = $Types.GetResult<ExamplePayload, S>

  type ExampleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ExampleFindManyArgs, 'select' | 'include'> & {
      select?: ExampleCountAggregateInputType | true
    }

  export interface ExampleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Example'], meta: { name: 'Example' } }
    /**
     * Find zero or one Example that matches the filter.
     * @param {ExampleFindUniqueArgs} args - Arguments to find a Example
     * @example
     * // Get one Example
     * const example = await prisma.example.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExampleFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExampleFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Example'> extends True ? Prisma__ExampleClient<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ExampleClient<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Example that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExampleFindUniqueOrThrowArgs} args - Arguments to find a Example
     * @example
     * // Get one Example
     * const example = await prisma.example.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExampleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExampleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExampleClient<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Example that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleFindFirstArgs} args - Arguments to find a Example
     * @example
     * // Get one Example
     * const example = await prisma.example.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExampleFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExampleFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Example'> extends True ? Prisma__ExampleClient<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ExampleClient<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Example that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleFindFirstOrThrowArgs} args - Arguments to find a Example
     * @example
     * // Get one Example
     * const example = await prisma.example.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExampleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExampleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExampleClient<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Examples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Examples
     * const examples = await prisma.example.findMany()
     * 
     * // Get first 10 Examples
     * const examples = await prisma.example.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exampleWithIdOnly = await prisma.example.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExampleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExampleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Example.
     * @param {ExampleCreateArgs} args - Arguments to create a Example.
     * @example
     * // Create one Example
     * const Example = await prisma.example.create({
     *   data: {
     *     // ... data to create a Example
     *   }
     * })
     * 
    **/
    create<T extends ExampleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ExampleCreateArgs<ExtArgs>>
    ): Prisma__ExampleClient<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Examples.
     *     @param {ExampleCreateManyArgs} args - Arguments to create many Examples.
     *     @example
     *     // Create many Examples
     *     const example = await prisma.example.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExampleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExampleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Example.
     * @param {ExampleDeleteArgs} args - Arguments to delete one Example.
     * @example
     * // Delete one Example
     * const Example = await prisma.example.delete({
     *   where: {
     *     // ... filter to delete one Example
     *   }
     * })
     * 
    **/
    delete<T extends ExampleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ExampleDeleteArgs<ExtArgs>>
    ): Prisma__ExampleClient<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Example.
     * @param {ExampleUpdateArgs} args - Arguments to update one Example.
     * @example
     * // Update one Example
     * const example = await prisma.example.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExampleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ExampleUpdateArgs<ExtArgs>>
    ): Prisma__ExampleClient<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Examples.
     * @param {ExampleDeleteManyArgs} args - Arguments to filter Examples to delete.
     * @example
     * // Delete a few Examples
     * const { count } = await prisma.example.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExampleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExampleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Examples
     * const example = await prisma.example.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExampleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ExampleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Example.
     * @param {ExampleUpsertArgs} args - Arguments to update or create a Example.
     * @example
     * // Update or create a Example
     * const example = await prisma.example.upsert({
     *   create: {
     *     // ... data to create a Example
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Example we want to update
     *   }
     * })
    **/
    upsert<T extends ExampleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ExampleUpsertArgs<ExtArgs>>
    ): Prisma__ExampleClient<$Types.GetResult<ExamplePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Examples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleCountArgs} args - Arguments to filter Examples to count.
     * @example
     * // Count the number of Examples
     * const count = await prisma.example.count({
     *   where: {
     *     // ... the filter for the Examples we want to count
     *   }
     * })
    **/
    count<T extends ExampleCountArgs>(
      args?: Subset<T, ExampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Example.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExampleAggregateArgs>(args: Subset<T, ExampleAggregateArgs>): Prisma.PrismaPromise<GetExampleAggregateType<T>>

    /**
     * Group by Example.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExampleGroupByArgs['orderBy'] }
        : { orderBy?: ExampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Example.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExampleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Example base type for findUnique actions
   */
  export type ExampleFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Filter, which Example to fetch.
     */
    where: ExampleWhereUniqueInput
  }

  /**
   * Example findUnique
   */
  export interface ExampleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ExampleFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Example findUniqueOrThrow
   */
  export type ExampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Filter, which Example to fetch.
     */
    where: ExampleWhereUniqueInput
  }


  /**
   * Example base type for findFirst actions
   */
  export type ExampleFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Filter, which Example to fetch.
     */
    where?: ExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examples to fetch.
     */
    orderBy?: Enumerable<ExampleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Examples.
     */
    cursor?: ExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Examples.
     */
    distinct?: Enumerable<ExampleScalarFieldEnum>
  }

  /**
   * Example findFirst
   */
  export interface ExampleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ExampleFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Example findFirstOrThrow
   */
  export type ExampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Filter, which Example to fetch.
     */
    where?: ExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examples to fetch.
     */
    orderBy?: Enumerable<ExampleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Examples.
     */
    cursor?: ExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Examples.
     */
    distinct?: Enumerable<ExampleScalarFieldEnum>
  }


  /**
   * Example findMany
   */
  export type ExampleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Filter, which Examples to fetch.
     */
    where?: ExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examples to fetch.
     */
    orderBy?: Enumerable<ExampleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Examples.
     */
    cursor?: ExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examples.
     */
    skip?: number
    distinct?: Enumerable<ExampleScalarFieldEnum>
  }


  /**
   * Example create
   */
  export type ExampleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * The data needed to create a Example.
     */
    data: XOR<ExampleCreateInput, ExampleUncheckedCreateInput>
  }


  /**
   * Example createMany
   */
  export type ExampleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Examples.
     */
    data: Enumerable<ExampleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Example update
   */
  export type ExampleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * The data needed to update a Example.
     */
    data: XOR<ExampleUpdateInput, ExampleUncheckedUpdateInput>
    /**
     * Choose, which Example to update.
     */
    where: ExampleWhereUniqueInput
  }


  /**
   * Example updateMany
   */
  export type ExampleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Examples.
     */
    data: XOR<ExampleUpdateManyMutationInput, ExampleUncheckedUpdateManyInput>
    /**
     * Filter which Examples to update
     */
    where?: ExampleWhereInput
  }


  /**
   * Example upsert
   */
  export type ExampleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * The filter to search for the Example to update in case it exists.
     */
    where: ExampleWhereUniqueInput
    /**
     * In case the Example found by the `where` argument doesn't exist, create a new Example with this data.
     */
    create: XOR<ExampleCreateInput, ExampleUncheckedCreateInput>
    /**
     * In case the Example was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExampleUpdateInput, ExampleUncheckedUpdateInput>
  }


  /**
   * Example delete
   */
  export type ExampleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Filter which Example to delete.
     */
    where: ExampleWhereUniqueInput
  }


  /**
   * Example deleteMany
   */
  export type ExampleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Examples to delete
     */
    where?: ExampleWhereInput
  }


  /**
   * Example without action
   */
  export type ExampleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
  }



  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: AccountScalarFieldEnum[]
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountArgs> = $Types.GetResult<AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUnique
   */
  export interface AccountFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AccountFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account findFirst
   */
  export interface AccountFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AccountFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: SessionScalarFieldEnum[]
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type SessionGetPayload<S extends boolean | null | undefined | SessionArgs> = $Types.GetResult<SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? Prisma__SessionClient<$Types.GetResult<SessionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SessionClient<$Types.GetResult<SessionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Types.GetResult<SessionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? Prisma__SessionClient<$Types.GetResult<SessionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SessionClient<$Types.GetResult<SessionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Types.GetResult<SessionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SessionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Types.GetResult<SessionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<$Types.GetResult<SessionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Types.GetResult<SessionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<$Types.GetResult<SessionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Session base type for findUnique actions
   */
  export type SessionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUnique
   */
  export interface SessionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SessionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session base type for findFirst actions
   */
  export type SessionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: Enumerable<SessionScalarFieldEnum>
  }

  /**
   * Session findFirst
   */
  export interface SessionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SessionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
  }



  /**
   * Model Company
   */


  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    record_id: string | null
    name: string | null
    type: string | null
    tier: string | null
    access_to_marketplace: boolean | null
    created_at: Date | null
    company_manager_id: string | null
    macrovesta_manager_id: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    record_id: string | null
    name: string | null
    type: string | null
    tier: string | null
    access_to_marketplace: boolean | null
    created_at: Date | null
    company_manager_id: string | null
    macrovesta_manager_id: string | null
  }

  export type CompanyCountAggregateOutputType = {
    record_id: number
    name: number
    type: number
    tier: number
    access_to_marketplace: number
    created_at: number
    company_manager_id: number
    macrovesta_manager_id: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    record_id?: true
    name?: true
    type?: true
    tier?: true
    access_to_marketplace?: true
    created_at?: true
    company_manager_id?: true
    macrovesta_manager_id?: true
  }

  export type CompanyMaxAggregateInputType = {
    record_id?: true
    name?: true
    type?: true
    tier?: true
    access_to_marketplace?: true
    created_at?: true
    company_manager_id?: true
    macrovesta_manager_id?: true
  }

  export type CompanyCountAggregateInputType = {
    record_id?: true
    name?: true
    type?: true
    tier?: true
    access_to_marketplace?: true
    created_at?: true
    company_manager_id?: true
    macrovesta_manager_id?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: Enumerable<CompanyOrderByWithAggregationInput>
    by: CompanyScalarFieldEnum[]
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }


  export type CompanyGroupByOutputType = {
    record_id: string
    name: string
    type: string
    tier: string
    access_to_marketplace: boolean | null
    created_at: Date
    company_manager_id: string | null
    macrovesta_manager_id: string | null
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    name?: boolean
    type?: boolean
    tier?: boolean
    access_to_marketplace?: boolean
    created_at?: boolean
    company_manager_id?: boolean
    macrovesta_manager_id?: boolean
    company_manager?: boolean | UserArgs<ExtArgs>
    macrovesta_manager?: boolean | UserArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    selected_users?: boolean | Company$selected_usersArgs<ExtArgs>
    producer_production_estimates?: boolean | Company$producer_production_estimatesArgs<ExtArgs>
    producer_cost_estimates?: boolean | Company$producer_cost_estimatesArgs<ExtArgs>
    producer_commercialisation_estimates?: boolean | Company$producer_commercialisation_estimatesArgs<ExtArgs>
    strategy_log?: boolean | Company$strategy_logArgs<ExtArgs>
    fixed_cotton?: boolean | Company$fixed_cottonArgs<ExtArgs>
    unfixed_cotton?: boolean | Company$unfixed_cottonArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    record_id?: boolean
    name?: boolean
    type?: boolean
    tier?: boolean
    access_to_marketplace?: boolean
    created_at?: boolean
    company_manager_id?: boolean
    macrovesta_manager_id?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    company_manager?: boolean | UserArgs<ExtArgs>
    macrovesta_manager?: boolean | UserArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    selected_users?: boolean | Company$selected_usersArgs<ExtArgs>
    producer_production_estimates?: boolean | Company$producer_production_estimatesArgs<ExtArgs>
    producer_cost_estimates?: boolean | Company$producer_cost_estimatesArgs<ExtArgs>
    producer_commercialisation_estimates?: boolean | Company$producer_commercialisation_estimatesArgs<ExtArgs>
    strategy_log?: boolean | Company$strategy_logArgs<ExtArgs>
    fixed_cotton?: boolean | Company$fixed_cottonArgs<ExtArgs>
    unfixed_cotton?: boolean | Company$unfixed_cottonArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeArgs<ExtArgs>
  }


  type CompanyGetPayload<S extends boolean | null | undefined | CompanyArgs> = $Types.GetResult<CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Company'> extends True ? Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Company'> extends True ? Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const companyWithRecord_idOnly = await prisma.company.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends CompanyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends CompanyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Companies.
     *     @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const company = await prisma.company.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CompanyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends CompanyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    company_manager<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    macrovesta_manager<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    selected_users<T extends Company$selected_usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$selected_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    producer_production_estimates<T extends Company$producer_production_estimatesArgs<ExtArgs> = {}>(args?: Subset<T, Company$producer_production_estimatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    producer_cost_estimates<T extends Company$producer_cost_estimatesArgs<ExtArgs> = {}>(args?: Subset<T, Company$producer_cost_estimatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    producer_commercialisation_estimates<T extends Company$producer_commercialisation_estimatesArgs<ExtArgs> = {}>(args?: Subset<T, Company$producer_commercialisation_estimatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    strategy_log<T extends Company$strategy_logArgs<ExtArgs> = {}>(args?: Subset<T, Company$strategy_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'findMany', never>| Null>;

    fixed_cotton<T extends Company$fixed_cottonArgs<ExtArgs> = {}>(args?: Subset<T, Company$fixed_cottonArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'findMany', never>| Null>;

    unfixed_cotton<T extends Company$unfixed_cottonArgs<ExtArgs> = {}>(args?: Subset<T, Company$unfixed_cottonArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Company base type for findUnique actions
   */
  export type CompanyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUnique
   */
  export interface CompanyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CompanyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company base type for findFirst actions
   */
  export type CompanyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }

  /**
   * Company findFirst
   */
  export interface CompanyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CompanyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }


  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: Enumerable<CompanyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }


  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }


  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }


  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Company.selected_users
   */
  export type Company$selected_usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Company.producer_production_estimates
   */
  export type Company$producer_production_estimatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
    where?: producer_production_estimatesWhereInput
    orderBy?: Enumerable<producer_production_estimatesOrderByWithRelationInput>
    cursor?: producer_production_estimatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Producer_production_estimatesScalarFieldEnum>
  }


  /**
   * Company.producer_cost_estimates
   */
  export type Company$producer_cost_estimatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
    where?: producer_cost_estimatesWhereInput
    orderBy?: Enumerable<producer_cost_estimatesOrderByWithRelationInput>
    cursor?: producer_cost_estimatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Producer_cost_estimatesScalarFieldEnum>
  }


  /**
   * Company.producer_commercialisation_estimates
   */
  export type Company$producer_commercialisation_estimatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
    where?: producer_commercialisation_estimatesWhereInput
    orderBy?: Enumerable<producer_commercialisation_estimatesOrderByWithRelationInput>
    cursor?: producer_commercialisation_estimatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Producer_commercialisation_estimatesScalarFieldEnum>
  }


  /**
   * Company.strategy_log
   */
  export type Company$strategy_logArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
    where?: strategy_logWhereInput
    orderBy?: Enumerable<strategy_logOrderByWithRelationInput>
    cursor?: strategy_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Strategy_logScalarFieldEnum>
  }


  /**
   * Company.fixed_cotton
   */
  export type Company$fixed_cottonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
    where?: fixed_cottonWhereInput
    orderBy?: Enumerable<fixed_cottonOrderByWithRelationInput>
    cursor?: fixed_cottonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Fixed_cottonScalarFieldEnum>
  }


  /**
   * Company.unfixed_cotton
   */
  export type Company$unfixed_cottonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
    where?: unfixed_cottonWhereInput
    orderBy?: Enumerable<unfixed_cottonOrderByWithRelationInput>
    cursor?: unfixed_cottonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Unfixed_cottonScalarFieldEnum>
  }


  /**
   * Company without action
   */
  export type CompanyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
  }



  /**
   * Model VerificationToken
   */


  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: Enumerable<VerificationTokenOrderByWithAggregationInput>
    by: VerificationTokenScalarFieldEnum[]
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }


  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenArgs> = $Types.GetResult<VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationTokenFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VerificationToken'> extends True ? Prisma__VerificationTokenClient<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__VerificationTokenClient<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationTokenFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VerificationToken'> extends True ? Prisma__VerificationTokenClient<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__VerificationTokenClient<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
    **/
    findMany<T extends VerificationTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
    **/
    create<T extends VerificationTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     *     @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     *     @example
     *     // Create many VerificationTokens
     *     const verificationToken = await prisma.verificationToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
    **/
    delete<T extends VerificationTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Types.GetResult<VerificationTokenPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * VerificationToken base type for findUnique actions
   */
  export type VerificationTokenFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUnique
   */
  export interface VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends VerificationTokenFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken base type for findFirst actions
   */
  export type VerificationTokenFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }

  /**
   * VerificationToken findFirst
   */
  export interface VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends VerificationTokenFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }


  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: Enumerable<VerificationTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: Enumerable<VerificationTokenScalarFieldEnum>
  }


  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }


  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: Enumerable<VerificationTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }


  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken without action
   */
  export type VerificationTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    role: string | null
    company_id: string | null
    selected_company_id: string | null
    submittedSurvey: boolean | null
    image: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    role: string | null
    company_id: string | null
    selected_company_id: string | null
    submittedSurvey: boolean | null
    image: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    role: number
    company_id: number
    selected_company_id: number
    submittedSurvey: number
    image: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    role?: true
    company_id?: true
    selected_company_id?: true
    submittedSurvey?: true
    image?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    role?: true
    company_id?: true
    selected_company_id?: true
    submittedSurvey?: true
    image?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    role?: true
    company_id?: true
    selected_company_id?: true
    submittedSurvey?: true
    image?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    role: string | null
    company_id: string | null
    selected_company_id: string | null
    submittedSurvey: boolean | null
    image: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    role?: boolean
    company_id?: boolean
    selected_company_id?: boolean
    submittedSurvey?: boolean
    image?: boolean
    company?: boolean | CompanyArgs<ExtArgs>
    selected_company?: boolean | CompanyArgs<ExtArgs>
    company_managing?: boolean | CompanyArgs<ExtArgs>
    macrovesta_managing?: boolean | User$macrovesta_managingArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    agents?: boolean | User$agentsArgs<ExtArgs>
    buyers?: boolean | User$buyersArgs<ExtArgs>
    Marketplace?: boolean | User$MarketplaceArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    role?: boolean
    company_id?: boolean
    selected_company_id?: boolean
    submittedSurvey?: boolean
    image?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyArgs<ExtArgs>
    selected_company?: boolean | CompanyArgs<ExtArgs>
    company_managing?: boolean | CompanyArgs<ExtArgs>
    macrovesta_managing?: boolean | User$macrovesta_managingArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    agents?: boolean | User$agentsArgs<ExtArgs>
    buyers?: boolean | User$buyersArgs<ExtArgs>
    Marketplace?: boolean | User$MarketplaceArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    company<T extends CompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    selected_company<T extends CompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    company_managing<T extends CompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    macrovesta_managing<T extends User$macrovesta_managingArgs<ExtArgs> = {}>(args?: Subset<T, User$macrovesta_managingArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findMany', never>| Null>;

    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findMany', never>| Null>;

    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SessionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    agents<T extends User$agentsArgs<ExtArgs> = {}>(args?: Subset<T, User$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    buyers<T extends User$buyersArgs<ExtArgs> = {}>(args?: Subset<T, User$buyersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    Marketplace<T extends User$MarketplaceArgs<ExtArgs> = {}>(args?: Subset<T, User$MarketplaceArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'findMany', never>| Null>;

    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.macrovesta_managing
   */
  export type User$macrovesta_managingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * User.agents
   */
  export type User$agentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    where?: MarketplaceAgentWhereInput
    orderBy?: Enumerable<MarketplaceAgentOrderByWithRelationInput>
    cursor?: MarketplaceAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MarketplaceAgentScalarFieldEnum>
  }


  /**
   * User.buyers
   */
  export type User$buyersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    where?: MarketplaceBuyerWhereInput
    orderBy?: Enumerable<MarketplaceBuyerOrderByWithRelationInput>
    cursor?: MarketplaceBuyerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MarketplaceBuyerScalarFieldEnum>
  }


  /**
   * User.Marketplace
   */
  export type User$MarketplaceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
    where?: MarketplaceWhereInput
    orderBy?: Enumerable<MarketplaceOrderByWithRelationInput>
    cursor?: MarketplaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MarketplaceScalarFieldEnum>
  }


  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    record_id: string | null
    title: string | null
    description: string | null
    is_read: boolean | null
    user_id: string | null
    date_created: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    record_id: string | null
    title: string | null
    description: string | null
    is_read: boolean | null
    user_id: string | null
    date_created: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    record_id: number
    title: number
    description: number
    is_read: number
    user_id: number
    date_created: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    record_id?: true
    title?: true
    description?: true
    is_read?: true
    user_id?: true
    date_created?: true
  }

  export type NotificationMaxAggregateInputType = {
    record_id?: true
    title?: true
    description?: true
    is_read?: true
    user_id?: true
    date_created?: true
  }

  export type NotificationCountAggregateInputType = {
    record_id?: true
    title?: true
    description?: true
    is_read?: true
    user_id?: true
    date_created?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithAggregationInput>
    by: NotificationScalarFieldEnum[]
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    record_id: string
    title: string
    description: string
    is_read: boolean
    user_id: string
    date_created: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    title?: boolean
    description?: boolean
    is_read?: boolean
    user_id?: boolean
    date_created?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    record_id?: boolean
    title?: boolean
    description?: boolean
    is_read?: boolean
    user_id?: boolean
    date_created?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationArgs> = $Types.GetResult<NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const notificationWithRecord_idOnly = await prisma.notification.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notification base type for findUnique actions
   */
  export type NotificationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUnique
   */
  export interface NotificationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NotificationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification base type for findFirst actions
   */
  export type NotificationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }

  /**
   * Notification findFirst
   */
  export interface NotificationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NotificationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
  }



  /**
   * Model Marketplace
   */


  export type AggregateMarketplace = {
    _count: MarketplaceCountAggregateOutputType | null
    _avg: MarketplaceAvgAggregateOutputType | null
    _sum: MarketplaceSumAggregateOutputType | null
    _min: MarketplaceMinAggregateOutputType | null
    _max: MarketplaceMaxAggregateOutputType | null
  }

  export type MarketplaceAvgAggregateOutputType = {
    quantity: number | null
    price_usd: number | null
  }

  export type MarketplaceSumAggregateOutputType = {
    quantity: number | null
    price_usd: number | null
  }

  export type MarketplaceMinAggregateOutputType = {
    record_id: string | null
    product: string | null
    category: string | null
    quantity: number | null
    quality: string | null
    description: string | null
    image_url: string | null
    price_usd: number | null
    added_by: string | null
    hvi_file: string | null
    shipment: string | null
    payment_terms: string | null
    date_created: Date | null
    expiry_date: Date | null
    reserved_by: string | null
  }

  export type MarketplaceMaxAggregateOutputType = {
    record_id: string | null
    product: string | null
    category: string | null
    quantity: number | null
    quality: string | null
    description: string | null
    image_url: string | null
    price_usd: number | null
    added_by: string | null
    hvi_file: string | null
    shipment: string | null
    payment_terms: string | null
    date_created: Date | null
    expiry_date: Date | null
    reserved_by: string | null
  }

  export type MarketplaceCountAggregateOutputType = {
    record_id: number
    product: number
    category: number
    quantity: number
    quality: number
    description: number
    image_url: number
    price_usd: number
    added_by: number
    hvi_file: number
    shipment: number
    payment_terms: number
    date_created: number
    expiry_date: number
    reserved_by: number
    _all: number
  }


  export type MarketplaceAvgAggregateInputType = {
    quantity?: true
    price_usd?: true
  }

  export type MarketplaceSumAggregateInputType = {
    quantity?: true
    price_usd?: true
  }

  export type MarketplaceMinAggregateInputType = {
    record_id?: true
    product?: true
    category?: true
    quantity?: true
    quality?: true
    description?: true
    image_url?: true
    price_usd?: true
    added_by?: true
    hvi_file?: true
    shipment?: true
    payment_terms?: true
    date_created?: true
    expiry_date?: true
    reserved_by?: true
  }

  export type MarketplaceMaxAggregateInputType = {
    record_id?: true
    product?: true
    category?: true
    quantity?: true
    quality?: true
    description?: true
    image_url?: true
    price_usd?: true
    added_by?: true
    hvi_file?: true
    shipment?: true
    payment_terms?: true
    date_created?: true
    expiry_date?: true
    reserved_by?: true
  }

  export type MarketplaceCountAggregateInputType = {
    record_id?: true
    product?: true
    category?: true
    quantity?: true
    quality?: true
    description?: true
    image_url?: true
    price_usd?: true
    added_by?: true
    hvi_file?: true
    shipment?: true
    payment_terms?: true
    date_created?: true
    expiry_date?: true
    reserved_by?: true
    _all?: true
  }

  export type MarketplaceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Marketplace to aggregate.
     */
    where?: MarketplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marketplaces to fetch.
     */
    orderBy?: Enumerable<MarketplaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marketplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marketplaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Marketplaces
    **/
    _count?: true | MarketplaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketplaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketplaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceMaxAggregateInputType
  }

  export type GetMarketplaceAggregateType<T extends MarketplaceAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplace[P]>
      : GetScalarType<T[P], AggregateMarketplace[P]>
  }




  export type MarketplaceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MarketplaceWhereInput
    orderBy?: Enumerable<MarketplaceOrderByWithAggregationInput>
    by: MarketplaceScalarFieldEnum[]
    having?: MarketplaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceCountAggregateInputType | true
    _avg?: MarketplaceAvgAggregateInputType
    _sum?: MarketplaceSumAggregateInputType
    _min?: MarketplaceMinAggregateInputType
    _max?: MarketplaceMaxAggregateInputType
  }


  export type MarketplaceGroupByOutputType = {
    record_id: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created: Date
    expiry_date: Date
    reserved_by: string | null
    _count: MarketplaceCountAggregateOutputType | null
    _avg: MarketplaceAvgAggregateOutputType | null
    _sum: MarketplaceSumAggregateOutputType | null
    _min: MarketplaceMinAggregateOutputType | null
    _max: MarketplaceMaxAggregateOutputType | null
  }

  type GetMarketplaceGroupByPayload<T extends MarketplaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MarketplaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    product?: boolean
    category?: boolean
    quantity?: boolean
    quality?: boolean
    description?: boolean
    image_url?: boolean
    price_usd?: boolean
    added_by?: boolean
    hvi_file?: boolean
    shipment?: boolean
    payment_terms?: boolean
    date_created?: boolean
    expiry_date?: boolean
    reserved_by?: boolean
    reserved_by_user?: boolean | UserArgs<ExtArgs>
    agents?: boolean | Marketplace$agentsArgs<ExtArgs>
    buyers?: boolean | Marketplace$buyersArgs<ExtArgs>
    _count?: boolean | MarketplaceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["marketplace"]>

  export type MarketplaceSelectScalar = {
    record_id?: boolean
    product?: boolean
    category?: boolean
    quantity?: boolean
    quality?: boolean
    description?: boolean
    image_url?: boolean
    price_usd?: boolean
    added_by?: boolean
    hvi_file?: boolean
    shipment?: boolean
    payment_terms?: boolean
    date_created?: boolean
    expiry_date?: boolean
    reserved_by?: boolean
  }

  export type MarketplaceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    reserved_by_user?: boolean | UserArgs<ExtArgs>
    agents?: boolean | Marketplace$agentsArgs<ExtArgs>
    buyers?: boolean | Marketplace$buyersArgs<ExtArgs>
    _count?: boolean | MarketplaceCountOutputTypeArgs<ExtArgs>
  }


  type MarketplaceGetPayload<S extends boolean | null | undefined | MarketplaceArgs> = $Types.GetResult<MarketplacePayload, S>

  type MarketplaceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MarketplaceFindManyArgs, 'select' | 'include'> & {
      select?: MarketplaceCountAggregateInputType | true
    }

  export interface MarketplaceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Marketplace'], meta: { name: 'Marketplace' } }
    /**
     * Find zero or one Marketplace that matches the filter.
     * @param {MarketplaceFindUniqueArgs} args - Arguments to find a Marketplace
     * @example
     * // Get one Marketplace
     * const marketplace = await prisma.marketplace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarketplaceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarketplaceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Marketplace'> extends True ? Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Marketplace that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MarketplaceFindUniqueOrThrowArgs} args - Arguments to find a Marketplace
     * @example
     * // Get one Marketplace
     * const marketplace = await prisma.marketplace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MarketplaceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Marketplace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceFindFirstArgs} args - Arguments to find a Marketplace
     * @example
     * // Get one Marketplace
     * const marketplace = await prisma.marketplace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarketplaceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarketplaceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Marketplace'> extends True ? Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Marketplace that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceFindFirstOrThrowArgs} args - Arguments to find a Marketplace
     * @example
     * // Get one Marketplace
     * const marketplace = await prisma.marketplace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MarketplaceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Marketplaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marketplaces
     * const marketplaces = await prisma.marketplace.findMany()
     * 
     * // Get first 10 Marketplaces
     * const marketplaces = await prisma.marketplace.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const marketplaceWithRecord_idOnly = await prisma.marketplace.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends MarketplaceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Marketplace.
     * @param {MarketplaceCreateArgs} args - Arguments to create a Marketplace.
     * @example
     * // Create one Marketplace
     * const Marketplace = await prisma.marketplace.create({
     *   data: {
     *     // ... data to create a Marketplace
     *   }
     * })
     * 
    **/
    create<T extends MarketplaceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceCreateArgs<ExtArgs>>
    ): Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Marketplaces.
     *     @param {MarketplaceCreateManyArgs} args - Arguments to create many Marketplaces.
     *     @example
     *     // Create many Marketplaces
     *     const marketplace = await prisma.marketplace.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarketplaceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Marketplace.
     * @param {MarketplaceDeleteArgs} args - Arguments to delete one Marketplace.
     * @example
     * // Delete one Marketplace
     * const Marketplace = await prisma.marketplace.delete({
     *   where: {
     *     // ... filter to delete one Marketplace
     *   }
     * })
     * 
    **/
    delete<T extends MarketplaceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceDeleteArgs<ExtArgs>>
    ): Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Marketplace.
     * @param {MarketplaceUpdateArgs} args - Arguments to update one Marketplace.
     * @example
     * // Update one Marketplace
     * const marketplace = await prisma.marketplace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarketplaceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceUpdateArgs<ExtArgs>>
    ): Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Marketplaces.
     * @param {MarketplaceDeleteManyArgs} args - Arguments to filter Marketplaces to delete.
     * @example
     * // Delete a few Marketplaces
     * const { count } = await prisma.marketplace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarketplaceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marketplaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marketplaces
     * const marketplace = await prisma.marketplace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarketplaceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Marketplace.
     * @param {MarketplaceUpsertArgs} args - Arguments to update or create a Marketplace.
     * @example
     * // Update or create a Marketplace
     * const marketplace = await prisma.marketplace.upsert({
     *   create: {
     *     // ... data to create a Marketplace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marketplace we want to update
     *   }
     * })
    **/
    upsert<T extends MarketplaceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceUpsertArgs<ExtArgs>>
    ): Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Marketplaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceCountArgs} args - Arguments to filter Marketplaces to count.
     * @example
     * // Count the number of Marketplaces
     * const count = await prisma.marketplace.count({
     *   where: {
     *     // ... the filter for the Marketplaces we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceCountArgs>(
      args?: Subset<T, MarketplaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marketplace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceAggregateArgs>(args: Subset<T, MarketplaceAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceAggregateType<T>>

    /**
     * Group by Marketplace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Marketplace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarketplaceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reserved_by_user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    agents<T extends Marketplace$agentsArgs<ExtArgs> = {}>(args?: Subset<T, Marketplace$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    buyers<T extends Marketplace$buyersArgs<ExtArgs> = {}>(args?: Subset<T, Marketplace$buyersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Marketplace base type for findUnique actions
   */
  export type MarketplaceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
    /**
     * Filter, which Marketplace to fetch.
     */
    where: MarketplaceWhereUniqueInput
  }

  /**
   * Marketplace findUnique
   */
  export interface MarketplaceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MarketplaceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Marketplace findUniqueOrThrow
   */
  export type MarketplaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
    /**
     * Filter, which Marketplace to fetch.
     */
    where: MarketplaceWhereUniqueInput
  }


  /**
   * Marketplace base type for findFirst actions
   */
  export type MarketplaceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
    /**
     * Filter, which Marketplace to fetch.
     */
    where?: MarketplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marketplaces to fetch.
     */
    orderBy?: Enumerable<MarketplaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marketplaces.
     */
    cursor?: MarketplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marketplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marketplaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marketplaces.
     */
    distinct?: Enumerable<MarketplaceScalarFieldEnum>
  }

  /**
   * Marketplace findFirst
   */
  export interface MarketplaceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MarketplaceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Marketplace findFirstOrThrow
   */
  export type MarketplaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
    /**
     * Filter, which Marketplace to fetch.
     */
    where?: MarketplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marketplaces to fetch.
     */
    orderBy?: Enumerable<MarketplaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marketplaces.
     */
    cursor?: MarketplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marketplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marketplaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marketplaces.
     */
    distinct?: Enumerable<MarketplaceScalarFieldEnum>
  }


  /**
   * Marketplace findMany
   */
  export type MarketplaceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
    /**
     * Filter, which Marketplaces to fetch.
     */
    where?: MarketplaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marketplaces to fetch.
     */
    orderBy?: Enumerable<MarketplaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Marketplaces.
     */
    cursor?: MarketplaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marketplaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marketplaces.
     */
    skip?: number
    distinct?: Enumerable<MarketplaceScalarFieldEnum>
  }


  /**
   * Marketplace create
   */
  export type MarketplaceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Marketplace.
     */
    data: XOR<MarketplaceCreateInput, MarketplaceUncheckedCreateInput>
  }


  /**
   * Marketplace createMany
   */
  export type MarketplaceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Marketplaces.
     */
    data: Enumerable<MarketplaceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Marketplace update
   */
  export type MarketplaceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Marketplace.
     */
    data: XOR<MarketplaceUpdateInput, MarketplaceUncheckedUpdateInput>
    /**
     * Choose, which Marketplace to update.
     */
    where: MarketplaceWhereUniqueInput
  }


  /**
   * Marketplace updateMany
   */
  export type MarketplaceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Marketplaces.
     */
    data: XOR<MarketplaceUpdateManyMutationInput, MarketplaceUncheckedUpdateManyInput>
    /**
     * Filter which Marketplaces to update
     */
    where?: MarketplaceWhereInput
  }


  /**
   * Marketplace upsert
   */
  export type MarketplaceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Marketplace to update in case it exists.
     */
    where: MarketplaceWhereUniqueInput
    /**
     * In case the Marketplace found by the `where` argument doesn't exist, create a new Marketplace with this data.
     */
    create: XOR<MarketplaceCreateInput, MarketplaceUncheckedCreateInput>
    /**
     * In case the Marketplace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceUpdateInput, MarketplaceUncheckedUpdateInput>
  }


  /**
   * Marketplace delete
   */
  export type MarketplaceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
    /**
     * Filter which Marketplace to delete.
     */
    where: MarketplaceWhereUniqueInput
  }


  /**
   * Marketplace deleteMany
   */
  export type MarketplaceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Marketplaces to delete
     */
    where?: MarketplaceWhereInput
  }


  /**
   * Marketplace.agents
   */
  export type Marketplace$agentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    where?: MarketplaceAgentWhereInput
    orderBy?: Enumerable<MarketplaceAgentOrderByWithRelationInput>
    cursor?: MarketplaceAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MarketplaceAgentScalarFieldEnum>
  }


  /**
   * Marketplace.buyers
   */
  export type Marketplace$buyersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    where?: MarketplaceBuyerWhereInput
    orderBy?: Enumerable<MarketplaceBuyerOrderByWithRelationInput>
    cursor?: MarketplaceBuyerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MarketplaceBuyerScalarFieldEnum>
  }


  /**
   * Marketplace without action
   */
  export type MarketplaceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace
     */
    select?: MarketplaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceInclude<ExtArgs> | null
  }



  /**
   * Model MarketplaceAgent
   */


  export type AggregateMarketplaceAgent = {
    _count: MarketplaceAgentCountAggregateOutputType | null
    _min: MarketplaceAgentMinAggregateOutputType | null
    _max: MarketplaceAgentMaxAggregateOutputType | null
  }

  export type MarketplaceAgentMinAggregateOutputType = {
    record_id: string | null
    marketplace_id: string | null
    agent_id: string | null
    date_created: Date | null
  }

  export type MarketplaceAgentMaxAggregateOutputType = {
    record_id: string | null
    marketplace_id: string | null
    agent_id: string | null
    date_created: Date | null
  }

  export type MarketplaceAgentCountAggregateOutputType = {
    record_id: number
    marketplace_id: number
    agent_id: number
    date_created: number
    _all: number
  }


  export type MarketplaceAgentMinAggregateInputType = {
    record_id?: true
    marketplace_id?: true
    agent_id?: true
    date_created?: true
  }

  export type MarketplaceAgentMaxAggregateInputType = {
    record_id?: true
    marketplace_id?: true
    agent_id?: true
    date_created?: true
  }

  export type MarketplaceAgentCountAggregateInputType = {
    record_id?: true
    marketplace_id?: true
    agent_id?: true
    date_created?: true
    _all?: true
  }

  export type MarketplaceAgentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceAgent to aggregate.
     */
    where?: MarketplaceAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceAgents to fetch.
     */
    orderBy?: Enumerable<MarketplaceAgentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceAgents
    **/
    _count?: true | MarketplaceAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceAgentMaxAggregateInputType
  }

  export type GetMarketplaceAgentAggregateType<T extends MarketplaceAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceAgent[P]>
      : GetScalarType<T[P], AggregateMarketplaceAgent[P]>
  }




  export type MarketplaceAgentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MarketplaceAgentWhereInput
    orderBy?: Enumerable<MarketplaceAgentOrderByWithAggregationInput>
    by: MarketplaceAgentScalarFieldEnum[]
    having?: MarketplaceAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceAgentCountAggregateInputType | true
    _min?: MarketplaceAgentMinAggregateInputType
    _max?: MarketplaceAgentMaxAggregateInputType
  }


  export type MarketplaceAgentGroupByOutputType = {
    record_id: string
    marketplace_id: string
    agent_id: string
    date_created: Date
    _count: MarketplaceAgentCountAggregateOutputType | null
    _min: MarketplaceAgentMinAggregateOutputType | null
    _max: MarketplaceAgentMaxAggregateOutputType | null
  }

  type GetMarketplaceAgentGroupByPayload<T extends MarketplaceAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MarketplaceAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceAgentGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceAgentGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceAgentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    marketplace_id?: boolean
    agent_id?: boolean
    date_created?: boolean
    marketplace?: boolean | MarketplaceArgs<ExtArgs>
    agent?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceAgent"]>

  export type MarketplaceAgentSelectScalar = {
    record_id?: boolean
    marketplace_id?: boolean
    agent_id?: boolean
    date_created?: boolean
  }

  export type MarketplaceAgentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    marketplace?: boolean | MarketplaceArgs<ExtArgs>
    agent?: boolean | UserArgs<ExtArgs>
  }


  type MarketplaceAgentGetPayload<S extends boolean | null | undefined | MarketplaceAgentArgs> = $Types.GetResult<MarketplaceAgentPayload, S>

  type MarketplaceAgentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MarketplaceAgentFindManyArgs, 'select' | 'include'> & {
      select?: MarketplaceAgentCountAggregateInputType | true
    }

  export interface MarketplaceAgentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceAgent'], meta: { name: 'MarketplaceAgent' } }
    /**
     * Find zero or one MarketplaceAgent that matches the filter.
     * @param {MarketplaceAgentFindUniqueArgs} args - Arguments to find a MarketplaceAgent
     * @example
     * // Get one MarketplaceAgent
     * const marketplaceAgent = await prisma.marketplaceAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarketplaceAgentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarketplaceAgentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MarketplaceAgent'> extends True ? Prisma__MarketplaceAgentClient<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__MarketplaceAgentClient<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one MarketplaceAgent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MarketplaceAgentFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceAgent
     * @example
     * // Get one MarketplaceAgent
     * const marketplaceAgent = await prisma.marketplaceAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MarketplaceAgentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceAgentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MarketplaceAgentClient<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first MarketplaceAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceAgentFindFirstArgs} args - Arguments to find a MarketplaceAgent
     * @example
     * // Get one MarketplaceAgent
     * const marketplaceAgent = await prisma.marketplaceAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarketplaceAgentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarketplaceAgentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MarketplaceAgent'> extends True ? Prisma__MarketplaceAgentClient<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__MarketplaceAgentClient<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first MarketplaceAgent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceAgentFindFirstOrThrowArgs} args - Arguments to find a MarketplaceAgent
     * @example
     * // Get one MarketplaceAgent
     * const marketplaceAgent = await prisma.marketplaceAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MarketplaceAgentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceAgentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MarketplaceAgentClient<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more MarketplaceAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceAgentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceAgents
     * const marketplaceAgents = await prisma.marketplaceAgent.findMany()
     * 
     * // Get first 10 MarketplaceAgents
     * const marketplaceAgents = await prisma.marketplaceAgent.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const marketplaceAgentWithRecord_idOnly = await prisma.marketplaceAgent.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends MarketplaceAgentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceAgentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a MarketplaceAgent.
     * @param {MarketplaceAgentCreateArgs} args - Arguments to create a MarketplaceAgent.
     * @example
     * // Create one MarketplaceAgent
     * const MarketplaceAgent = await prisma.marketplaceAgent.create({
     *   data: {
     *     // ... data to create a MarketplaceAgent
     *   }
     * })
     * 
    **/
    create<T extends MarketplaceAgentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceAgentCreateArgs<ExtArgs>>
    ): Prisma__MarketplaceAgentClient<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many MarketplaceAgents.
     *     @param {MarketplaceAgentCreateManyArgs} args - Arguments to create many MarketplaceAgents.
     *     @example
     *     // Create many MarketplaceAgents
     *     const marketplaceAgent = await prisma.marketplaceAgent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarketplaceAgentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceAgentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MarketplaceAgent.
     * @param {MarketplaceAgentDeleteArgs} args - Arguments to delete one MarketplaceAgent.
     * @example
     * // Delete one MarketplaceAgent
     * const MarketplaceAgent = await prisma.marketplaceAgent.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceAgent
     *   }
     * })
     * 
    **/
    delete<T extends MarketplaceAgentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceAgentDeleteArgs<ExtArgs>>
    ): Prisma__MarketplaceAgentClient<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one MarketplaceAgent.
     * @param {MarketplaceAgentUpdateArgs} args - Arguments to update one MarketplaceAgent.
     * @example
     * // Update one MarketplaceAgent
     * const marketplaceAgent = await prisma.marketplaceAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarketplaceAgentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceAgentUpdateArgs<ExtArgs>>
    ): Prisma__MarketplaceAgentClient<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more MarketplaceAgents.
     * @param {MarketplaceAgentDeleteManyArgs} args - Arguments to filter MarketplaceAgents to delete.
     * @example
     * // Delete a few MarketplaceAgents
     * const { count } = await prisma.marketplaceAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarketplaceAgentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceAgentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceAgents
     * const marketplaceAgent = await prisma.marketplaceAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarketplaceAgentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceAgentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketplaceAgent.
     * @param {MarketplaceAgentUpsertArgs} args - Arguments to update or create a MarketplaceAgent.
     * @example
     * // Update or create a MarketplaceAgent
     * const marketplaceAgent = await prisma.marketplaceAgent.upsert({
     *   create: {
     *     // ... data to create a MarketplaceAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceAgent we want to update
     *   }
     * })
    **/
    upsert<T extends MarketplaceAgentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceAgentUpsertArgs<ExtArgs>>
    ): Prisma__MarketplaceAgentClient<$Types.GetResult<MarketplaceAgentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of MarketplaceAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceAgentCountArgs} args - Arguments to filter MarketplaceAgents to count.
     * @example
     * // Count the number of MarketplaceAgents
     * const count = await prisma.marketplaceAgent.count({
     *   where: {
     *     // ... the filter for the MarketplaceAgents we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceAgentCountArgs>(
      args?: Subset<T, MarketplaceAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceAgentAggregateArgs>(args: Subset<T, MarketplaceAgentAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceAgentAggregateType<T>>

    /**
     * Group by MarketplaceAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceAgentGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarketplaceAgentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    marketplace<T extends MarketplaceArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceArgs<ExtArgs>>): Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    agent<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MarketplaceAgent base type for findUnique actions
   */
  export type MarketplaceAgentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceAgent to fetch.
     */
    where: MarketplaceAgentWhereUniqueInput
  }

  /**
   * MarketplaceAgent findUnique
   */
  export interface MarketplaceAgentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MarketplaceAgentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketplaceAgent findUniqueOrThrow
   */
  export type MarketplaceAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceAgent to fetch.
     */
    where: MarketplaceAgentWhereUniqueInput
  }


  /**
   * MarketplaceAgent base type for findFirst actions
   */
  export type MarketplaceAgentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceAgent to fetch.
     */
    where?: MarketplaceAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceAgents to fetch.
     */
    orderBy?: Enumerable<MarketplaceAgentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceAgents.
     */
    cursor?: MarketplaceAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceAgents.
     */
    distinct?: Enumerable<MarketplaceAgentScalarFieldEnum>
  }

  /**
   * MarketplaceAgent findFirst
   */
  export interface MarketplaceAgentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MarketplaceAgentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketplaceAgent findFirstOrThrow
   */
  export type MarketplaceAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceAgent to fetch.
     */
    where?: MarketplaceAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceAgents to fetch.
     */
    orderBy?: Enumerable<MarketplaceAgentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceAgents.
     */
    cursor?: MarketplaceAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceAgents.
     */
    distinct?: Enumerable<MarketplaceAgentScalarFieldEnum>
  }


  /**
   * MarketplaceAgent findMany
   */
  export type MarketplaceAgentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceAgents to fetch.
     */
    where?: MarketplaceAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceAgents to fetch.
     */
    orderBy?: Enumerable<MarketplaceAgentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceAgents.
     */
    cursor?: MarketplaceAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceAgents.
     */
    skip?: number
    distinct?: Enumerable<MarketplaceAgentScalarFieldEnum>
  }


  /**
   * MarketplaceAgent create
   */
  export type MarketplaceAgentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceAgent.
     */
    data: XOR<MarketplaceAgentCreateInput, MarketplaceAgentUncheckedCreateInput>
  }


  /**
   * MarketplaceAgent createMany
   */
  export type MarketplaceAgentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceAgents.
     */
    data: Enumerable<MarketplaceAgentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MarketplaceAgent update
   */
  export type MarketplaceAgentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceAgent.
     */
    data: XOR<MarketplaceAgentUpdateInput, MarketplaceAgentUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceAgent to update.
     */
    where: MarketplaceAgentWhereUniqueInput
  }


  /**
   * MarketplaceAgent updateMany
   */
  export type MarketplaceAgentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceAgents.
     */
    data: XOR<MarketplaceAgentUpdateManyMutationInput, MarketplaceAgentUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceAgents to update
     */
    where?: MarketplaceAgentWhereInput
  }


  /**
   * MarketplaceAgent upsert
   */
  export type MarketplaceAgentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceAgent to update in case it exists.
     */
    where: MarketplaceAgentWhereUniqueInput
    /**
     * In case the MarketplaceAgent found by the `where` argument doesn't exist, create a new MarketplaceAgent with this data.
     */
    create: XOR<MarketplaceAgentCreateInput, MarketplaceAgentUncheckedCreateInput>
    /**
     * In case the MarketplaceAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceAgentUpdateInput, MarketplaceAgentUncheckedUpdateInput>
  }


  /**
   * MarketplaceAgent delete
   */
  export type MarketplaceAgentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceAgent to delete.
     */
    where: MarketplaceAgentWhereUniqueInput
  }


  /**
   * MarketplaceAgent deleteMany
   */
  export type MarketplaceAgentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceAgents to delete
     */
    where?: MarketplaceAgentWhereInput
  }


  /**
   * MarketplaceAgent without action
   */
  export type MarketplaceAgentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceAgent
     */
    select?: MarketplaceAgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceAgentInclude<ExtArgs> | null
  }



  /**
   * Model MarketplaceBuyer
   */


  export type AggregateMarketplaceBuyer = {
    _count: MarketplaceBuyerCountAggregateOutputType | null
    _min: MarketplaceBuyerMinAggregateOutputType | null
    _max: MarketplaceBuyerMaxAggregateOutputType | null
  }

  export type MarketplaceBuyerMinAggregateOutputType = {
    record_id: string | null
    marketplace_id: string | null
    buyer_id: string | null
    date_created: Date | null
  }

  export type MarketplaceBuyerMaxAggregateOutputType = {
    record_id: string | null
    marketplace_id: string | null
    buyer_id: string | null
    date_created: Date | null
  }

  export type MarketplaceBuyerCountAggregateOutputType = {
    record_id: number
    marketplace_id: number
    buyer_id: number
    date_created: number
    _all: number
  }


  export type MarketplaceBuyerMinAggregateInputType = {
    record_id?: true
    marketplace_id?: true
    buyer_id?: true
    date_created?: true
  }

  export type MarketplaceBuyerMaxAggregateInputType = {
    record_id?: true
    marketplace_id?: true
    buyer_id?: true
    date_created?: true
  }

  export type MarketplaceBuyerCountAggregateInputType = {
    record_id?: true
    marketplace_id?: true
    buyer_id?: true
    date_created?: true
    _all?: true
  }

  export type MarketplaceBuyerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceBuyer to aggregate.
     */
    where?: MarketplaceBuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceBuyers to fetch.
     */
    orderBy?: Enumerable<MarketplaceBuyerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceBuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceBuyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceBuyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceBuyers
    **/
    _count?: true | MarketplaceBuyerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceBuyerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceBuyerMaxAggregateInputType
  }

  export type GetMarketplaceBuyerAggregateType<T extends MarketplaceBuyerAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceBuyer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceBuyer[P]>
      : GetScalarType<T[P], AggregateMarketplaceBuyer[P]>
  }




  export type MarketplaceBuyerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MarketplaceBuyerWhereInput
    orderBy?: Enumerable<MarketplaceBuyerOrderByWithAggregationInput>
    by: MarketplaceBuyerScalarFieldEnum[]
    having?: MarketplaceBuyerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceBuyerCountAggregateInputType | true
    _min?: MarketplaceBuyerMinAggregateInputType
    _max?: MarketplaceBuyerMaxAggregateInputType
  }


  export type MarketplaceBuyerGroupByOutputType = {
    record_id: string
    marketplace_id: string
    buyer_id: string
    date_created: Date
    _count: MarketplaceBuyerCountAggregateOutputType | null
    _min: MarketplaceBuyerMinAggregateOutputType | null
    _max: MarketplaceBuyerMaxAggregateOutputType | null
  }

  type GetMarketplaceBuyerGroupByPayload<T extends MarketplaceBuyerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MarketplaceBuyerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceBuyerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceBuyerGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceBuyerGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceBuyerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    marketplace_id?: boolean
    buyer_id?: boolean
    date_created?: boolean
    buyer?: boolean | UserArgs<ExtArgs>
    marketplace?: boolean | MarketplaceArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceBuyer"]>

  export type MarketplaceBuyerSelectScalar = {
    record_id?: boolean
    marketplace_id?: boolean
    buyer_id?: boolean
    date_created?: boolean
  }

  export type MarketplaceBuyerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    buyer?: boolean | UserArgs<ExtArgs>
    marketplace?: boolean | MarketplaceArgs<ExtArgs>
  }


  type MarketplaceBuyerGetPayload<S extends boolean | null | undefined | MarketplaceBuyerArgs> = $Types.GetResult<MarketplaceBuyerPayload, S>

  type MarketplaceBuyerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MarketplaceBuyerFindManyArgs, 'select' | 'include'> & {
      select?: MarketplaceBuyerCountAggregateInputType | true
    }

  export interface MarketplaceBuyerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceBuyer'], meta: { name: 'MarketplaceBuyer' } }
    /**
     * Find zero or one MarketplaceBuyer that matches the filter.
     * @param {MarketplaceBuyerFindUniqueArgs} args - Arguments to find a MarketplaceBuyer
     * @example
     * // Get one MarketplaceBuyer
     * const marketplaceBuyer = await prisma.marketplaceBuyer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarketplaceBuyerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarketplaceBuyerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MarketplaceBuyer'> extends True ? Prisma__MarketplaceBuyerClient<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__MarketplaceBuyerClient<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one MarketplaceBuyer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MarketplaceBuyerFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceBuyer
     * @example
     * // Get one MarketplaceBuyer
     * const marketplaceBuyer = await prisma.marketplaceBuyer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MarketplaceBuyerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceBuyerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MarketplaceBuyerClient<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first MarketplaceBuyer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceBuyerFindFirstArgs} args - Arguments to find a MarketplaceBuyer
     * @example
     * // Get one MarketplaceBuyer
     * const marketplaceBuyer = await prisma.marketplaceBuyer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarketplaceBuyerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarketplaceBuyerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MarketplaceBuyer'> extends True ? Prisma__MarketplaceBuyerClient<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__MarketplaceBuyerClient<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first MarketplaceBuyer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceBuyerFindFirstOrThrowArgs} args - Arguments to find a MarketplaceBuyer
     * @example
     * // Get one MarketplaceBuyer
     * const marketplaceBuyer = await prisma.marketplaceBuyer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MarketplaceBuyerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceBuyerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MarketplaceBuyerClient<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more MarketplaceBuyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceBuyerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceBuyers
     * const marketplaceBuyers = await prisma.marketplaceBuyer.findMany()
     * 
     * // Get first 10 MarketplaceBuyers
     * const marketplaceBuyers = await prisma.marketplaceBuyer.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const marketplaceBuyerWithRecord_idOnly = await prisma.marketplaceBuyer.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends MarketplaceBuyerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceBuyerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a MarketplaceBuyer.
     * @param {MarketplaceBuyerCreateArgs} args - Arguments to create a MarketplaceBuyer.
     * @example
     * // Create one MarketplaceBuyer
     * const MarketplaceBuyer = await prisma.marketplaceBuyer.create({
     *   data: {
     *     // ... data to create a MarketplaceBuyer
     *   }
     * })
     * 
    **/
    create<T extends MarketplaceBuyerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceBuyerCreateArgs<ExtArgs>>
    ): Prisma__MarketplaceBuyerClient<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many MarketplaceBuyers.
     *     @param {MarketplaceBuyerCreateManyArgs} args - Arguments to create many MarketplaceBuyers.
     *     @example
     *     // Create many MarketplaceBuyers
     *     const marketplaceBuyer = await prisma.marketplaceBuyer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarketplaceBuyerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceBuyerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MarketplaceBuyer.
     * @param {MarketplaceBuyerDeleteArgs} args - Arguments to delete one MarketplaceBuyer.
     * @example
     * // Delete one MarketplaceBuyer
     * const MarketplaceBuyer = await prisma.marketplaceBuyer.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceBuyer
     *   }
     * })
     * 
    **/
    delete<T extends MarketplaceBuyerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceBuyerDeleteArgs<ExtArgs>>
    ): Prisma__MarketplaceBuyerClient<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one MarketplaceBuyer.
     * @param {MarketplaceBuyerUpdateArgs} args - Arguments to update one MarketplaceBuyer.
     * @example
     * // Update one MarketplaceBuyer
     * const marketplaceBuyer = await prisma.marketplaceBuyer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarketplaceBuyerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceBuyerUpdateArgs<ExtArgs>>
    ): Prisma__MarketplaceBuyerClient<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more MarketplaceBuyers.
     * @param {MarketplaceBuyerDeleteManyArgs} args - Arguments to filter MarketplaceBuyers to delete.
     * @example
     * // Delete a few MarketplaceBuyers
     * const { count } = await prisma.marketplaceBuyer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarketplaceBuyerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MarketplaceBuyerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceBuyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceBuyerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceBuyers
     * const marketplaceBuyer = await prisma.marketplaceBuyer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarketplaceBuyerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceBuyerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketplaceBuyer.
     * @param {MarketplaceBuyerUpsertArgs} args - Arguments to update or create a MarketplaceBuyer.
     * @example
     * // Update or create a MarketplaceBuyer
     * const marketplaceBuyer = await prisma.marketplaceBuyer.upsert({
     *   create: {
     *     // ... data to create a MarketplaceBuyer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceBuyer we want to update
     *   }
     * })
    **/
    upsert<T extends MarketplaceBuyerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MarketplaceBuyerUpsertArgs<ExtArgs>>
    ): Prisma__MarketplaceBuyerClient<$Types.GetResult<MarketplaceBuyerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of MarketplaceBuyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceBuyerCountArgs} args - Arguments to filter MarketplaceBuyers to count.
     * @example
     * // Count the number of MarketplaceBuyers
     * const count = await prisma.marketplaceBuyer.count({
     *   where: {
     *     // ... the filter for the MarketplaceBuyers we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceBuyerCountArgs>(
      args?: Subset<T, MarketplaceBuyerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceBuyerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceBuyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceBuyerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceBuyerAggregateArgs>(args: Subset<T, MarketplaceBuyerAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceBuyerAggregateType<T>>

    /**
     * Group by MarketplaceBuyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceBuyerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceBuyerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceBuyerGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceBuyerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceBuyerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceBuyerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceBuyer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarketplaceBuyerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    buyer<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    marketplace<T extends MarketplaceArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceArgs<ExtArgs>>): Prisma__MarketplaceClient<$Types.GetResult<MarketplacePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MarketplaceBuyer base type for findUnique actions
   */
  export type MarketplaceBuyerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceBuyer to fetch.
     */
    where: MarketplaceBuyerWhereUniqueInput
  }

  /**
   * MarketplaceBuyer findUnique
   */
  export interface MarketplaceBuyerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MarketplaceBuyerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketplaceBuyer findUniqueOrThrow
   */
  export type MarketplaceBuyerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceBuyer to fetch.
     */
    where: MarketplaceBuyerWhereUniqueInput
  }


  /**
   * MarketplaceBuyer base type for findFirst actions
   */
  export type MarketplaceBuyerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceBuyer to fetch.
     */
    where?: MarketplaceBuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceBuyers to fetch.
     */
    orderBy?: Enumerable<MarketplaceBuyerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceBuyers.
     */
    cursor?: MarketplaceBuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceBuyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceBuyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceBuyers.
     */
    distinct?: Enumerable<MarketplaceBuyerScalarFieldEnum>
  }

  /**
   * MarketplaceBuyer findFirst
   */
  export interface MarketplaceBuyerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MarketplaceBuyerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarketplaceBuyer findFirstOrThrow
   */
  export type MarketplaceBuyerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceBuyer to fetch.
     */
    where?: MarketplaceBuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceBuyers to fetch.
     */
    orderBy?: Enumerable<MarketplaceBuyerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceBuyers.
     */
    cursor?: MarketplaceBuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceBuyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceBuyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceBuyers.
     */
    distinct?: Enumerable<MarketplaceBuyerScalarFieldEnum>
  }


  /**
   * MarketplaceBuyer findMany
   */
  export type MarketplaceBuyerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceBuyers to fetch.
     */
    where?: MarketplaceBuyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceBuyers to fetch.
     */
    orderBy?: Enumerable<MarketplaceBuyerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceBuyers.
     */
    cursor?: MarketplaceBuyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceBuyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceBuyers.
     */
    skip?: number
    distinct?: Enumerable<MarketplaceBuyerScalarFieldEnum>
  }


  /**
   * MarketplaceBuyer create
   */
  export type MarketplaceBuyerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceBuyer.
     */
    data: XOR<MarketplaceBuyerCreateInput, MarketplaceBuyerUncheckedCreateInput>
  }


  /**
   * MarketplaceBuyer createMany
   */
  export type MarketplaceBuyerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceBuyers.
     */
    data: Enumerable<MarketplaceBuyerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MarketplaceBuyer update
   */
  export type MarketplaceBuyerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceBuyer.
     */
    data: XOR<MarketplaceBuyerUpdateInput, MarketplaceBuyerUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceBuyer to update.
     */
    where: MarketplaceBuyerWhereUniqueInput
  }


  /**
   * MarketplaceBuyer updateMany
   */
  export type MarketplaceBuyerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceBuyers.
     */
    data: XOR<MarketplaceBuyerUpdateManyMutationInput, MarketplaceBuyerUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceBuyers to update
     */
    where?: MarketplaceBuyerWhereInput
  }


  /**
   * MarketplaceBuyer upsert
   */
  export type MarketplaceBuyerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceBuyer to update in case it exists.
     */
    where: MarketplaceBuyerWhereUniqueInput
    /**
     * In case the MarketplaceBuyer found by the `where` argument doesn't exist, create a new MarketplaceBuyer with this data.
     */
    create: XOR<MarketplaceBuyerCreateInput, MarketplaceBuyerUncheckedCreateInput>
    /**
     * In case the MarketplaceBuyer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceBuyerUpdateInput, MarketplaceBuyerUncheckedUpdateInput>
  }


  /**
   * MarketplaceBuyer delete
   */
  export type MarketplaceBuyerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceBuyer to delete.
     */
    where: MarketplaceBuyerWhereUniqueInput
  }


  /**
   * MarketplaceBuyer deleteMany
   */
  export type MarketplaceBuyerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceBuyers to delete
     */
    where?: MarketplaceBuyerWhereInput
  }


  /**
   * MarketplaceBuyer without action
   */
  export type MarketplaceBuyerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceBuyer
     */
    select?: MarketplaceBuyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MarketplaceBuyerInclude<ExtArgs> | null
  }



  /**
   * Model a_index
   */


  export type AggregateA_index = {
    _count: A_indexCountAggregateOutputType | null
    _avg: A_indexAvgAggregateOutputType | null
    _sum: A_indexSumAggregateOutputType | null
    _min: A_indexMinAggregateOutputType | null
    _max: A_indexMaxAggregateOutputType | null
  }

  export type A_indexAvgAggregateOutputType = {
    a_index: Decimal | null
    ice_highest_open_interest_17_months: Decimal | null
    cc_index: Decimal | null
    mcx: Decimal | null
    cepea: Decimal | null
  }

  export type A_indexSumAggregateOutputType = {
    a_index: Decimal | null
    ice_highest_open_interest_17_months: Decimal | null
    cc_index: Decimal | null
    mcx: Decimal | null
    cepea: Decimal | null
  }

  export type A_indexMinAggregateOutputType = {
    record_id: string | null
    date: Date | null
    a_index: Decimal | null
    ice_highest_open_interest_17_months: Decimal | null
    cc_index: Decimal | null
    mcx: Decimal | null
    cepea: Decimal | null
  }

  export type A_indexMaxAggregateOutputType = {
    record_id: string | null
    date: Date | null
    a_index: Decimal | null
    ice_highest_open_interest_17_months: Decimal | null
    cc_index: Decimal | null
    mcx: Decimal | null
    cepea: Decimal | null
  }

  export type A_indexCountAggregateOutputType = {
    record_id: number
    date: number
    a_index: number
    ice_highest_open_interest_17_months: number
    cc_index: number
    mcx: number
    cepea: number
    _all: number
  }


  export type A_indexAvgAggregateInputType = {
    a_index?: true
    ice_highest_open_interest_17_months?: true
    cc_index?: true
    mcx?: true
    cepea?: true
  }

  export type A_indexSumAggregateInputType = {
    a_index?: true
    ice_highest_open_interest_17_months?: true
    cc_index?: true
    mcx?: true
    cepea?: true
  }

  export type A_indexMinAggregateInputType = {
    record_id?: true
    date?: true
    a_index?: true
    ice_highest_open_interest_17_months?: true
    cc_index?: true
    mcx?: true
    cepea?: true
  }

  export type A_indexMaxAggregateInputType = {
    record_id?: true
    date?: true
    a_index?: true
    ice_highest_open_interest_17_months?: true
    cc_index?: true
    mcx?: true
    cepea?: true
  }

  export type A_indexCountAggregateInputType = {
    record_id?: true
    date?: true
    a_index?: true
    ice_highest_open_interest_17_months?: true
    cc_index?: true
    mcx?: true
    cepea?: true
    _all?: true
  }

  export type A_indexAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which a_index to aggregate.
     */
    where?: a_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of a_indices to fetch.
     */
    orderBy?: Enumerable<a_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: a_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` a_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` a_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned a_indices
    **/
    _count?: true | A_indexCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: A_indexAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: A_indexSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: A_indexMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: A_indexMaxAggregateInputType
  }

  export type GetA_indexAggregateType<T extends A_indexAggregateArgs> = {
        [P in keyof T & keyof AggregateA_index]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateA_index[P]>
      : GetScalarType<T[P], AggregateA_index[P]>
  }




  export type A_indexGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: a_indexWhereInput
    orderBy?: Enumerable<a_indexOrderByWithAggregationInput>
    by: A_indexScalarFieldEnum[]
    having?: a_indexScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: A_indexCountAggregateInputType | true
    _avg?: A_indexAvgAggregateInputType
    _sum?: A_indexSumAggregateInputType
    _min?: A_indexMinAggregateInputType
    _max?: A_indexMaxAggregateInputType
  }


  export type A_indexGroupByOutputType = {
    record_id: string
    date: Date
    a_index: Decimal
    ice_highest_open_interest_17_months: Decimal | null
    cc_index: Decimal | null
    mcx: Decimal | null
    cepea: Decimal | null
    _count: A_indexCountAggregateOutputType | null
    _avg: A_indexAvgAggregateOutputType | null
    _sum: A_indexSumAggregateOutputType | null
    _min: A_indexMinAggregateOutputType | null
    _max: A_indexMaxAggregateOutputType | null
  }

  type GetA_indexGroupByPayload<T extends A_indexGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<A_indexGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof A_indexGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], A_indexGroupByOutputType[P]>
            : GetScalarType<T[P], A_indexGroupByOutputType[P]>
        }
      >
    >


  export type a_indexSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    date?: boolean
    a_index?: boolean
    ice_highest_open_interest_17_months?: boolean
    cc_index?: boolean
    mcx?: boolean
    cepea?: boolean
  }, ExtArgs["result"]["a_index"]>

  export type a_indexSelectScalar = {
    record_id?: boolean
    date?: boolean
    a_index?: boolean
    ice_highest_open_interest_17_months?: boolean
    cc_index?: boolean
    mcx?: boolean
    cepea?: boolean
  }


  type a_indexGetPayload<S extends boolean | null | undefined | a_indexArgs> = $Types.GetResult<a_indexPayload, S>

  type a_indexCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<a_indexFindManyArgs, 'select' | 'include'> & {
      select?: A_indexCountAggregateInputType | true
    }

  export interface a_indexDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['a_index'], meta: { name: 'a_index' } }
    /**
     * Find zero or one A_index that matches the filter.
     * @param {a_indexFindUniqueArgs} args - Arguments to find a A_index
     * @example
     * // Get one A_index
     * const a_index = await prisma.a_index.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends a_indexFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, a_indexFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'a_index'> extends True ? Prisma__a_indexClient<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__a_indexClient<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one A_index that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {a_indexFindUniqueOrThrowArgs} args - Arguments to find a A_index
     * @example
     * // Get one A_index
     * const a_index = await prisma.a_index.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends a_indexFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, a_indexFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__a_indexClient<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first A_index that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {a_indexFindFirstArgs} args - Arguments to find a A_index
     * @example
     * // Get one A_index
     * const a_index = await prisma.a_index.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends a_indexFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, a_indexFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'a_index'> extends True ? Prisma__a_indexClient<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__a_indexClient<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first A_index that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {a_indexFindFirstOrThrowArgs} args - Arguments to find a A_index
     * @example
     * // Get one A_index
     * const a_index = await prisma.a_index.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends a_indexFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, a_indexFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__a_indexClient<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more A_indices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {a_indexFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all A_indices
     * const a_indices = await prisma.a_index.findMany()
     * 
     * // Get first 10 A_indices
     * const a_indices = await prisma.a_index.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const a_indexWithRecord_idOnly = await prisma.a_index.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends a_indexFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, a_indexFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a A_index.
     * @param {a_indexCreateArgs} args - Arguments to create a A_index.
     * @example
     * // Create one A_index
     * const A_index = await prisma.a_index.create({
     *   data: {
     *     // ... data to create a A_index
     *   }
     * })
     * 
    **/
    create<T extends a_indexCreateArgs<ExtArgs>>(
      args: SelectSubset<T, a_indexCreateArgs<ExtArgs>>
    ): Prisma__a_indexClient<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many A_indices.
     *     @param {a_indexCreateManyArgs} args - Arguments to create many A_indices.
     *     @example
     *     // Create many A_indices
     *     const a_index = await prisma.a_index.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends a_indexCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, a_indexCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a A_index.
     * @param {a_indexDeleteArgs} args - Arguments to delete one A_index.
     * @example
     * // Delete one A_index
     * const A_index = await prisma.a_index.delete({
     *   where: {
     *     // ... filter to delete one A_index
     *   }
     * })
     * 
    **/
    delete<T extends a_indexDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, a_indexDeleteArgs<ExtArgs>>
    ): Prisma__a_indexClient<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one A_index.
     * @param {a_indexUpdateArgs} args - Arguments to update one A_index.
     * @example
     * // Update one A_index
     * const a_index = await prisma.a_index.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends a_indexUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, a_indexUpdateArgs<ExtArgs>>
    ): Prisma__a_indexClient<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more A_indices.
     * @param {a_indexDeleteManyArgs} args - Arguments to filter A_indices to delete.
     * @example
     * // Delete a few A_indices
     * const { count } = await prisma.a_index.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends a_indexDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, a_indexDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more A_indices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {a_indexUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many A_indices
     * const a_index = await prisma.a_index.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends a_indexUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, a_indexUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one A_index.
     * @param {a_indexUpsertArgs} args - Arguments to update or create a A_index.
     * @example
     * // Update or create a A_index
     * const a_index = await prisma.a_index.upsert({
     *   create: {
     *     // ... data to create a A_index
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the A_index we want to update
     *   }
     * })
    **/
    upsert<T extends a_indexUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, a_indexUpsertArgs<ExtArgs>>
    ): Prisma__a_indexClient<$Types.GetResult<a_indexPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of A_indices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {a_indexCountArgs} args - Arguments to filter A_indices to count.
     * @example
     * // Count the number of A_indices
     * const count = await prisma.a_index.count({
     *   where: {
     *     // ... the filter for the A_indices we want to count
     *   }
     * })
    **/
    count<T extends a_indexCountArgs>(
      args?: Subset<T, a_indexCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], A_indexCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a A_index.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {A_indexAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends A_indexAggregateArgs>(args: Subset<T, A_indexAggregateArgs>): Prisma.PrismaPromise<GetA_indexAggregateType<T>>

    /**
     * Group by A_index.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {A_indexGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends A_indexGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: A_indexGroupByArgs['orderBy'] }
        : { orderBy?: A_indexGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, A_indexGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetA_indexGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for a_index.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__a_indexClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * a_index base type for findUnique actions
   */
  export type a_indexFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the a_index
     */
    select?: a_indexSelect<ExtArgs> | null
    /**
     * Filter, which a_index to fetch.
     */
    where: a_indexWhereUniqueInput
  }

  /**
   * a_index findUnique
   */
  export interface a_indexFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends a_indexFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * a_index findUniqueOrThrow
   */
  export type a_indexFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the a_index
     */
    select?: a_indexSelect<ExtArgs> | null
    /**
     * Filter, which a_index to fetch.
     */
    where: a_indexWhereUniqueInput
  }


  /**
   * a_index base type for findFirst actions
   */
  export type a_indexFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the a_index
     */
    select?: a_indexSelect<ExtArgs> | null
    /**
     * Filter, which a_index to fetch.
     */
    where?: a_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of a_indices to fetch.
     */
    orderBy?: Enumerable<a_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for a_indices.
     */
    cursor?: a_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` a_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` a_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of a_indices.
     */
    distinct?: Enumerable<A_indexScalarFieldEnum>
  }

  /**
   * a_index findFirst
   */
  export interface a_indexFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends a_indexFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * a_index findFirstOrThrow
   */
  export type a_indexFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the a_index
     */
    select?: a_indexSelect<ExtArgs> | null
    /**
     * Filter, which a_index to fetch.
     */
    where?: a_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of a_indices to fetch.
     */
    orderBy?: Enumerable<a_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for a_indices.
     */
    cursor?: a_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` a_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` a_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of a_indices.
     */
    distinct?: Enumerable<A_indexScalarFieldEnum>
  }


  /**
   * a_index findMany
   */
  export type a_indexFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the a_index
     */
    select?: a_indexSelect<ExtArgs> | null
    /**
     * Filter, which a_indices to fetch.
     */
    where?: a_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of a_indices to fetch.
     */
    orderBy?: Enumerable<a_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing a_indices.
     */
    cursor?: a_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` a_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` a_indices.
     */
    skip?: number
    distinct?: Enumerable<A_indexScalarFieldEnum>
  }


  /**
   * a_index create
   */
  export type a_indexCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the a_index
     */
    select?: a_indexSelect<ExtArgs> | null
    /**
     * The data needed to create a a_index.
     */
    data: XOR<a_indexCreateInput, a_indexUncheckedCreateInput>
  }


  /**
   * a_index createMany
   */
  export type a_indexCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many a_indices.
     */
    data: Enumerable<a_indexCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * a_index update
   */
  export type a_indexUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the a_index
     */
    select?: a_indexSelect<ExtArgs> | null
    /**
     * The data needed to update a a_index.
     */
    data: XOR<a_indexUpdateInput, a_indexUncheckedUpdateInput>
    /**
     * Choose, which a_index to update.
     */
    where: a_indexWhereUniqueInput
  }


  /**
   * a_index updateMany
   */
  export type a_indexUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update a_indices.
     */
    data: XOR<a_indexUpdateManyMutationInput, a_indexUncheckedUpdateManyInput>
    /**
     * Filter which a_indices to update
     */
    where?: a_indexWhereInput
  }


  /**
   * a_index upsert
   */
  export type a_indexUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the a_index
     */
    select?: a_indexSelect<ExtArgs> | null
    /**
     * The filter to search for the a_index to update in case it exists.
     */
    where: a_indexWhereUniqueInput
    /**
     * In case the a_index found by the `where` argument doesn't exist, create a new a_index with this data.
     */
    create: XOR<a_indexCreateInput, a_indexUncheckedCreateInput>
    /**
     * In case the a_index was found with the provided `where` argument, update it with this data.
     */
    update: XOR<a_indexUpdateInput, a_indexUncheckedUpdateInput>
  }


  /**
   * a_index delete
   */
  export type a_indexDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the a_index
     */
    select?: a_indexSelect<ExtArgs> | null
    /**
     * Filter which a_index to delete.
     */
    where: a_indexWhereUniqueInput
  }


  /**
   * a_index deleteMany
   */
  export type a_indexDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which a_indices to delete
     */
    where?: a_indexWhereInput
  }


  /**
   * a_index without action
   */
  export type a_indexArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the a_index
     */
    select?: a_indexSelect<ExtArgs> | null
  }



  /**
   * Model fixed_cotton
   */


  export type AggregateFixed_cotton = {
    _count: Fixed_cottonCountAggregateOutputType | null
    _avg: Fixed_cottonAvgAggregateOutputType | null
    _sum: Fixed_cottonSumAggregateOutputType | null
    _min: Fixed_cottonMinAggregateOutputType | null
    _max: Fixed_cottonMaxAggregateOutputType | null
  }

  export type Fixed_cottonAvgAggregateOutputType = {
    basis: Decimal | null
    fixed_price_without_basis: Decimal | null
    amount_fixed: Decimal | null
  }

  export type Fixed_cottonSumAggregateOutputType = {
    basis: Decimal | null
    fixed_price_without_basis: Decimal | null
    amount_fixed: Decimal | null
  }

  export type Fixed_cottonMinAggregateOutputType = {
    company_id: string | null
    record_id: string | null
    contract_number: string | null
    futures_month: string | null
    basis: Decimal | null
    fixed_price_without_basis: Decimal | null
    amount_fixed: Decimal | null
    added_by: string | null
    date_created: Date | null
  }

  export type Fixed_cottonMaxAggregateOutputType = {
    company_id: string | null
    record_id: string | null
    contract_number: string | null
    futures_month: string | null
    basis: Decimal | null
    fixed_price_without_basis: Decimal | null
    amount_fixed: Decimal | null
    added_by: string | null
    date_created: Date | null
  }

  export type Fixed_cottonCountAggregateOutputType = {
    company_id: number
    record_id: number
    contract_number: number
    futures_month: number
    basis: number
    fixed_price_without_basis: number
    amount_fixed: number
    added_by: number
    date_created: number
    _all: number
  }


  export type Fixed_cottonAvgAggregateInputType = {
    basis?: true
    fixed_price_without_basis?: true
    amount_fixed?: true
  }

  export type Fixed_cottonSumAggregateInputType = {
    basis?: true
    fixed_price_without_basis?: true
    amount_fixed?: true
  }

  export type Fixed_cottonMinAggregateInputType = {
    company_id?: true
    record_id?: true
    contract_number?: true
    futures_month?: true
    basis?: true
    fixed_price_without_basis?: true
    amount_fixed?: true
    added_by?: true
    date_created?: true
  }

  export type Fixed_cottonMaxAggregateInputType = {
    company_id?: true
    record_id?: true
    contract_number?: true
    futures_month?: true
    basis?: true
    fixed_price_without_basis?: true
    amount_fixed?: true
    added_by?: true
    date_created?: true
  }

  export type Fixed_cottonCountAggregateInputType = {
    company_id?: true
    record_id?: true
    contract_number?: true
    futures_month?: true
    basis?: true
    fixed_price_without_basis?: true
    amount_fixed?: true
    added_by?: true
    date_created?: true
    _all?: true
  }

  export type Fixed_cottonAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fixed_cotton to aggregate.
     */
    where?: fixed_cottonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixed_cottons to fetch.
     */
    orderBy?: Enumerable<fixed_cottonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fixed_cottonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixed_cottons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixed_cottons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fixed_cottons
    **/
    _count?: true | Fixed_cottonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fixed_cottonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fixed_cottonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fixed_cottonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fixed_cottonMaxAggregateInputType
  }

  export type GetFixed_cottonAggregateType<T extends Fixed_cottonAggregateArgs> = {
        [P in keyof T & keyof AggregateFixed_cotton]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFixed_cotton[P]>
      : GetScalarType<T[P], AggregateFixed_cotton[P]>
  }




  export type Fixed_cottonGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fixed_cottonWhereInput
    orderBy?: Enumerable<fixed_cottonOrderByWithAggregationInput>
    by: Fixed_cottonScalarFieldEnum[]
    having?: fixed_cottonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fixed_cottonCountAggregateInputType | true
    _avg?: Fixed_cottonAvgAggregateInputType
    _sum?: Fixed_cottonSumAggregateInputType
    _min?: Fixed_cottonMinAggregateInputType
    _max?: Fixed_cottonMaxAggregateInputType
  }


  export type Fixed_cottonGroupByOutputType = {
    company_id: string
    record_id: string
    contract_number: string
    futures_month: string
    basis: Decimal | null
    fixed_price_without_basis: Decimal | null
    amount_fixed: Decimal | null
    added_by: string
    date_created: Date
    _count: Fixed_cottonCountAggregateOutputType | null
    _avg: Fixed_cottonAvgAggregateOutputType | null
    _sum: Fixed_cottonSumAggregateOutputType | null
    _min: Fixed_cottonMinAggregateOutputType | null
    _max: Fixed_cottonMaxAggregateOutputType | null
  }

  type GetFixed_cottonGroupByPayload<T extends Fixed_cottonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Fixed_cottonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fixed_cottonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fixed_cottonGroupByOutputType[P]>
            : GetScalarType<T[P], Fixed_cottonGroupByOutputType[P]>
        }
      >
    >


  export type fixed_cottonSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_id?: boolean
    record_id?: boolean
    contract_number?: boolean
    futures_month?: boolean
    basis?: boolean
    fixed_price_without_basis?: boolean
    amount_fixed?: boolean
    added_by?: boolean
    date_created?: boolean
    company?: boolean | CompanyArgs<ExtArgs>
  }, ExtArgs["result"]["fixed_cotton"]>

  export type fixed_cottonSelectScalar = {
    company_id?: boolean
    record_id?: boolean
    contract_number?: boolean
    futures_month?: boolean
    basis?: boolean
    fixed_price_without_basis?: boolean
    amount_fixed?: boolean
    added_by?: boolean
    date_created?: boolean
  }

  export type fixed_cottonInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyArgs<ExtArgs>
  }


  type fixed_cottonGetPayload<S extends boolean | null | undefined | fixed_cottonArgs> = $Types.GetResult<fixed_cottonPayload, S>

  type fixed_cottonCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<fixed_cottonFindManyArgs, 'select' | 'include'> & {
      select?: Fixed_cottonCountAggregateInputType | true
    }

  export interface fixed_cottonDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fixed_cotton'], meta: { name: 'fixed_cotton' } }
    /**
     * Find zero or one Fixed_cotton that matches the filter.
     * @param {fixed_cottonFindUniqueArgs} args - Arguments to find a Fixed_cotton
     * @example
     * // Get one Fixed_cotton
     * const fixed_cotton = await prisma.fixed_cotton.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fixed_cottonFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fixed_cottonFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fixed_cotton'> extends True ? Prisma__fixed_cottonClient<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__fixed_cottonClient<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Fixed_cotton that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fixed_cottonFindUniqueOrThrowArgs} args - Arguments to find a Fixed_cotton
     * @example
     * // Get one Fixed_cotton
     * const fixed_cotton = await prisma.fixed_cotton.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fixed_cottonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fixed_cottonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fixed_cottonClient<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Fixed_cotton that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixed_cottonFindFirstArgs} args - Arguments to find a Fixed_cotton
     * @example
     * // Get one Fixed_cotton
     * const fixed_cotton = await prisma.fixed_cotton.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fixed_cottonFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fixed_cottonFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fixed_cotton'> extends True ? Prisma__fixed_cottonClient<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__fixed_cottonClient<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Fixed_cotton that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixed_cottonFindFirstOrThrowArgs} args - Arguments to find a Fixed_cotton
     * @example
     * // Get one Fixed_cotton
     * const fixed_cotton = await prisma.fixed_cotton.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fixed_cottonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fixed_cottonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fixed_cottonClient<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Fixed_cottons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixed_cottonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fixed_cottons
     * const fixed_cottons = await prisma.fixed_cotton.findMany()
     * 
     * // Get first 10 Fixed_cottons
     * const fixed_cottons = await prisma.fixed_cotton.findMany({ take: 10 })
     * 
     * // Only select the `company_id`
     * const fixed_cottonWithCompany_idOnly = await prisma.fixed_cotton.findMany({ select: { company_id: true } })
     * 
    **/
    findMany<T extends fixed_cottonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fixed_cottonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Fixed_cotton.
     * @param {fixed_cottonCreateArgs} args - Arguments to create a Fixed_cotton.
     * @example
     * // Create one Fixed_cotton
     * const Fixed_cotton = await prisma.fixed_cotton.create({
     *   data: {
     *     // ... data to create a Fixed_cotton
     *   }
     * })
     * 
    **/
    create<T extends fixed_cottonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fixed_cottonCreateArgs<ExtArgs>>
    ): Prisma__fixed_cottonClient<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Fixed_cottons.
     *     @param {fixed_cottonCreateManyArgs} args - Arguments to create many Fixed_cottons.
     *     @example
     *     // Create many Fixed_cottons
     *     const fixed_cotton = await prisma.fixed_cotton.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fixed_cottonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fixed_cottonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fixed_cotton.
     * @param {fixed_cottonDeleteArgs} args - Arguments to delete one Fixed_cotton.
     * @example
     * // Delete one Fixed_cotton
     * const Fixed_cotton = await prisma.fixed_cotton.delete({
     *   where: {
     *     // ... filter to delete one Fixed_cotton
     *   }
     * })
     * 
    **/
    delete<T extends fixed_cottonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fixed_cottonDeleteArgs<ExtArgs>>
    ): Prisma__fixed_cottonClient<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Fixed_cotton.
     * @param {fixed_cottonUpdateArgs} args - Arguments to update one Fixed_cotton.
     * @example
     * // Update one Fixed_cotton
     * const fixed_cotton = await prisma.fixed_cotton.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fixed_cottonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fixed_cottonUpdateArgs<ExtArgs>>
    ): Prisma__fixed_cottonClient<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Fixed_cottons.
     * @param {fixed_cottonDeleteManyArgs} args - Arguments to filter Fixed_cottons to delete.
     * @example
     * // Delete a few Fixed_cottons
     * const { count } = await prisma.fixed_cotton.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fixed_cottonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fixed_cottonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fixed_cottons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixed_cottonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fixed_cottons
     * const fixed_cotton = await prisma.fixed_cotton.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fixed_cottonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fixed_cottonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fixed_cotton.
     * @param {fixed_cottonUpsertArgs} args - Arguments to update or create a Fixed_cotton.
     * @example
     * // Update or create a Fixed_cotton
     * const fixed_cotton = await prisma.fixed_cotton.upsert({
     *   create: {
     *     // ... data to create a Fixed_cotton
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fixed_cotton we want to update
     *   }
     * })
    **/
    upsert<T extends fixed_cottonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fixed_cottonUpsertArgs<ExtArgs>>
    ): Prisma__fixed_cottonClient<$Types.GetResult<fixed_cottonPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Fixed_cottons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fixed_cottonCountArgs} args - Arguments to filter Fixed_cottons to count.
     * @example
     * // Count the number of Fixed_cottons
     * const count = await prisma.fixed_cotton.count({
     *   where: {
     *     // ... the filter for the Fixed_cottons we want to count
     *   }
     * })
    **/
    count<T extends fixed_cottonCountArgs>(
      args?: Subset<T, fixed_cottonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fixed_cottonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fixed_cotton.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fixed_cottonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fixed_cottonAggregateArgs>(args: Subset<T, Fixed_cottonAggregateArgs>): Prisma.PrismaPromise<GetFixed_cottonAggregateType<T>>

    /**
     * Group by Fixed_cotton.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fixed_cottonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fixed_cottonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fixed_cottonGroupByArgs['orderBy'] }
        : { orderBy?: Fixed_cottonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fixed_cottonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFixed_cottonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fixed_cotton.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fixed_cottonClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    company<T extends CompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fixed_cotton base type for findUnique actions
   */
  export type fixed_cottonFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
    /**
     * Filter, which fixed_cotton to fetch.
     */
    where: fixed_cottonWhereUniqueInput
  }

  /**
   * fixed_cotton findUnique
   */
  export interface fixed_cottonFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fixed_cottonFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fixed_cotton findUniqueOrThrow
   */
  export type fixed_cottonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
    /**
     * Filter, which fixed_cotton to fetch.
     */
    where: fixed_cottonWhereUniqueInput
  }


  /**
   * fixed_cotton base type for findFirst actions
   */
  export type fixed_cottonFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
    /**
     * Filter, which fixed_cotton to fetch.
     */
    where?: fixed_cottonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixed_cottons to fetch.
     */
    orderBy?: Enumerable<fixed_cottonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fixed_cottons.
     */
    cursor?: fixed_cottonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixed_cottons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixed_cottons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fixed_cottons.
     */
    distinct?: Enumerable<Fixed_cottonScalarFieldEnum>
  }

  /**
   * fixed_cotton findFirst
   */
  export interface fixed_cottonFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fixed_cottonFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fixed_cotton findFirstOrThrow
   */
  export type fixed_cottonFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
    /**
     * Filter, which fixed_cotton to fetch.
     */
    where?: fixed_cottonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixed_cottons to fetch.
     */
    orderBy?: Enumerable<fixed_cottonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fixed_cottons.
     */
    cursor?: fixed_cottonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixed_cottons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixed_cottons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fixed_cottons.
     */
    distinct?: Enumerable<Fixed_cottonScalarFieldEnum>
  }


  /**
   * fixed_cotton findMany
   */
  export type fixed_cottonFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
    /**
     * Filter, which fixed_cottons to fetch.
     */
    where?: fixed_cottonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fixed_cottons to fetch.
     */
    orderBy?: Enumerable<fixed_cottonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fixed_cottons.
     */
    cursor?: fixed_cottonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fixed_cottons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fixed_cottons.
     */
    skip?: number
    distinct?: Enumerable<Fixed_cottonScalarFieldEnum>
  }


  /**
   * fixed_cotton create
   */
  export type fixed_cottonCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
    /**
     * The data needed to create a fixed_cotton.
     */
    data: XOR<fixed_cottonCreateInput, fixed_cottonUncheckedCreateInput>
  }


  /**
   * fixed_cotton createMany
   */
  export type fixed_cottonCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fixed_cottons.
     */
    data: Enumerable<fixed_cottonCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fixed_cotton update
   */
  export type fixed_cottonUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
    /**
     * The data needed to update a fixed_cotton.
     */
    data: XOR<fixed_cottonUpdateInput, fixed_cottonUncheckedUpdateInput>
    /**
     * Choose, which fixed_cotton to update.
     */
    where: fixed_cottonWhereUniqueInput
  }


  /**
   * fixed_cotton updateMany
   */
  export type fixed_cottonUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fixed_cottons.
     */
    data: XOR<fixed_cottonUpdateManyMutationInput, fixed_cottonUncheckedUpdateManyInput>
    /**
     * Filter which fixed_cottons to update
     */
    where?: fixed_cottonWhereInput
  }


  /**
   * fixed_cotton upsert
   */
  export type fixed_cottonUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
    /**
     * The filter to search for the fixed_cotton to update in case it exists.
     */
    where: fixed_cottonWhereUniqueInput
    /**
     * In case the fixed_cotton found by the `where` argument doesn't exist, create a new fixed_cotton with this data.
     */
    create: XOR<fixed_cottonCreateInput, fixed_cottonUncheckedCreateInput>
    /**
     * In case the fixed_cotton was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fixed_cottonUpdateInput, fixed_cottonUncheckedUpdateInput>
  }


  /**
   * fixed_cotton delete
   */
  export type fixed_cottonDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
    /**
     * Filter which fixed_cotton to delete.
     */
    where: fixed_cottonWhereUniqueInput
  }


  /**
   * fixed_cotton deleteMany
   */
  export type fixed_cottonDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fixed_cottons to delete
     */
    where?: fixed_cottonWhereInput
  }


  /**
   * fixed_cotton without action
   */
  export type fixed_cottonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fixed_cotton
     */
    select?: fixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fixed_cottonInclude<ExtArgs> | null
  }



  /**
   * Model unfixed_cotton
   */


  export type AggregateUnfixed_cotton = {
    _count: Unfixed_cottonCountAggregateOutputType | null
    _avg: Unfixed_cottonAvgAggregateOutputType | null
    _sum: Unfixed_cottonSumAggregateOutputType | null
    _min: Unfixed_cottonMinAggregateOutputType | null
    _max: Unfixed_cottonMaxAggregateOutputType | null
  }

  export type Unfixed_cottonAvgAggregateOutputType = {
    basis: Decimal | null
    total_amount: Decimal | null
    amount_remaining: Decimal | null
  }

  export type Unfixed_cottonSumAggregateOutputType = {
    basis: Decimal | null
    total_amount: Decimal | null
    amount_remaining: Decimal | null
  }

  export type Unfixed_cottonMinAggregateOutputType = {
    record_id: string | null
    company_id: string | null
    contract_number: string | null
    futures_month: string | null
    basis: Decimal | null
    fix_by: Date | null
    total_amount: Decimal | null
    amount_remaining: Decimal | null
    added_by: string | null
    date_created: Date | null
  }

  export type Unfixed_cottonMaxAggregateOutputType = {
    record_id: string | null
    company_id: string | null
    contract_number: string | null
    futures_month: string | null
    basis: Decimal | null
    fix_by: Date | null
    total_amount: Decimal | null
    amount_remaining: Decimal | null
    added_by: string | null
    date_created: Date | null
  }

  export type Unfixed_cottonCountAggregateOutputType = {
    record_id: number
    company_id: number
    contract_number: number
    futures_month: number
    basis: number
    fix_by: number
    total_amount: number
    amount_remaining: number
    added_by: number
    date_created: number
    _all: number
  }


  export type Unfixed_cottonAvgAggregateInputType = {
    basis?: true
    total_amount?: true
    amount_remaining?: true
  }

  export type Unfixed_cottonSumAggregateInputType = {
    basis?: true
    total_amount?: true
    amount_remaining?: true
  }

  export type Unfixed_cottonMinAggregateInputType = {
    record_id?: true
    company_id?: true
    contract_number?: true
    futures_month?: true
    basis?: true
    fix_by?: true
    total_amount?: true
    amount_remaining?: true
    added_by?: true
    date_created?: true
  }

  export type Unfixed_cottonMaxAggregateInputType = {
    record_id?: true
    company_id?: true
    contract_number?: true
    futures_month?: true
    basis?: true
    fix_by?: true
    total_amount?: true
    amount_remaining?: true
    added_by?: true
    date_created?: true
  }

  export type Unfixed_cottonCountAggregateInputType = {
    record_id?: true
    company_id?: true
    contract_number?: true
    futures_month?: true
    basis?: true
    fix_by?: true
    total_amount?: true
    amount_remaining?: true
    added_by?: true
    date_created?: true
    _all?: true
  }

  export type Unfixed_cottonAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which unfixed_cotton to aggregate.
     */
    where?: unfixed_cottonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unfixed_cottons to fetch.
     */
    orderBy?: Enumerable<unfixed_cottonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: unfixed_cottonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unfixed_cottons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unfixed_cottons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned unfixed_cottons
    **/
    _count?: true | Unfixed_cottonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Unfixed_cottonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Unfixed_cottonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Unfixed_cottonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Unfixed_cottonMaxAggregateInputType
  }

  export type GetUnfixed_cottonAggregateType<T extends Unfixed_cottonAggregateArgs> = {
        [P in keyof T & keyof AggregateUnfixed_cotton]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnfixed_cotton[P]>
      : GetScalarType<T[P], AggregateUnfixed_cotton[P]>
  }




  export type Unfixed_cottonGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: unfixed_cottonWhereInput
    orderBy?: Enumerable<unfixed_cottonOrderByWithAggregationInput>
    by: Unfixed_cottonScalarFieldEnum[]
    having?: unfixed_cottonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Unfixed_cottonCountAggregateInputType | true
    _avg?: Unfixed_cottonAvgAggregateInputType
    _sum?: Unfixed_cottonSumAggregateInputType
    _min?: Unfixed_cottonMinAggregateInputType
    _max?: Unfixed_cottonMaxAggregateInputType
  }


  export type Unfixed_cottonGroupByOutputType = {
    record_id: string
    company_id: string
    contract_number: string
    futures_month: string
    basis: Decimal | null
    fix_by: Date
    total_amount: Decimal | null
    amount_remaining: Decimal | null
    added_by: string
    date_created: Date
    _count: Unfixed_cottonCountAggregateOutputType | null
    _avg: Unfixed_cottonAvgAggregateOutputType | null
    _sum: Unfixed_cottonSumAggregateOutputType | null
    _min: Unfixed_cottonMinAggregateOutputType | null
    _max: Unfixed_cottonMaxAggregateOutputType | null
  }

  type GetUnfixed_cottonGroupByPayload<T extends Unfixed_cottonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Unfixed_cottonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Unfixed_cottonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Unfixed_cottonGroupByOutputType[P]>
            : GetScalarType<T[P], Unfixed_cottonGroupByOutputType[P]>
        }
      >
    >


  export type unfixed_cottonSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    company_id?: boolean
    contract_number?: boolean
    futures_month?: boolean
    basis?: boolean
    fix_by?: boolean
    total_amount?: boolean
    amount_remaining?: boolean
    added_by?: boolean
    date_created?: boolean
    company?: boolean | CompanyArgs<ExtArgs>
  }, ExtArgs["result"]["unfixed_cotton"]>

  export type unfixed_cottonSelectScalar = {
    record_id?: boolean
    company_id?: boolean
    contract_number?: boolean
    futures_month?: boolean
    basis?: boolean
    fix_by?: boolean
    total_amount?: boolean
    amount_remaining?: boolean
    added_by?: boolean
    date_created?: boolean
  }

  export type unfixed_cottonInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyArgs<ExtArgs>
  }


  type unfixed_cottonGetPayload<S extends boolean | null | undefined | unfixed_cottonArgs> = $Types.GetResult<unfixed_cottonPayload, S>

  type unfixed_cottonCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<unfixed_cottonFindManyArgs, 'select' | 'include'> & {
      select?: Unfixed_cottonCountAggregateInputType | true
    }

  export interface unfixed_cottonDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['unfixed_cotton'], meta: { name: 'unfixed_cotton' } }
    /**
     * Find zero or one Unfixed_cotton that matches the filter.
     * @param {unfixed_cottonFindUniqueArgs} args - Arguments to find a Unfixed_cotton
     * @example
     * // Get one Unfixed_cotton
     * const unfixed_cotton = await prisma.unfixed_cotton.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends unfixed_cottonFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, unfixed_cottonFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'unfixed_cotton'> extends True ? Prisma__unfixed_cottonClient<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__unfixed_cottonClient<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Unfixed_cotton that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {unfixed_cottonFindUniqueOrThrowArgs} args - Arguments to find a Unfixed_cotton
     * @example
     * // Get one Unfixed_cotton
     * const unfixed_cotton = await prisma.unfixed_cotton.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends unfixed_cottonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, unfixed_cottonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__unfixed_cottonClient<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Unfixed_cotton that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unfixed_cottonFindFirstArgs} args - Arguments to find a Unfixed_cotton
     * @example
     * // Get one Unfixed_cotton
     * const unfixed_cotton = await prisma.unfixed_cotton.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends unfixed_cottonFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, unfixed_cottonFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'unfixed_cotton'> extends True ? Prisma__unfixed_cottonClient<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__unfixed_cottonClient<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Unfixed_cotton that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unfixed_cottonFindFirstOrThrowArgs} args - Arguments to find a Unfixed_cotton
     * @example
     * // Get one Unfixed_cotton
     * const unfixed_cotton = await prisma.unfixed_cotton.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends unfixed_cottonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, unfixed_cottonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__unfixed_cottonClient<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Unfixed_cottons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unfixed_cottonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Unfixed_cottons
     * const unfixed_cottons = await prisma.unfixed_cotton.findMany()
     * 
     * // Get first 10 Unfixed_cottons
     * const unfixed_cottons = await prisma.unfixed_cotton.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const unfixed_cottonWithRecord_idOnly = await prisma.unfixed_cotton.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends unfixed_cottonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, unfixed_cottonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Unfixed_cotton.
     * @param {unfixed_cottonCreateArgs} args - Arguments to create a Unfixed_cotton.
     * @example
     * // Create one Unfixed_cotton
     * const Unfixed_cotton = await prisma.unfixed_cotton.create({
     *   data: {
     *     // ... data to create a Unfixed_cotton
     *   }
     * })
     * 
    **/
    create<T extends unfixed_cottonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, unfixed_cottonCreateArgs<ExtArgs>>
    ): Prisma__unfixed_cottonClient<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Unfixed_cottons.
     *     @param {unfixed_cottonCreateManyArgs} args - Arguments to create many Unfixed_cottons.
     *     @example
     *     // Create many Unfixed_cottons
     *     const unfixed_cotton = await prisma.unfixed_cotton.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends unfixed_cottonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, unfixed_cottonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unfixed_cotton.
     * @param {unfixed_cottonDeleteArgs} args - Arguments to delete one Unfixed_cotton.
     * @example
     * // Delete one Unfixed_cotton
     * const Unfixed_cotton = await prisma.unfixed_cotton.delete({
     *   where: {
     *     // ... filter to delete one Unfixed_cotton
     *   }
     * })
     * 
    **/
    delete<T extends unfixed_cottonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, unfixed_cottonDeleteArgs<ExtArgs>>
    ): Prisma__unfixed_cottonClient<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Unfixed_cotton.
     * @param {unfixed_cottonUpdateArgs} args - Arguments to update one Unfixed_cotton.
     * @example
     * // Update one Unfixed_cotton
     * const unfixed_cotton = await prisma.unfixed_cotton.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends unfixed_cottonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, unfixed_cottonUpdateArgs<ExtArgs>>
    ): Prisma__unfixed_cottonClient<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Unfixed_cottons.
     * @param {unfixed_cottonDeleteManyArgs} args - Arguments to filter Unfixed_cottons to delete.
     * @example
     * // Delete a few Unfixed_cottons
     * const { count } = await prisma.unfixed_cotton.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends unfixed_cottonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, unfixed_cottonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Unfixed_cottons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unfixed_cottonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Unfixed_cottons
     * const unfixed_cotton = await prisma.unfixed_cotton.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends unfixed_cottonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, unfixed_cottonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unfixed_cotton.
     * @param {unfixed_cottonUpsertArgs} args - Arguments to update or create a Unfixed_cotton.
     * @example
     * // Update or create a Unfixed_cotton
     * const unfixed_cotton = await prisma.unfixed_cotton.upsert({
     *   create: {
     *     // ... data to create a Unfixed_cotton
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unfixed_cotton we want to update
     *   }
     * })
    **/
    upsert<T extends unfixed_cottonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, unfixed_cottonUpsertArgs<ExtArgs>>
    ): Prisma__unfixed_cottonClient<$Types.GetResult<unfixed_cottonPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Unfixed_cottons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unfixed_cottonCountArgs} args - Arguments to filter Unfixed_cottons to count.
     * @example
     * // Count the number of Unfixed_cottons
     * const count = await prisma.unfixed_cotton.count({
     *   where: {
     *     // ... the filter for the Unfixed_cottons we want to count
     *   }
     * })
    **/
    count<T extends unfixed_cottonCountArgs>(
      args?: Subset<T, unfixed_cottonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Unfixed_cottonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unfixed_cotton.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unfixed_cottonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Unfixed_cottonAggregateArgs>(args: Subset<T, Unfixed_cottonAggregateArgs>): Prisma.PrismaPromise<GetUnfixed_cottonAggregateType<T>>

    /**
     * Group by Unfixed_cotton.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unfixed_cottonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Unfixed_cottonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Unfixed_cottonGroupByArgs['orderBy'] }
        : { orderBy?: Unfixed_cottonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Unfixed_cottonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnfixed_cottonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for unfixed_cotton.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__unfixed_cottonClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    company<T extends CompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * unfixed_cotton base type for findUnique actions
   */
  export type unfixed_cottonFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
    /**
     * Filter, which unfixed_cotton to fetch.
     */
    where: unfixed_cottonWhereUniqueInput
  }

  /**
   * unfixed_cotton findUnique
   */
  export interface unfixed_cottonFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends unfixed_cottonFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * unfixed_cotton findUniqueOrThrow
   */
  export type unfixed_cottonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
    /**
     * Filter, which unfixed_cotton to fetch.
     */
    where: unfixed_cottonWhereUniqueInput
  }


  /**
   * unfixed_cotton base type for findFirst actions
   */
  export type unfixed_cottonFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
    /**
     * Filter, which unfixed_cotton to fetch.
     */
    where?: unfixed_cottonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unfixed_cottons to fetch.
     */
    orderBy?: Enumerable<unfixed_cottonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unfixed_cottons.
     */
    cursor?: unfixed_cottonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unfixed_cottons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unfixed_cottons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unfixed_cottons.
     */
    distinct?: Enumerable<Unfixed_cottonScalarFieldEnum>
  }

  /**
   * unfixed_cotton findFirst
   */
  export interface unfixed_cottonFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends unfixed_cottonFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * unfixed_cotton findFirstOrThrow
   */
  export type unfixed_cottonFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
    /**
     * Filter, which unfixed_cotton to fetch.
     */
    where?: unfixed_cottonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unfixed_cottons to fetch.
     */
    orderBy?: Enumerable<unfixed_cottonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unfixed_cottons.
     */
    cursor?: unfixed_cottonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unfixed_cottons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unfixed_cottons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unfixed_cottons.
     */
    distinct?: Enumerable<Unfixed_cottonScalarFieldEnum>
  }


  /**
   * unfixed_cotton findMany
   */
  export type unfixed_cottonFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
    /**
     * Filter, which unfixed_cottons to fetch.
     */
    where?: unfixed_cottonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unfixed_cottons to fetch.
     */
    orderBy?: Enumerable<unfixed_cottonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing unfixed_cottons.
     */
    cursor?: unfixed_cottonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unfixed_cottons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unfixed_cottons.
     */
    skip?: number
    distinct?: Enumerable<Unfixed_cottonScalarFieldEnum>
  }


  /**
   * unfixed_cotton create
   */
  export type unfixed_cottonCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
    /**
     * The data needed to create a unfixed_cotton.
     */
    data: XOR<unfixed_cottonCreateInput, unfixed_cottonUncheckedCreateInput>
  }


  /**
   * unfixed_cotton createMany
   */
  export type unfixed_cottonCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many unfixed_cottons.
     */
    data: Enumerable<unfixed_cottonCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * unfixed_cotton update
   */
  export type unfixed_cottonUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
    /**
     * The data needed to update a unfixed_cotton.
     */
    data: XOR<unfixed_cottonUpdateInput, unfixed_cottonUncheckedUpdateInput>
    /**
     * Choose, which unfixed_cotton to update.
     */
    where: unfixed_cottonWhereUniqueInput
  }


  /**
   * unfixed_cotton updateMany
   */
  export type unfixed_cottonUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update unfixed_cottons.
     */
    data: XOR<unfixed_cottonUpdateManyMutationInput, unfixed_cottonUncheckedUpdateManyInput>
    /**
     * Filter which unfixed_cottons to update
     */
    where?: unfixed_cottonWhereInput
  }


  /**
   * unfixed_cotton upsert
   */
  export type unfixed_cottonUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
    /**
     * The filter to search for the unfixed_cotton to update in case it exists.
     */
    where: unfixed_cottonWhereUniqueInput
    /**
     * In case the unfixed_cotton found by the `where` argument doesn't exist, create a new unfixed_cotton with this data.
     */
    create: XOR<unfixed_cottonCreateInput, unfixed_cottonUncheckedCreateInput>
    /**
     * In case the unfixed_cotton was found with the provided `where` argument, update it with this data.
     */
    update: XOR<unfixed_cottonUpdateInput, unfixed_cottonUncheckedUpdateInput>
  }


  /**
   * unfixed_cotton delete
   */
  export type unfixed_cottonDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
    /**
     * Filter which unfixed_cotton to delete.
     */
    where: unfixed_cottonWhereUniqueInput
  }


  /**
   * unfixed_cotton deleteMany
   */
  export type unfixed_cottonDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which unfixed_cottons to delete
     */
    where?: unfixed_cottonWhereInput
  }


  /**
   * unfixed_cotton without action
   */
  export type unfixed_cottonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unfixed_cotton
     */
    select?: unfixed_cottonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: unfixed_cottonInclude<ExtArgs> | null
  }



  /**
   * Model strategy_log
   */


  export type AggregateStrategy_log = {
    _count: Strategy_logCountAggregateOutputType | null
    _min: Strategy_logMinAggregateOutputType | null
    _max: Strategy_logMaxAggregateOutputType | null
  }

  export type Strategy_logMinAggregateOutputType = {
    record_id: string | null
    company_id: string | null
    title: string | null
    text: string | null
    added_by: string | null
    date_created: Date | null
  }

  export type Strategy_logMaxAggregateOutputType = {
    record_id: string | null
    company_id: string | null
    title: string | null
    text: string | null
    added_by: string | null
    date_created: Date | null
  }

  export type Strategy_logCountAggregateOutputType = {
    record_id: number
    company_id: number
    title: number
    text: number
    added_by: number
    date_created: number
    _all: number
  }


  export type Strategy_logMinAggregateInputType = {
    record_id?: true
    company_id?: true
    title?: true
    text?: true
    added_by?: true
    date_created?: true
  }

  export type Strategy_logMaxAggregateInputType = {
    record_id?: true
    company_id?: true
    title?: true
    text?: true
    added_by?: true
    date_created?: true
  }

  export type Strategy_logCountAggregateInputType = {
    record_id?: true
    company_id?: true
    title?: true
    text?: true
    added_by?: true
    date_created?: true
    _all?: true
  }

  export type Strategy_logAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which strategy_log to aggregate.
     */
    where?: strategy_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strategy_logs to fetch.
     */
    orderBy?: Enumerable<strategy_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: strategy_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strategy_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strategy_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned strategy_logs
    **/
    _count?: true | Strategy_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Strategy_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Strategy_logMaxAggregateInputType
  }

  export type GetStrategy_logAggregateType<T extends Strategy_logAggregateArgs> = {
        [P in keyof T & keyof AggregateStrategy_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrategy_log[P]>
      : GetScalarType<T[P], AggregateStrategy_log[P]>
  }




  export type Strategy_logGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: strategy_logWhereInput
    orderBy?: Enumerable<strategy_logOrderByWithAggregationInput>
    by: Strategy_logScalarFieldEnum[]
    having?: strategy_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Strategy_logCountAggregateInputType | true
    _min?: Strategy_logMinAggregateInputType
    _max?: Strategy_logMaxAggregateInputType
  }


  export type Strategy_logGroupByOutputType = {
    record_id: string
    company_id: string
    title: string | null
    text: string | null
    added_by: string | null
    date_created: Date
    _count: Strategy_logCountAggregateOutputType | null
    _min: Strategy_logMinAggregateOutputType | null
    _max: Strategy_logMaxAggregateOutputType | null
  }

  type GetStrategy_logGroupByPayload<T extends Strategy_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Strategy_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Strategy_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Strategy_logGroupByOutputType[P]>
            : GetScalarType<T[P], Strategy_logGroupByOutputType[P]>
        }
      >
    >


  export type strategy_logSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    company_id?: boolean
    title?: boolean
    text?: boolean
    added_by?: boolean
    date_created?: boolean
    company?: boolean | CompanyArgs<ExtArgs>
  }, ExtArgs["result"]["strategy_log"]>

  export type strategy_logSelectScalar = {
    record_id?: boolean
    company_id?: boolean
    title?: boolean
    text?: boolean
    added_by?: boolean
    date_created?: boolean
  }

  export type strategy_logInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyArgs<ExtArgs>
  }


  type strategy_logGetPayload<S extends boolean | null | undefined | strategy_logArgs> = $Types.GetResult<strategy_logPayload, S>

  type strategy_logCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<strategy_logFindManyArgs, 'select' | 'include'> & {
      select?: Strategy_logCountAggregateInputType | true
    }

  export interface strategy_logDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['strategy_log'], meta: { name: 'strategy_log' } }
    /**
     * Find zero or one Strategy_log that matches the filter.
     * @param {strategy_logFindUniqueArgs} args - Arguments to find a Strategy_log
     * @example
     * // Get one Strategy_log
     * const strategy_log = await prisma.strategy_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends strategy_logFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, strategy_logFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'strategy_log'> extends True ? Prisma__strategy_logClient<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__strategy_logClient<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Strategy_log that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {strategy_logFindUniqueOrThrowArgs} args - Arguments to find a Strategy_log
     * @example
     * // Get one Strategy_log
     * const strategy_log = await prisma.strategy_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends strategy_logFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, strategy_logFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__strategy_logClient<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Strategy_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_logFindFirstArgs} args - Arguments to find a Strategy_log
     * @example
     * // Get one Strategy_log
     * const strategy_log = await prisma.strategy_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends strategy_logFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, strategy_logFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'strategy_log'> extends True ? Prisma__strategy_logClient<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__strategy_logClient<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Strategy_log that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_logFindFirstOrThrowArgs} args - Arguments to find a Strategy_log
     * @example
     * // Get one Strategy_log
     * const strategy_log = await prisma.strategy_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends strategy_logFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, strategy_logFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__strategy_logClient<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Strategy_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_logFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Strategy_logs
     * const strategy_logs = await prisma.strategy_log.findMany()
     * 
     * // Get first 10 Strategy_logs
     * const strategy_logs = await prisma.strategy_log.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const strategy_logWithRecord_idOnly = await prisma.strategy_log.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends strategy_logFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, strategy_logFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Strategy_log.
     * @param {strategy_logCreateArgs} args - Arguments to create a Strategy_log.
     * @example
     * // Create one Strategy_log
     * const Strategy_log = await prisma.strategy_log.create({
     *   data: {
     *     // ... data to create a Strategy_log
     *   }
     * })
     * 
    **/
    create<T extends strategy_logCreateArgs<ExtArgs>>(
      args: SelectSubset<T, strategy_logCreateArgs<ExtArgs>>
    ): Prisma__strategy_logClient<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Strategy_logs.
     *     @param {strategy_logCreateManyArgs} args - Arguments to create many Strategy_logs.
     *     @example
     *     // Create many Strategy_logs
     *     const strategy_log = await prisma.strategy_log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends strategy_logCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, strategy_logCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Strategy_log.
     * @param {strategy_logDeleteArgs} args - Arguments to delete one Strategy_log.
     * @example
     * // Delete one Strategy_log
     * const Strategy_log = await prisma.strategy_log.delete({
     *   where: {
     *     // ... filter to delete one Strategy_log
     *   }
     * })
     * 
    **/
    delete<T extends strategy_logDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, strategy_logDeleteArgs<ExtArgs>>
    ): Prisma__strategy_logClient<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Strategy_log.
     * @param {strategy_logUpdateArgs} args - Arguments to update one Strategy_log.
     * @example
     * // Update one Strategy_log
     * const strategy_log = await prisma.strategy_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends strategy_logUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, strategy_logUpdateArgs<ExtArgs>>
    ): Prisma__strategy_logClient<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Strategy_logs.
     * @param {strategy_logDeleteManyArgs} args - Arguments to filter Strategy_logs to delete.
     * @example
     * // Delete a few Strategy_logs
     * const { count } = await prisma.strategy_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends strategy_logDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, strategy_logDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strategy_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Strategy_logs
     * const strategy_log = await prisma.strategy_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends strategy_logUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, strategy_logUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Strategy_log.
     * @param {strategy_logUpsertArgs} args - Arguments to update or create a Strategy_log.
     * @example
     * // Update or create a Strategy_log
     * const strategy_log = await prisma.strategy_log.upsert({
     *   create: {
     *     // ... data to create a Strategy_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Strategy_log we want to update
     *   }
     * })
    **/
    upsert<T extends strategy_logUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, strategy_logUpsertArgs<ExtArgs>>
    ): Prisma__strategy_logClient<$Types.GetResult<strategy_logPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Strategy_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {strategy_logCountArgs} args - Arguments to filter Strategy_logs to count.
     * @example
     * // Count the number of Strategy_logs
     * const count = await prisma.strategy_log.count({
     *   where: {
     *     // ... the filter for the Strategy_logs we want to count
     *   }
     * })
    **/
    count<T extends strategy_logCountArgs>(
      args?: Subset<T, strategy_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Strategy_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Strategy_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Strategy_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Strategy_logAggregateArgs>(args: Subset<T, Strategy_logAggregateArgs>): Prisma.PrismaPromise<GetStrategy_logAggregateType<T>>

    /**
     * Group by Strategy_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Strategy_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Strategy_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Strategy_logGroupByArgs['orderBy'] }
        : { orderBy?: Strategy_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Strategy_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrategy_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for strategy_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__strategy_logClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    company<T extends CompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * strategy_log base type for findUnique actions
   */
  export type strategy_logFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
    /**
     * Filter, which strategy_log to fetch.
     */
    where: strategy_logWhereUniqueInput
  }

  /**
   * strategy_log findUnique
   */
  export interface strategy_logFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends strategy_logFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * strategy_log findUniqueOrThrow
   */
  export type strategy_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
    /**
     * Filter, which strategy_log to fetch.
     */
    where: strategy_logWhereUniqueInput
  }


  /**
   * strategy_log base type for findFirst actions
   */
  export type strategy_logFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
    /**
     * Filter, which strategy_log to fetch.
     */
    where?: strategy_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strategy_logs to fetch.
     */
    orderBy?: Enumerable<strategy_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for strategy_logs.
     */
    cursor?: strategy_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strategy_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strategy_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of strategy_logs.
     */
    distinct?: Enumerable<Strategy_logScalarFieldEnum>
  }

  /**
   * strategy_log findFirst
   */
  export interface strategy_logFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends strategy_logFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * strategy_log findFirstOrThrow
   */
  export type strategy_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
    /**
     * Filter, which strategy_log to fetch.
     */
    where?: strategy_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strategy_logs to fetch.
     */
    orderBy?: Enumerable<strategy_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for strategy_logs.
     */
    cursor?: strategy_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strategy_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strategy_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of strategy_logs.
     */
    distinct?: Enumerable<Strategy_logScalarFieldEnum>
  }


  /**
   * strategy_log findMany
   */
  export type strategy_logFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
    /**
     * Filter, which strategy_logs to fetch.
     */
    where?: strategy_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of strategy_logs to fetch.
     */
    orderBy?: Enumerable<strategy_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing strategy_logs.
     */
    cursor?: strategy_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` strategy_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` strategy_logs.
     */
    skip?: number
    distinct?: Enumerable<Strategy_logScalarFieldEnum>
  }


  /**
   * strategy_log create
   */
  export type strategy_logCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
    /**
     * The data needed to create a strategy_log.
     */
    data: XOR<strategy_logCreateInput, strategy_logUncheckedCreateInput>
  }


  /**
   * strategy_log createMany
   */
  export type strategy_logCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many strategy_logs.
     */
    data: Enumerable<strategy_logCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * strategy_log update
   */
  export type strategy_logUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
    /**
     * The data needed to update a strategy_log.
     */
    data: XOR<strategy_logUpdateInput, strategy_logUncheckedUpdateInput>
    /**
     * Choose, which strategy_log to update.
     */
    where: strategy_logWhereUniqueInput
  }


  /**
   * strategy_log updateMany
   */
  export type strategy_logUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update strategy_logs.
     */
    data: XOR<strategy_logUpdateManyMutationInput, strategy_logUncheckedUpdateManyInput>
    /**
     * Filter which strategy_logs to update
     */
    where?: strategy_logWhereInput
  }


  /**
   * strategy_log upsert
   */
  export type strategy_logUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
    /**
     * The filter to search for the strategy_log to update in case it exists.
     */
    where: strategy_logWhereUniqueInput
    /**
     * In case the strategy_log found by the `where` argument doesn't exist, create a new strategy_log with this data.
     */
    create: XOR<strategy_logCreateInput, strategy_logUncheckedCreateInput>
    /**
     * In case the strategy_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<strategy_logUpdateInput, strategy_logUncheckedUpdateInput>
  }


  /**
   * strategy_log delete
   */
  export type strategy_logDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
    /**
     * Filter which strategy_log to delete.
     */
    where: strategy_logWhereUniqueInput
  }


  /**
   * strategy_log deleteMany
   */
  export type strategy_logDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which strategy_logs to delete
     */
    where?: strategy_logWhereInput
  }


  /**
   * strategy_log without action
   */
  export type strategy_logArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the strategy_log
     */
    select?: strategy_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: strategy_logInclude<ExtArgs> | null
  }



  /**
   * Model producer_production_estimates
   */


  export type AggregateProducer_production_estimates = {
    _count: Producer_production_estimatesCountAggregateOutputType | null
    _avg: Producer_production_estimatesAvgAggregateOutputType | null
    _sum: Producer_production_estimatesSumAggregateOutputType | null
    _min: Producer_production_estimatesMinAggregateOutputType | null
    _max: Producer_production_estimatesMaxAggregateOutputType | null
  }

  export type Producer_production_estimatesAvgAggregateOutputType = {
    production_estimate: Decimal | null
    yield_estimate: Decimal | null
  }

  export type Producer_production_estimatesSumAggregateOutputType = {
    production_estimate: Decimal | null
    yield_estimate: Decimal | null
  }

  export type Producer_production_estimatesMinAggregateOutputType = {
    record_id: string | null
    company_id: string | null
    season: string | null
    production_estimate: Decimal | null
    yield_estimate: Decimal | null
    added_by: string | null
    date_created: Date | null
  }

  export type Producer_production_estimatesMaxAggregateOutputType = {
    record_id: string | null
    company_id: string | null
    season: string | null
    production_estimate: Decimal | null
    yield_estimate: Decimal | null
    added_by: string | null
    date_created: Date | null
  }

  export type Producer_production_estimatesCountAggregateOutputType = {
    record_id: number
    company_id: number
    season: number
    production_estimate: number
    yield_estimate: number
    added_by: number
    date_created: number
    _all: number
  }


  export type Producer_production_estimatesAvgAggregateInputType = {
    production_estimate?: true
    yield_estimate?: true
  }

  export type Producer_production_estimatesSumAggregateInputType = {
    production_estimate?: true
    yield_estimate?: true
  }

  export type Producer_production_estimatesMinAggregateInputType = {
    record_id?: true
    company_id?: true
    season?: true
    production_estimate?: true
    yield_estimate?: true
    added_by?: true
    date_created?: true
  }

  export type Producer_production_estimatesMaxAggregateInputType = {
    record_id?: true
    company_id?: true
    season?: true
    production_estimate?: true
    yield_estimate?: true
    added_by?: true
    date_created?: true
  }

  export type Producer_production_estimatesCountAggregateInputType = {
    record_id?: true
    company_id?: true
    season?: true
    production_estimate?: true
    yield_estimate?: true
    added_by?: true
    date_created?: true
    _all?: true
  }

  export type Producer_production_estimatesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which producer_production_estimates to aggregate.
     */
    where?: producer_production_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_production_estimates to fetch.
     */
    orderBy?: Enumerable<producer_production_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: producer_production_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_production_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_production_estimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned producer_production_estimates
    **/
    _count?: true | Producer_production_estimatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Producer_production_estimatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Producer_production_estimatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Producer_production_estimatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Producer_production_estimatesMaxAggregateInputType
  }

  export type GetProducer_production_estimatesAggregateType<T extends Producer_production_estimatesAggregateArgs> = {
        [P in keyof T & keyof AggregateProducer_production_estimates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducer_production_estimates[P]>
      : GetScalarType<T[P], AggregateProducer_production_estimates[P]>
  }




  export type Producer_production_estimatesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: producer_production_estimatesWhereInput
    orderBy?: Enumerable<producer_production_estimatesOrderByWithAggregationInput>
    by: Producer_production_estimatesScalarFieldEnum[]
    having?: producer_production_estimatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Producer_production_estimatesCountAggregateInputType | true
    _avg?: Producer_production_estimatesAvgAggregateInputType
    _sum?: Producer_production_estimatesSumAggregateInputType
    _min?: Producer_production_estimatesMinAggregateInputType
    _max?: Producer_production_estimatesMaxAggregateInputType
  }


  export type Producer_production_estimatesGroupByOutputType = {
    record_id: string
    company_id: string
    season: string
    production_estimate: Decimal
    yield_estimate: Decimal
    added_by: string | null
    date_created: Date
    _count: Producer_production_estimatesCountAggregateOutputType | null
    _avg: Producer_production_estimatesAvgAggregateOutputType | null
    _sum: Producer_production_estimatesSumAggregateOutputType | null
    _min: Producer_production_estimatesMinAggregateOutputType | null
    _max: Producer_production_estimatesMaxAggregateOutputType | null
  }

  type GetProducer_production_estimatesGroupByPayload<T extends Producer_production_estimatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Producer_production_estimatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Producer_production_estimatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Producer_production_estimatesGroupByOutputType[P]>
            : GetScalarType<T[P], Producer_production_estimatesGroupByOutputType[P]>
        }
      >
    >


  export type producer_production_estimatesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    company_id?: boolean
    season?: boolean
    production_estimate?: boolean
    yield_estimate?: boolean
    added_by?: boolean
    date_created?: boolean
    company?: boolean | CompanyArgs<ExtArgs>
  }, ExtArgs["result"]["producer_production_estimates"]>

  export type producer_production_estimatesSelectScalar = {
    record_id?: boolean
    company_id?: boolean
    season?: boolean
    production_estimate?: boolean
    yield_estimate?: boolean
    added_by?: boolean
    date_created?: boolean
  }

  export type producer_production_estimatesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyArgs<ExtArgs>
  }


  type producer_production_estimatesGetPayload<S extends boolean | null | undefined | producer_production_estimatesArgs> = $Types.GetResult<producer_production_estimatesPayload, S>

  type producer_production_estimatesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<producer_production_estimatesFindManyArgs, 'select' | 'include'> & {
      select?: Producer_production_estimatesCountAggregateInputType | true
    }

  export interface producer_production_estimatesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['producer_production_estimates'], meta: { name: 'producer_production_estimates' } }
    /**
     * Find zero or one Producer_production_estimates that matches the filter.
     * @param {producer_production_estimatesFindUniqueArgs} args - Arguments to find a Producer_production_estimates
     * @example
     * // Get one Producer_production_estimates
     * const producer_production_estimates = await prisma.producer_production_estimates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends producer_production_estimatesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, producer_production_estimatesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'producer_production_estimates'> extends True ? Prisma__producer_production_estimatesClient<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__producer_production_estimatesClient<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Producer_production_estimates that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {producer_production_estimatesFindUniqueOrThrowArgs} args - Arguments to find a Producer_production_estimates
     * @example
     * // Get one Producer_production_estimates
     * const producer_production_estimates = await prisma.producer_production_estimates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends producer_production_estimatesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_production_estimatesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__producer_production_estimatesClient<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Producer_production_estimates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_production_estimatesFindFirstArgs} args - Arguments to find a Producer_production_estimates
     * @example
     * // Get one Producer_production_estimates
     * const producer_production_estimates = await prisma.producer_production_estimates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends producer_production_estimatesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, producer_production_estimatesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'producer_production_estimates'> extends True ? Prisma__producer_production_estimatesClient<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__producer_production_estimatesClient<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Producer_production_estimates that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_production_estimatesFindFirstOrThrowArgs} args - Arguments to find a Producer_production_estimates
     * @example
     * // Get one Producer_production_estimates
     * const producer_production_estimates = await prisma.producer_production_estimates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends producer_production_estimatesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_production_estimatesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__producer_production_estimatesClient<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Producer_production_estimates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_production_estimatesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Producer_production_estimates
     * const producer_production_estimates = await prisma.producer_production_estimates.findMany()
     * 
     * // Get first 10 Producer_production_estimates
     * const producer_production_estimates = await prisma.producer_production_estimates.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const producer_production_estimatesWithRecord_idOnly = await prisma.producer_production_estimates.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends producer_production_estimatesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_production_estimatesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Producer_production_estimates.
     * @param {producer_production_estimatesCreateArgs} args - Arguments to create a Producer_production_estimates.
     * @example
     * // Create one Producer_production_estimates
     * const Producer_production_estimates = await prisma.producer_production_estimates.create({
     *   data: {
     *     // ... data to create a Producer_production_estimates
     *   }
     * })
     * 
    **/
    create<T extends producer_production_estimatesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, producer_production_estimatesCreateArgs<ExtArgs>>
    ): Prisma__producer_production_estimatesClient<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Producer_production_estimates.
     *     @param {producer_production_estimatesCreateManyArgs} args - Arguments to create many Producer_production_estimates.
     *     @example
     *     // Create many Producer_production_estimates
     *     const producer_production_estimates = await prisma.producer_production_estimates.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends producer_production_estimatesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_production_estimatesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Producer_production_estimates.
     * @param {producer_production_estimatesDeleteArgs} args - Arguments to delete one Producer_production_estimates.
     * @example
     * // Delete one Producer_production_estimates
     * const Producer_production_estimates = await prisma.producer_production_estimates.delete({
     *   where: {
     *     // ... filter to delete one Producer_production_estimates
     *   }
     * })
     * 
    **/
    delete<T extends producer_production_estimatesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, producer_production_estimatesDeleteArgs<ExtArgs>>
    ): Prisma__producer_production_estimatesClient<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Producer_production_estimates.
     * @param {producer_production_estimatesUpdateArgs} args - Arguments to update one Producer_production_estimates.
     * @example
     * // Update one Producer_production_estimates
     * const producer_production_estimates = await prisma.producer_production_estimates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends producer_production_estimatesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, producer_production_estimatesUpdateArgs<ExtArgs>>
    ): Prisma__producer_production_estimatesClient<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Producer_production_estimates.
     * @param {producer_production_estimatesDeleteManyArgs} args - Arguments to filter Producer_production_estimates to delete.
     * @example
     * // Delete a few Producer_production_estimates
     * const { count } = await prisma.producer_production_estimates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends producer_production_estimatesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_production_estimatesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Producer_production_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_production_estimatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Producer_production_estimates
     * const producer_production_estimates = await prisma.producer_production_estimates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends producer_production_estimatesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, producer_production_estimatesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Producer_production_estimates.
     * @param {producer_production_estimatesUpsertArgs} args - Arguments to update or create a Producer_production_estimates.
     * @example
     * // Update or create a Producer_production_estimates
     * const producer_production_estimates = await prisma.producer_production_estimates.upsert({
     *   create: {
     *     // ... data to create a Producer_production_estimates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producer_production_estimates we want to update
     *   }
     * })
    **/
    upsert<T extends producer_production_estimatesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, producer_production_estimatesUpsertArgs<ExtArgs>>
    ): Prisma__producer_production_estimatesClient<$Types.GetResult<producer_production_estimatesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Producer_production_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_production_estimatesCountArgs} args - Arguments to filter Producer_production_estimates to count.
     * @example
     * // Count the number of Producer_production_estimates
     * const count = await prisma.producer_production_estimates.count({
     *   where: {
     *     // ... the filter for the Producer_production_estimates we want to count
     *   }
     * })
    **/
    count<T extends producer_production_estimatesCountArgs>(
      args?: Subset<T, producer_production_estimatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Producer_production_estimatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producer_production_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Producer_production_estimatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Producer_production_estimatesAggregateArgs>(args: Subset<T, Producer_production_estimatesAggregateArgs>): Prisma.PrismaPromise<GetProducer_production_estimatesAggregateType<T>>

    /**
     * Group by Producer_production_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Producer_production_estimatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Producer_production_estimatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Producer_production_estimatesGroupByArgs['orderBy'] }
        : { orderBy?: Producer_production_estimatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Producer_production_estimatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProducer_production_estimatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for producer_production_estimates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__producer_production_estimatesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    company<T extends CompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * producer_production_estimates base type for findUnique actions
   */
  export type producer_production_estimatesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_production_estimates to fetch.
     */
    where: producer_production_estimatesWhereUniqueInput
  }

  /**
   * producer_production_estimates findUnique
   */
  export interface producer_production_estimatesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends producer_production_estimatesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * producer_production_estimates findUniqueOrThrow
   */
  export type producer_production_estimatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_production_estimates to fetch.
     */
    where: producer_production_estimatesWhereUniqueInput
  }


  /**
   * producer_production_estimates base type for findFirst actions
   */
  export type producer_production_estimatesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_production_estimates to fetch.
     */
    where?: producer_production_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_production_estimates to fetch.
     */
    orderBy?: Enumerable<producer_production_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for producer_production_estimates.
     */
    cursor?: producer_production_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_production_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_production_estimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of producer_production_estimates.
     */
    distinct?: Enumerable<Producer_production_estimatesScalarFieldEnum>
  }

  /**
   * producer_production_estimates findFirst
   */
  export interface producer_production_estimatesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends producer_production_estimatesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * producer_production_estimates findFirstOrThrow
   */
  export type producer_production_estimatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_production_estimates to fetch.
     */
    where?: producer_production_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_production_estimates to fetch.
     */
    orderBy?: Enumerable<producer_production_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for producer_production_estimates.
     */
    cursor?: producer_production_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_production_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_production_estimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of producer_production_estimates.
     */
    distinct?: Enumerable<Producer_production_estimatesScalarFieldEnum>
  }


  /**
   * producer_production_estimates findMany
   */
  export type producer_production_estimatesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_production_estimates to fetch.
     */
    where?: producer_production_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_production_estimates to fetch.
     */
    orderBy?: Enumerable<producer_production_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing producer_production_estimates.
     */
    cursor?: producer_production_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_production_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_production_estimates.
     */
    skip?: number
    distinct?: Enumerable<Producer_production_estimatesScalarFieldEnum>
  }


  /**
   * producer_production_estimates create
   */
  export type producer_production_estimatesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
    /**
     * The data needed to create a producer_production_estimates.
     */
    data: XOR<producer_production_estimatesCreateInput, producer_production_estimatesUncheckedCreateInput>
  }


  /**
   * producer_production_estimates createMany
   */
  export type producer_production_estimatesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many producer_production_estimates.
     */
    data: Enumerable<producer_production_estimatesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * producer_production_estimates update
   */
  export type producer_production_estimatesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
    /**
     * The data needed to update a producer_production_estimates.
     */
    data: XOR<producer_production_estimatesUpdateInput, producer_production_estimatesUncheckedUpdateInput>
    /**
     * Choose, which producer_production_estimates to update.
     */
    where: producer_production_estimatesWhereUniqueInput
  }


  /**
   * producer_production_estimates updateMany
   */
  export type producer_production_estimatesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update producer_production_estimates.
     */
    data: XOR<producer_production_estimatesUpdateManyMutationInput, producer_production_estimatesUncheckedUpdateManyInput>
    /**
     * Filter which producer_production_estimates to update
     */
    where?: producer_production_estimatesWhereInput
  }


  /**
   * producer_production_estimates upsert
   */
  export type producer_production_estimatesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
    /**
     * The filter to search for the producer_production_estimates to update in case it exists.
     */
    where: producer_production_estimatesWhereUniqueInput
    /**
     * In case the producer_production_estimates found by the `where` argument doesn't exist, create a new producer_production_estimates with this data.
     */
    create: XOR<producer_production_estimatesCreateInput, producer_production_estimatesUncheckedCreateInput>
    /**
     * In case the producer_production_estimates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<producer_production_estimatesUpdateInput, producer_production_estimatesUncheckedUpdateInput>
  }


  /**
   * producer_production_estimates delete
   */
  export type producer_production_estimatesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
    /**
     * Filter which producer_production_estimates to delete.
     */
    where: producer_production_estimatesWhereUniqueInput
  }


  /**
   * producer_production_estimates deleteMany
   */
  export type producer_production_estimatesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which producer_production_estimates to delete
     */
    where?: producer_production_estimatesWhereInput
  }


  /**
   * producer_production_estimates without action
   */
  export type producer_production_estimatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_production_estimates
     */
    select?: producer_production_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_production_estimatesInclude<ExtArgs> | null
  }



  /**
   * Model producer_cost_estimates
   */


  export type AggregateProducer_cost_estimates = {
    _count: Producer_cost_estimatesCountAggregateOutputType | null
    _avg: Producer_cost_estimatesAvgAggregateOutputType | null
    _sum: Producer_cost_estimatesSumAggregateOutputType | null
    _min: Producer_cost_estimatesMinAggregateOutputType | null
    _max: Producer_cost_estimatesMaxAggregateOutputType | null
  }

  export type Producer_cost_estimatesAvgAggregateOutputType = {
    cost_estimate_dollar_per_hectare: Decimal | null
    cost_estimate_cent_per_pound: Decimal | null
  }

  export type Producer_cost_estimatesSumAggregateOutputType = {
    cost_estimate_dollar_per_hectare: Decimal | null
    cost_estimate_cent_per_pound: Decimal | null
  }

  export type Producer_cost_estimatesMinAggregateOutputType = {
    record_id: string | null
    company_id: string | null
    season: string | null
    cost_estimate_dollar_per_hectare: Decimal | null
    cost_estimate_cent_per_pound: Decimal | null
    added_by: string | null
    date_created: Date | null
  }

  export type Producer_cost_estimatesMaxAggregateOutputType = {
    record_id: string | null
    company_id: string | null
    season: string | null
    cost_estimate_dollar_per_hectare: Decimal | null
    cost_estimate_cent_per_pound: Decimal | null
    added_by: string | null
    date_created: Date | null
  }

  export type Producer_cost_estimatesCountAggregateOutputType = {
    record_id: number
    company_id: number
    season: number
    cost_estimate_dollar_per_hectare: number
    cost_estimate_cent_per_pound: number
    added_by: number
    date_created: number
    _all: number
  }


  export type Producer_cost_estimatesAvgAggregateInputType = {
    cost_estimate_dollar_per_hectare?: true
    cost_estimate_cent_per_pound?: true
  }

  export type Producer_cost_estimatesSumAggregateInputType = {
    cost_estimate_dollar_per_hectare?: true
    cost_estimate_cent_per_pound?: true
  }

  export type Producer_cost_estimatesMinAggregateInputType = {
    record_id?: true
    company_id?: true
    season?: true
    cost_estimate_dollar_per_hectare?: true
    cost_estimate_cent_per_pound?: true
    added_by?: true
    date_created?: true
  }

  export type Producer_cost_estimatesMaxAggregateInputType = {
    record_id?: true
    company_id?: true
    season?: true
    cost_estimate_dollar_per_hectare?: true
    cost_estimate_cent_per_pound?: true
    added_by?: true
    date_created?: true
  }

  export type Producer_cost_estimatesCountAggregateInputType = {
    record_id?: true
    company_id?: true
    season?: true
    cost_estimate_dollar_per_hectare?: true
    cost_estimate_cent_per_pound?: true
    added_by?: true
    date_created?: true
    _all?: true
  }

  export type Producer_cost_estimatesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which producer_cost_estimates to aggregate.
     */
    where?: producer_cost_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_cost_estimates to fetch.
     */
    orderBy?: Enumerable<producer_cost_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: producer_cost_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_cost_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_cost_estimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned producer_cost_estimates
    **/
    _count?: true | Producer_cost_estimatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Producer_cost_estimatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Producer_cost_estimatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Producer_cost_estimatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Producer_cost_estimatesMaxAggregateInputType
  }

  export type GetProducer_cost_estimatesAggregateType<T extends Producer_cost_estimatesAggregateArgs> = {
        [P in keyof T & keyof AggregateProducer_cost_estimates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducer_cost_estimates[P]>
      : GetScalarType<T[P], AggregateProducer_cost_estimates[P]>
  }




  export type Producer_cost_estimatesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: producer_cost_estimatesWhereInput
    orderBy?: Enumerable<producer_cost_estimatesOrderByWithAggregationInput>
    by: Producer_cost_estimatesScalarFieldEnum[]
    having?: producer_cost_estimatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Producer_cost_estimatesCountAggregateInputType | true
    _avg?: Producer_cost_estimatesAvgAggregateInputType
    _sum?: Producer_cost_estimatesSumAggregateInputType
    _min?: Producer_cost_estimatesMinAggregateInputType
    _max?: Producer_cost_estimatesMaxAggregateInputType
  }


  export type Producer_cost_estimatesGroupByOutputType = {
    record_id: string
    company_id: string
    season: string
    cost_estimate_dollar_per_hectare: Decimal
    cost_estimate_cent_per_pound: Decimal
    added_by: string | null
    date_created: Date
    _count: Producer_cost_estimatesCountAggregateOutputType | null
    _avg: Producer_cost_estimatesAvgAggregateOutputType | null
    _sum: Producer_cost_estimatesSumAggregateOutputType | null
    _min: Producer_cost_estimatesMinAggregateOutputType | null
    _max: Producer_cost_estimatesMaxAggregateOutputType | null
  }

  type GetProducer_cost_estimatesGroupByPayload<T extends Producer_cost_estimatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Producer_cost_estimatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Producer_cost_estimatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Producer_cost_estimatesGroupByOutputType[P]>
            : GetScalarType<T[P], Producer_cost_estimatesGroupByOutputType[P]>
        }
      >
    >


  export type producer_cost_estimatesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    company_id?: boolean
    season?: boolean
    cost_estimate_dollar_per_hectare?: boolean
    cost_estimate_cent_per_pound?: boolean
    added_by?: boolean
    date_created?: boolean
    company?: boolean | CompanyArgs<ExtArgs>
  }, ExtArgs["result"]["producer_cost_estimates"]>

  export type producer_cost_estimatesSelectScalar = {
    record_id?: boolean
    company_id?: boolean
    season?: boolean
    cost_estimate_dollar_per_hectare?: boolean
    cost_estimate_cent_per_pound?: boolean
    added_by?: boolean
    date_created?: boolean
  }

  export type producer_cost_estimatesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyArgs<ExtArgs>
  }


  type producer_cost_estimatesGetPayload<S extends boolean | null | undefined | producer_cost_estimatesArgs> = $Types.GetResult<producer_cost_estimatesPayload, S>

  type producer_cost_estimatesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<producer_cost_estimatesFindManyArgs, 'select' | 'include'> & {
      select?: Producer_cost_estimatesCountAggregateInputType | true
    }

  export interface producer_cost_estimatesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['producer_cost_estimates'], meta: { name: 'producer_cost_estimates' } }
    /**
     * Find zero or one Producer_cost_estimates that matches the filter.
     * @param {producer_cost_estimatesFindUniqueArgs} args - Arguments to find a Producer_cost_estimates
     * @example
     * // Get one Producer_cost_estimates
     * const producer_cost_estimates = await prisma.producer_cost_estimates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends producer_cost_estimatesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, producer_cost_estimatesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'producer_cost_estimates'> extends True ? Prisma__producer_cost_estimatesClient<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__producer_cost_estimatesClient<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Producer_cost_estimates that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {producer_cost_estimatesFindUniqueOrThrowArgs} args - Arguments to find a Producer_cost_estimates
     * @example
     * // Get one Producer_cost_estimates
     * const producer_cost_estimates = await prisma.producer_cost_estimates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends producer_cost_estimatesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_cost_estimatesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__producer_cost_estimatesClient<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Producer_cost_estimates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_cost_estimatesFindFirstArgs} args - Arguments to find a Producer_cost_estimates
     * @example
     * // Get one Producer_cost_estimates
     * const producer_cost_estimates = await prisma.producer_cost_estimates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends producer_cost_estimatesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, producer_cost_estimatesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'producer_cost_estimates'> extends True ? Prisma__producer_cost_estimatesClient<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__producer_cost_estimatesClient<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Producer_cost_estimates that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_cost_estimatesFindFirstOrThrowArgs} args - Arguments to find a Producer_cost_estimates
     * @example
     * // Get one Producer_cost_estimates
     * const producer_cost_estimates = await prisma.producer_cost_estimates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends producer_cost_estimatesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_cost_estimatesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__producer_cost_estimatesClient<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Producer_cost_estimates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_cost_estimatesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Producer_cost_estimates
     * const producer_cost_estimates = await prisma.producer_cost_estimates.findMany()
     * 
     * // Get first 10 Producer_cost_estimates
     * const producer_cost_estimates = await prisma.producer_cost_estimates.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const producer_cost_estimatesWithRecord_idOnly = await prisma.producer_cost_estimates.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends producer_cost_estimatesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_cost_estimatesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Producer_cost_estimates.
     * @param {producer_cost_estimatesCreateArgs} args - Arguments to create a Producer_cost_estimates.
     * @example
     * // Create one Producer_cost_estimates
     * const Producer_cost_estimates = await prisma.producer_cost_estimates.create({
     *   data: {
     *     // ... data to create a Producer_cost_estimates
     *   }
     * })
     * 
    **/
    create<T extends producer_cost_estimatesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, producer_cost_estimatesCreateArgs<ExtArgs>>
    ): Prisma__producer_cost_estimatesClient<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Producer_cost_estimates.
     *     @param {producer_cost_estimatesCreateManyArgs} args - Arguments to create many Producer_cost_estimates.
     *     @example
     *     // Create many Producer_cost_estimates
     *     const producer_cost_estimates = await prisma.producer_cost_estimates.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends producer_cost_estimatesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_cost_estimatesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Producer_cost_estimates.
     * @param {producer_cost_estimatesDeleteArgs} args - Arguments to delete one Producer_cost_estimates.
     * @example
     * // Delete one Producer_cost_estimates
     * const Producer_cost_estimates = await prisma.producer_cost_estimates.delete({
     *   where: {
     *     // ... filter to delete one Producer_cost_estimates
     *   }
     * })
     * 
    **/
    delete<T extends producer_cost_estimatesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, producer_cost_estimatesDeleteArgs<ExtArgs>>
    ): Prisma__producer_cost_estimatesClient<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Producer_cost_estimates.
     * @param {producer_cost_estimatesUpdateArgs} args - Arguments to update one Producer_cost_estimates.
     * @example
     * // Update one Producer_cost_estimates
     * const producer_cost_estimates = await prisma.producer_cost_estimates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends producer_cost_estimatesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, producer_cost_estimatesUpdateArgs<ExtArgs>>
    ): Prisma__producer_cost_estimatesClient<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Producer_cost_estimates.
     * @param {producer_cost_estimatesDeleteManyArgs} args - Arguments to filter Producer_cost_estimates to delete.
     * @example
     * // Delete a few Producer_cost_estimates
     * const { count } = await prisma.producer_cost_estimates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends producer_cost_estimatesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_cost_estimatesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Producer_cost_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_cost_estimatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Producer_cost_estimates
     * const producer_cost_estimates = await prisma.producer_cost_estimates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends producer_cost_estimatesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, producer_cost_estimatesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Producer_cost_estimates.
     * @param {producer_cost_estimatesUpsertArgs} args - Arguments to update or create a Producer_cost_estimates.
     * @example
     * // Update or create a Producer_cost_estimates
     * const producer_cost_estimates = await prisma.producer_cost_estimates.upsert({
     *   create: {
     *     // ... data to create a Producer_cost_estimates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producer_cost_estimates we want to update
     *   }
     * })
    **/
    upsert<T extends producer_cost_estimatesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, producer_cost_estimatesUpsertArgs<ExtArgs>>
    ): Prisma__producer_cost_estimatesClient<$Types.GetResult<producer_cost_estimatesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Producer_cost_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_cost_estimatesCountArgs} args - Arguments to filter Producer_cost_estimates to count.
     * @example
     * // Count the number of Producer_cost_estimates
     * const count = await prisma.producer_cost_estimates.count({
     *   where: {
     *     // ... the filter for the Producer_cost_estimates we want to count
     *   }
     * })
    **/
    count<T extends producer_cost_estimatesCountArgs>(
      args?: Subset<T, producer_cost_estimatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Producer_cost_estimatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producer_cost_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Producer_cost_estimatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Producer_cost_estimatesAggregateArgs>(args: Subset<T, Producer_cost_estimatesAggregateArgs>): Prisma.PrismaPromise<GetProducer_cost_estimatesAggregateType<T>>

    /**
     * Group by Producer_cost_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Producer_cost_estimatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Producer_cost_estimatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Producer_cost_estimatesGroupByArgs['orderBy'] }
        : { orderBy?: Producer_cost_estimatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Producer_cost_estimatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProducer_cost_estimatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for producer_cost_estimates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__producer_cost_estimatesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    company<T extends CompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * producer_cost_estimates base type for findUnique actions
   */
  export type producer_cost_estimatesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_cost_estimates to fetch.
     */
    where: producer_cost_estimatesWhereUniqueInput
  }

  /**
   * producer_cost_estimates findUnique
   */
  export interface producer_cost_estimatesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends producer_cost_estimatesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * producer_cost_estimates findUniqueOrThrow
   */
  export type producer_cost_estimatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_cost_estimates to fetch.
     */
    where: producer_cost_estimatesWhereUniqueInput
  }


  /**
   * producer_cost_estimates base type for findFirst actions
   */
  export type producer_cost_estimatesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_cost_estimates to fetch.
     */
    where?: producer_cost_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_cost_estimates to fetch.
     */
    orderBy?: Enumerable<producer_cost_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for producer_cost_estimates.
     */
    cursor?: producer_cost_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_cost_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_cost_estimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of producer_cost_estimates.
     */
    distinct?: Enumerable<Producer_cost_estimatesScalarFieldEnum>
  }

  /**
   * producer_cost_estimates findFirst
   */
  export interface producer_cost_estimatesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends producer_cost_estimatesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * producer_cost_estimates findFirstOrThrow
   */
  export type producer_cost_estimatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_cost_estimates to fetch.
     */
    where?: producer_cost_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_cost_estimates to fetch.
     */
    orderBy?: Enumerable<producer_cost_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for producer_cost_estimates.
     */
    cursor?: producer_cost_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_cost_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_cost_estimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of producer_cost_estimates.
     */
    distinct?: Enumerable<Producer_cost_estimatesScalarFieldEnum>
  }


  /**
   * producer_cost_estimates findMany
   */
  export type producer_cost_estimatesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_cost_estimates to fetch.
     */
    where?: producer_cost_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_cost_estimates to fetch.
     */
    orderBy?: Enumerable<producer_cost_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing producer_cost_estimates.
     */
    cursor?: producer_cost_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_cost_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_cost_estimates.
     */
    skip?: number
    distinct?: Enumerable<Producer_cost_estimatesScalarFieldEnum>
  }


  /**
   * producer_cost_estimates create
   */
  export type producer_cost_estimatesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
    /**
     * The data needed to create a producer_cost_estimates.
     */
    data: XOR<producer_cost_estimatesCreateInput, producer_cost_estimatesUncheckedCreateInput>
  }


  /**
   * producer_cost_estimates createMany
   */
  export type producer_cost_estimatesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many producer_cost_estimates.
     */
    data: Enumerable<producer_cost_estimatesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * producer_cost_estimates update
   */
  export type producer_cost_estimatesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
    /**
     * The data needed to update a producer_cost_estimates.
     */
    data: XOR<producer_cost_estimatesUpdateInput, producer_cost_estimatesUncheckedUpdateInput>
    /**
     * Choose, which producer_cost_estimates to update.
     */
    where: producer_cost_estimatesWhereUniqueInput
  }


  /**
   * producer_cost_estimates updateMany
   */
  export type producer_cost_estimatesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update producer_cost_estimates.
     */
    data: XOR<producer_cost_estimatesUpdateManyMutationInput, producer_cost_estimatesUncheckedUpdateManyInput>
    /**
     * Filter which producer_cost_estimates to update
     */
    where?: producer_cost_estimatesWhereInput
  }


  /**
   * producer_cost_estimates upsert
   */
  export type producer_cost_estimatesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
    /**
     * The filter to search for the producer_cost_estimates to update in case it exists.
     */
    where: producer_cost_estimatesWhereUniqueInput
    /**
     * In case the producer_cost_estimates found by the `where` argument doesn't exist, create a new producer_cost_estimates with this data.
     */
    create: XOR<producer_cost_estimatesCreateInput, producer_cost_estimatesUncheckedCreateInput>
    /**
     * In case the producer_cost_estimates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<producer_cost_estimatesUpdateInput, producer_cost_estimatesUncheckedUpdateInput>
  }


  /**
   * producer_cost_estimates delete
   */
  export type producer_cost_estimatesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
    /**
     * Filter which producer_cost_estimates to delete.
     */
    where: producer_cost_estimatesWhereUniqueInput
  }


  /**
   * producer_cost_estimates deleteMany
   */
  export type producer_cost_estimatesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which producer_cost_estimates to delete
     */
    where?: producer_cost_estimatesWhereInput
  }


  /**
   * producer_cost_estimates without action
   */
  export type producer_cost_estimatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_cost_estimates
     */
    select?: producer_cost_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_cost_estimatesInclude<ExtArgs> | null
  }



  /**
   * Model producer_commercialisation_estimates
   */


  export type AggregateProducer_commercialisation_estimates = {
    _count: Producer_commercialisation_estimatesCountAggregateOutputType | null
    _avg: Producer_commercialisation_estimatesAvgAggregateOutputType | null
    _sum: Producer_commercialisation_estimatesSumAggregateOutputType | null
    _min: Producer_commercialisation_estimatesMinAggregateOutputType | null
    _max: Producer_commercialisation_estimatesMaxAggregateOutputType | null
  }

  export type Producer_commercialisation_estimatesAvgAggregateOutputType = {
    percentage_sold: Decimal | null
  }

  export type Producer_commercialisation_estimatesSumAggregateOutputType = {
    percentage_sold: Decimal | null
  }

  export type Producer_commercialisation_estimatesMinAggregateOutputType = {
    record_id: string | null
    company_id: string | null
    season: string | null
    percentage_sold: Decimal | null
    added_by: string | null
    date_created: Date | null
  }

  export type Producer_commercialisation_estimatesMaxAggregateOutputType = {
    record_id: string | null
    company_id: string | null
    season: string | null
    percentage_sold: Decimal | null
    added_by: string | null
    date_created: Date | null
  }

  export type Producer_commercialisation_estimatesCountAggregateOutputType = {
    record_id: number
    company_id: number
    season: number
    percentage_sold: number
    added_by: number
    date_created: number
    _all: number
  }


  export type Producer_commercialisation_estimatesAvgAggregateInputType = {
    percentage_sold?: true
  }

  export type Producer_commercialisation_estimatesSumAggregateInputType = {
    percentage_sold?: true
  }

  export type Producer_commercialisation_estimatesMinAggregateInputType = {
    record_id?: true
    company_id?: true
    season?: true
    percentage_sold?: true
    added_by?: true
    date_created?: true
  }

  export type Producer_commercialisation_estimatesMaxAggregateInputType = {
    record_id?: true
    company_id?: true
    season?: true
    percentage_sold?: true
    added_by?: true
    date_created?: true
  }

  export type Producer_commercialisation_estimatesCountAggregateInputType = {
    record_id?: true
    company_id?: true
    season?: true
    percentage_sold?: true
    added_by?: true
    date_created?: true
    _all?: true
  }

  export type Producer_commercialisation_estimatesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which producer_commercialisation_estimates to aggregate.
     */
    where?: producer_commercialisation_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_commercialisation_estimates to fetch.
     */
    orderBy?: Enumerable<producer_commercialisation_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: producer_commercialisation_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_commercialisation_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_commercialisation_estimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned producer_commercialisation_estimates
    **/
    _count?: true | Producer_commercialisation_estimatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Producer_commercialisation_estimatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Producer_commercialisation_estimatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Producer_commercialisation_estimatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Producer_commercialisation_estimatesMaxAggregateInputType
  }

  export type GetProducer_commercialisation_estimatesAggregateType<T extends Producer_commercialisation_estimatesAggregateArgs> = {
        [P in keyof T & keyof AggregateProducer_commercialisation_estimates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducer_commercialisation_estimates[P]>
      : GetScalarType<T[P], AggregateProducer_commercialisation_estimates[P]>
  }




  export type Producer_commercialisation_estimatesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: producer_commercialisation_estimatesWhereInput
    orderBy?: Enumerable<producer_commercialisation_estimatesOrderByWithAggregationInput>
    by: Producer_commercialisation_estimatesScalarFieldEnum[]
    having?: producer_commercialisation_estimatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Producer_commercialisation_estimatesCountAggregateInputType | true
    _avg?: Producer_commercialisation_estimatesAvgAggregateInputType
    _sum?: Producer_commercialisation_estimatesSumAggregateInputType
    _min?: Producer_commercialisation_estimatesMinAggregateInputType
    _max?: Producer_commercialisation_estimatesMaxAggregateInputType
  }


  export type Producer_commercialisation_estimatesGroupByOutputType = {
    record_id: string
    company_id: string
    season: string
    percentage_sold: Decimal
    added_by: string | null
    date_created: Date
    _count: Producer_commercialisation_estimatesCountAggregateOutputType | null
    _avg: Producer_commercialisation_estimatesAvgAggregateOutputType | null
    _sum: Producer_commercialisation_estimatesSumAggregateOutputType | null
    _min: Producer_commercialisation_estimatesMinAggregateOutputType | null
    _max: Producer_commercialisation_estimatesMaxAggregateOutputType | null
  }

  type GetProducer_commercialisation_estimatesGroupByPayload<T extends Producer_commercialisation_estimatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Producer_commercialisation_estimatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Producer_commercialisation_estimatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Producer_commercialisation_estimatesGroupByOutputType[P]>
            : GetScalarType<T[P], Producer_commercialisation_estimatesGroupByOutputType[P]>
        }
      >
    >


  export type producer_commercialisation_estimatesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    company_id?: boolean
    season?: boolean
    percentage_sold?: boolean
    added_by?: boolean
    date_created?: boolean
    company?: boolean | CompanyArgs<ExtArgs>
  }, ExtArgs["result"]["producer_commercialisation_estimates"]>

  export type producer_commercialisation_estimatesSelectScalar = {
    record_id?: boolean
    company_id?: boolean
    season?: boolean
    percentage_sold?: boolean
    added_by?: boolean
    date_created?: boolean
  }

  export type producer_commercialisation_estimatesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyArgs<ExtArgs>
  }


  type producer_commercialisation_estimatesGetPayload<S extends boolean | null | undefined | producer_commercialisation_estimatesArgs> = $Types.GetResult<producer_commercialisation_estimatesPayload, S>

  type producer_commercialisation_estimatesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<producer_commercialisation_estimatesFindManyArgs, 'select' | 'include'> & {
      select?: Producer_commercialisation_estimatesCountAggregateInputType | true
    }

  export interface producer_commercialisation_estimatesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['producer_commercialisation_estimates'], meta: { name: 'producer_commercialisation_estimates' } }
    /**
     * Find zero or one Producer_commercialisation_estimates that matches the filter.
     * @param {producer_commercialisation_estimatesFindUniqueArgs} args - Arguments to find a Producer_commercialisation_estimates
     * @example
     * // Get one Producer_commercialisation_estimates
     * const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends producer_commercialisation_estimatesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, producer_commercialisation_estimatesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'producer_commercialisation_estimates'> extends True ? Prisma__producer_commercialisation_estimatesClient<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__producer_commercialisation_estimatesClient<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Producer_commercialisation_estimates that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {producer_commercialisation_estimatesFindUniqueOrThrowArgs} args - Arguments to find a Producer_commercialisation_estimates
     * @example
     * // Get one Producer_commercialisation_estimates
     * const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends producer_commercialisation_estimatesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_commercialisation_estimatesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__producer_commercialisation_estimatesClient<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Producer_commercialisation_estimates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_commercialisation_estimatesFindFirstArgs} args - Arguments to find a Producer_commercialisation_estimates
     * @example
     * // Get one Producer_commercialisation_estimates
     * const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends producer_commercialisation_estimatesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, producer_commercialisation_estimatesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'producer_commercialisation_estimates'> extends True ? Prisma__producer_commercialisation_estimatesClient<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__producer_commercialisation_estimatesClient<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Producer_commercialisation_estimates that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_commercialisation_estimatesFindFirstOrThrowArgs} args - Arguments to find a Producer_commercialisation_estimates
     * @example
     * // Get one Producer_commercialisation_estimates
     * const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends producer_commercialisation_estimatesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_commercialisation_estimatesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__producer_commercialisation_estimatesClient<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Producer_commercialisation_estimates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_commercialisation_estimatesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Producer_commercialisation_estimates
     * const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.findMany()
     * 
     * // Get first 10 Producer_commercialisation_estimates
     * const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const producer_commercialisation_estimatesWithRecord_idOnly = await prisma.producer_commercialisation_estimates.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends producer_commercialisation_estimatesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_commercialisation_estimatesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Producer_commercialisation_estimates.
     * @param {producer_commercialisation_estimatesCreateArgs} args - Arguments to create a Producer_commercialisation_estimates.
     * @example
     * // Create one Producer_commercialisation_estimates
     * const Producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.create({
     *   data: {
     *     // ... data to create a Producer_commercialisation_estimates
     *   }
     * })
     * 
    **/
    create<T extends producer_commercialisation_estimatesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, producer_commercialisation_estimatesCreateArgs<ExtArgs>>
    ): Prisma__producer_commercialisation_estimatesClient<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Producer_commercialisation_estimates.
     *     @param {producer_commercialisation_estimatesCreateManyArgs} args - Arguments to create many Producer_commercialisation_estimates.
     *     @example
     *     // Create many Producer_commercialisation_estimates
     *     const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends producer_commercialisation_estimatesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_commercialisation_estimatesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Producer_commercialisation_estimates.
     * @param {producer_commercialisation_estimatesDeleteArgs} args - Arguments to delete one Producer_commercialisation_estimates.
     * @example
     * // Delete one Producer_commercialisation_estimates
     * const Producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.delete({
     *   where: {
     *     // ... filter to delete one Producer_commercialisation_estimates
     *   }
     * })
     * 
    **/
    delete<T extends producer_commercialisation_estimatesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, producer_commercialisation_estimatesDeleteArgs<ExtArgs>>
    ): Prisma__producer_commercialisation_estimatesClient<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Producer_commercialisation_estimates.
     * @param {producer_commercialisation_estimatesUpdateArgs} args - Arguments to update one Producer_commercialisation_estimates.
     * @example
     * // Update one Producer_commercialisation_estimates
     * const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends producer_commercialisation_estimatesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, producer_commercialisation_estimatesUpdateArgs<ExtArgs>>
    ): Prisma__producer_commercialisation_estimatesClient<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Producer_commercialisation_estimates.
     * @param {producer_commercialisation_estimatesDeleteManyArgs} args - Arguments to filter Producer_commercialisation_estimates to delete.
     * @example
     * // Delete a few Producer_commercialisation_estimates
     * const { count } = await prisma.producer_commercialisation_estimates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends producer_commercialisation_estimatesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, producer_commercialisation_estimatesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Producer_commercialisation_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_commercialisation_estimatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Producer_commercialisation_estimates
     * const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends producer_commercialisation_estimatesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, producer_commercialisation_estimatesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Producer_commercialisation_estimates.
     * @param {producer_commercialisation_estimatesUpsertArgs} args - Arguments to update or create a Producer_commercialisation_estimates.
     * @example
     * // Update or create a Producer_commercialisation_estimates
     * const producer_commercialisation_estimates = await prisma.producer_commercialisation_estimates.upsert({
     *   create: {
     *     // ... data to create a Producer_commercialisation_estimates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producer_commercialisation_estimates we want to update
     *   }
     * })
    **/
    upsert<T extends producer_commercialisation_estimatesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, producer_commercialisation_estimatesUpsertArgs<ExtArgs>>
    ): Prisma__producer_commercialisation_estimatesClient<$Types.GetResult<producer_commercialisation_estimatesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Producer_commercialisation_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {producer_commercialisation_estimatesCountArgs} args - Arguments to filter Producer_commercialisation_estimates to count.
     * @example
     * // Count the number of Producer_commercialisation_estimates
     * const count = await prisma.producer_commercialisation_estimates.count({
     *   where: {
     *     // ... the filter for the Producer_commercialisation_estimates we want to count
     *   }
     * })
    **/
    count<T extends producer_commercialisation_estimatesCountArgs>(
      args?: Subset<T, producer_commercialisation_estimatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Producer_commercialisation_estimatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producer_commercialisation_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Producer_commercialisation_estimatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Producer_commercialisation_estimatesAggregateArgs>(args: Subset<T, Producer_commercialisation_estimatesAggregateArgs>): Prisma.PrismaPromise<GetProducer_commercialisation_estimatesAggregateType<T>>

    /**
     * Group by Producer_commercialisation_estimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Producer_commercialisation_estimatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Producer_commercialisation_estimatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Producer_commercialisation_estimatesGroupByArgs['orderBy'] }
        : { orderBy?: Producer_commercialisation_estimatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Producer_commercialisation_estimatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProducer_commercialisation_estimatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for producer_commercialisation_estimates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__producer_commercialisation_estimatesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    company<T extends CompanyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Types.GetResult<CompanyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * producer_commercialisation_estimates base type for findUnique actions
   */
  export type producer_commercialisation_estimatesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_commercialisation_estimates to fetch.
     */
    where: producer_commercialisation_estimatesWhereUniqueInput
  }

  /**
   * producer_commercialisation_estimates findUnique
   */
  export interface producer_commercialisation_estimatesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends producer_commercialisation_estimatesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * producer_commercialisation_estimates findUniqueOrThrow
   */
  export type producer_commercialisation_estimatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_commercialisation_estimates to fetch.
     */
    where: producer_commercialisation_estimatesWhereUniqueInput
  }


  /**
   * producer_commercialisation_estimates base type for findFirst actions
   */
  export type producer_commercialisation_estimatesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_commercialisation_estimates to fetch.
     */
    where?: producer_commercialisation_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_commercialisation_estimates to fetch.
     */
    orderBy?: Enumerable<producer_commercialisation_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for producer_commercialisation_estimates.
     */
    cursor?: producer_commercialisation_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_commercialisation_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_commercialisation_estimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of producer_commercialisation_estimates.
     */
    distinct?: Enumerable<Producer_commercialisation_estimatesScalarFieldEnum>
  }

  /**
   * producer_commercialisation_estimates findFirst
   */
  export interface producer_commercialisation_estimatesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends producer_commercialisation_estimatesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * producer_commercialisation_estimates findFirstOrThrow
   */
  export type producer_commercialisation_estimatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_commercialisation_estimates to fetch.
     */
    where?: producer_commercialisation_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_commercialisation_estimates to fetch.
     */
    orderBy?: Enumerable<producer_commercialisation_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for producer_commercialisation_estimates.
     */
    cursor?: producer_commercialisation_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_commercialisation_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_commercialisation_estimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of producer_commercialisation_estimates.
     */
    distinct?: Enumerable<Producer_commercialisation_estimatesScalarFieldEnum>
  }


  /**
   * producer_commercialisation_estimates findMany
   */
  export type producer_commercialisation_estimatesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
    /**
     * Filter, which producer_commercialisation_estimates to fetch.
     */
    where?: producer_commercialisation_estimatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of producer_commercialisation_estimates to fetch.
     */
    orderBy?: Enumerable<producer_commercialisation_estimatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing producer_commercialisation_estimates.
     */
    cursor?: producer_commercialisation_estimatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` producer_commercialisation_estimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` producer_commercialisation_estimates.
     */
    skip?: number
    distinct?: Enumerable<Producer_commercialisation_estimatesScalarFieldEnum>
  }


  /**
   * producer_commercialisation_estimates create
   */
  export type producer_commercialisation_estimatesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
    /**
     * The data needed to create a producer_commercialisation_estimates.
     */
    data: XOR<producer_commercialisation_estimatesCreateInput, producer_commercialisation_estimatesUncheckedCreateInput>
  }


  /**
   * producer_commercialisation_estimates createMany
   */
  export type producer_commercialisation_estimatesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many producer_commercialisation_estimates.
     */
    data: Enumerable<producer_commercialisation_estimatesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * producer_commercialisation_estimates update
   */
  export type producer_commercialisation_estimatesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
    /**
     * The data needed to update a producer_commercialisation_estimates.
     */
    data: XOR<producer_commercialisation_estimatesUpdateInput, producer_commercialisation_estimatesUncheckedUpdateInput>
    /**
     * Choose, which producer_commercialisation_estimates to update.
     */
    where: producer_commercialisation_estimatesWhereUniqueInput
  }


  /**
   * producer_commercialisation_estimates updateMany
   */
  export type producer_commercialisation_estimatesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update producer_commercialisation_estimates.
     */
    data: XOR<producer_commercialisation_estimatesUpdateManyMutationInput, producer_commercialisation_estimatesUncheckedUpdateManyInput>
    /**
     * Filter which producer_commercialisation_estimates to update
     */
    where?: producer_commercialisation_estimatesWhereInput
  }


  /**
   * producer_commercialisation_estimates upsert
   */
  export type producer_commercialisation_estimatesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
    /**
     * The filter to search for the producer_commercialisation_estimates to update in case it exists.
     */
    where: producer_commercialisation_estimatesWhereUniqueInput
    /**
     * In case the producer_commercialisation_estimates found by the `where` argument doesn't exist, create a new producer_commercialisation_estimates with this data.
     */
    create: XOR<producer_commercialisation_estimatesCreateInput, producer_commercialisation_estimatesUncheckedCreateInput>
    /**
     * In case the producer_commercialisation_estimates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<producer_commercialisation_estimatesUpdateInput, producer_commercialisation_estimatesUncheckedUpdateInput>
  }


  /**
   * producer_commercialisation_estimates delete
   */
  export type producer_commercialisation_estimatesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
    /**
     * Filter which producer_commercialisation_estimates to delete.
     */
    where: producer_commercialisation_estimatesWhereUniqueInput
  }


  /**
   * producer_commercialisation_estimates deleteMany
   */
  export type producer_commercialisation_estimatesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which producer_commercialisation_estimates to delete
     */
    where?: producer_commercialisation_estimatesWhereInput
  }


  /**
   * producer_commercialisation_estimates without action
   */
  export type producer_commercialisation_estimatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the producer_commercialisation_estimates
     */
    select?: producer_commercialisation_estimatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: producer_commercialisation_estimatesInclude<ExtArgs> | null
  }



  /**
   * Model bug_report
   */


  export type AggregateBug_report = {
    _count: Bug_reportCountAggregateOutputType | null
    _min: Bug_reportMinAggregateOutputType | null
    _max: Bug_reportMaxAggregateOutputType | null
  }

  export type Bug_reportMinAggregateOutputType = {
    record_id: string | null
    type: string | null
    title: string | null
    text: string | null
    added_by: string | null
    date_created: Date | null
  }

  export type Bug_reportMaxAggregateOutputType = {
    record_id: string | null
    type: string | null
    title: string | null
    text: string | null
    added_by: string | null
    date_created: Date | null
  }

  export type Bug_reportCountAggregateOutputType = {
    record_id: number
    type: number
    title: number
    text: number
    added_by: number
    date_created: number
    _all: number
  }


  export type Bug_reportMinAggregateInputType = {
    record_id?: true
    type?: true
    title?: true
    text?: true
    added_by?: true
    date_created?: true
  }

  export type Bug_reportMaxAggregateInputType = {
    record_id?: true
    type?: true
    title?: true
    text?: true
    added_by?: true
    date_created?: true
  }

  export type Bug_reportCountAggregateInputType = {
    record_id?: true
    type?: true
    title?: true
    text?: true
    added_by?: true
    date_created?: true
    _all?: true
  }

  export type Bug_reportAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bug_report to aggregate.
     */
    where?: bug_reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bug_reports to fetch.
     */
    orderBy?: Enumerable<bug_reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bug_reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bug_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bug_reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bug_reports
    **/
    _count?: true | Bug_reportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bug_reportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bug_reportMaxAggregateInputType
  }

  export type GetBug_reportAggregateType<T extends Bug_reportAggregateArgs> = {
        [P in keyof T & keyof AggregateBug_report]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBug_report[P]>
      : GetScalarType<T[P], AggregateBug_report[P]>
  }




  export type Bug_reportGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bug_reportWhereInput
    orderBy?: Enumerable<bug_reportOrderByWithAggregationInput>
    by: Bug_reportScalarFieldEnum[]
    having?: bug_reportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bug_reportCountAggregateInputType | true
    _min?: Bug_reportMinAggregateInputType
    _max?: Bug_reportMaxAggregateInputType
  }


  export type Bug_reportGroupByOutputType = {
    record_id: string
    type: string | null
    title: string | null
    text: string | null
    added_by: string | null
    date_created: Date
    _count: Bug_reportCountAggregateOutputType | null
    _min: Bug_reportMinAggregateOutputType | null
    _max: Bug_reportMaxAggregateOutputType | null
  }

  type GetBug_reportGroupByPayload<T extends Bug_reportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Bug_reportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bug_reportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bug_reportGroupByOutputType[P]>
            : GetScalarType<T[P], Bug_reportGroupByOutputType[P]>
        }
      >
    >


  export type bug_reportSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    type?: boolean
    title?: boolean
    text?: boolean
    added_by?: boolean
    date_created?: boolean
  }, ExtArgs["result"]["bug_report"]>

  export type bug_reportSelectScalar = {
    record_id?: boolean
    type?: boolean
    title?: boolean
    text?: boolean
    added_by?: boolean
    date_created?: boolean
  }


  type bug_reportGetPayload<S extends boolean | null | undefined | bug_reportArgs> = $Types.GetResult<bug_reportPayload, S>

  type bug_reportCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<bug_reportFindManyArgs, 'select' | 'include'> & {
      select?: Bug_reportCountAggregateInputType | true
    }

  export interface bug_reportDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bug_report'], meta: { name: 'bug_report' } }
    /**
     * Find zero or one Bug_report that matches the filter.
     * @param {bug_reportFindUniqueArgs} args - Arguments to find a Bug_report
     * @example
     * // Get one Bug_report
     * const bug_report = await prisma.bug_report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bug_reportFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, bug_reportFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'bug_report'> extends True ? Prisma__bug_reportClient<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__bug_reportClient<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Bug_report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bug_reportFindUniqueOrThrowArgs} args - Arguments to find a Bug_report
     * @example
     * // Get one Bug_report
     * const bug_report = await prisma.bug_report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bug_reportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bug_reportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bug_reportClient<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Bug_report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bug_reportFindFirstArgs} args - Arguments to find a Bug_report
     * @example
     * // Get one Bug_report
     * const bug_report = await prisma.bug_report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bug_reportFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, bug_reportFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'bug_report'> extends True ? Prisma__bug_reportClient<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__bug_reportClient<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Bug_report that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bug_reportFindFirstOrThrowArgs} args - Arguments to find a Bug_report
     * @example
     * // Get one Bug_report
     * const bug_report = await prisma.bug_report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bug_reportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bug_reportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bug_reportClient<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Bug_reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bug_reportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bug_reports
     * const bug_reports = await prisma.bug_report.findMany()
     * 
     * // Get first 10 Bug_reports
     * const bug_reports = await prisma.bug_report.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const bug_reportWithRecord_idOnly = await prisma.bug_report.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends bug_reportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bug_reportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Bug_report.
     * @param {bug_reportCreateArgs} args - Arguments to create a Bug_report.
     * @example
     * // Create one Bug_report
     * const Bug_report = await prisma.bug_report.create({
     *   data: {
     *     // ... data to create a Bug_report
     *   }
     * })
     * 
    **/
    create<T extends bug_reportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bug_reportCreateArgs<ExtArgs>>
    ): Prisma__bug_reportClient<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Bug_reports.
     *     @param {bug_reportCreateManyArgs} args - Arguments to create many Bug_reports.
     *     @example
     *     // Create many Bug_reports
     *     const bug_report = await prisma.bug_report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bug_reportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bug_reportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bug_report.
     * @param {bug_reportDeleteArgs} args - Arguments to delete one Bug_report.
     * @example
     * // Delete one Bug_report
     * const Bug_report = await prisma.bug_report.delete({
     *   where: {
     *     // ... filter to delete one Bug_report
     *   }
     * })
     * 
    **/
    delete<T extends bug_reportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bug_reportDeleteArgs<ExtArgs>>
    ): Prisma__bug_reportClient<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Bug_report.
     * @param {bug_reportUpdateArgs} args - Arguments to update one Bug_report.
     * @example
     * // Update one Bug_report
     * const bug_report = await prisma.bug_report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bug_reportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bug_reportUpdateArgs<ExtArgs>>
    ): Prisma__bug_reportClient<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Bug_reports.
     * @param {bug_reportDeleteManyArgs} args - Arguments to filter Bug_reports to delete.
     * @example
     * // Delete a few Bug_reports
     * const { count } = await prisma.bug_report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bug_reportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bug_reportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bug_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bug_reportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bug_reports
     * const bug_report = await prisma.bug_report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bug_reportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bug_reportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bug_report.
     * @param {bug_reportUpsertArgs} args - Arguments to update or create a Bug_report.
     * @example
     * // Update or create a Bug_report
     * const bug_report = await prisma.bug_report.upsert({
     *   create: {
     *     // ... data to create a Bug_report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bug_report we want to update
     *   }
     * })
    **/
    upsert<T extends bug_reportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bug_reportUpsertArgs<ExtArgs>>
    ): Prisma__bug_reportClient<$Types.GetResult<bug_reportPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Bug_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bug_reportCountArgs} args - Arguments to filter Bug_reports to count.
     * @example
     * // Count the number of Bug_reports
     * const count = await prisma.bug_report.count({
     *   where: {
     *     // ... the filter for the Bug_reports we want to count
     *   }
     * })
    **/
    count<T extends bug_reportCountArgs>(
      args?: Subset<T, bug_reportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bug_reportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bug_report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bug_reportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bug_reportAggregateArgs>(args: Subset<T, Bug_reportAggregateArgs>): Prisma.PrismaPromise<GetBug_reportAggregateType<T>>

    /**
     * Group by Bug_report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bug_reportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Bug_reportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Bug_reportGroupByArgs['orderBy'] }
        : { orderBy?: Bug_reportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Bug_reportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBug_reportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for bug_report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__bug_reportClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * bug_report base type for findUnique actions
   */
  export type bug_reportFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bug_report
     */
    select?: bug_reportSelect<ExtArgs> | null
    /**
     * Filter, which bug_report to fetch.
     */
    where: bug_reportWhereUniqueInput
  }

  /**
   * bug_report findUnique
   */
  export interface bug_reportFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends bug_reportFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * bug_report findUniqueOrThrow
   */
  export type bug_reportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bug_report
     */
    select?: bug_reportSelect<ExtArgs> | null
    /**
     * Filter, which bug_report to fetch.
     */
    where: bug_reportWhereUniqueInput
  }


  /**
   * bug_report base type for findFirst actions
   */
  export type bug_reportFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bug_report
     */
    select?: bug_reportSelect<ExtArgs> | null
    /**
     * Filter, which bug_report to fetch.
     */
    where?: bug_reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bug_reports to fetch.
     */
    orderBy?: Enumerable<bug_reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bug_reports.
     */
    cursor?: bug_reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bug_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bug_reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bug_reports.
     */
    distinct?: Enumerable<Bug_reportScalarFieldEnum>
  }

  /**
   * bug_report findFirst
   */
  export interface bug_reportFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends bug_reportFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * bug_report findFirstOrThrow
   */
  export type bug_reportFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bug_report
     */
    select?: bug_reportSelect<ExtArgs> | null
    /**
     * Filter, which bug_report to fetch.
     */
    where?: bug_reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bug_reports to fetch.
     */
    orderBy?: Enumerable<bug_reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bug_reports.
     */
    cursor?: bug_reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bug_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bug_reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bug_reports.
     */
    distinct?: Enumerable<Bug_reportScalarFieldEnum>
  }


  /**
   * bug_report findMany
   */
  export type bug_reportFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bug_report
     */
    select?: bug_reportSelect<ExtArgs> | null
    /**
     * Filter, which bug_reports to fetch.
     */
    where?: bug_reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bug_reports to fetch.
     */
    orderBy?: Enumerable<bug_reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bug_reports.
     */
    cursor?: bug_reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bug_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bug_reports.
     */
    skip?: number
    distinct?: Enumerable<Bug_reportScalarFieldEnum>
  }


  /**
   * bug_report create
   */
  export type bug_reportCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bug_report
     */
    select?: bug_reportSelect<ExtArgs> | null
    /**
     * The data needed to create a bug_report.
     */
    data?: XOR<bug_reportCreateInput, bug_reportUncheckedCreateInput>
  }


  /**
   * bug_report createMany
   */
  export type bug_reportCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bug_reports.
     */
    data: Enumerable<bug_reportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * bug_report update
   */
  export type bug_reportUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bug_report
     */
    select?: bug_reportSelect<ExtArgs> | null
    /**
     * The data needed to update a bug_report.
     */
    data: XOR<bug_reportUpdateInput, bug_reportUncheckedUpdateInput>
    /**
     * Choose, which bug_report to update.
     */
    where: bug_reportWhereUniqueInput
  }


  /**
   * bug_report updateMany
   */
  export type bug_reportUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bug_reports.
     */
    data: XOR<bug_reportUpdateManyMutationInput, bug_reportUncheckedUpdateManyInput>
    /**
     * Filter which bug_reports to update
     */
    where?: bug_reportWhereInput
  }


  /**
   * bug_report upsert
   */
  export type bug_reportUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bug_report
     */
    select?: bug_reportSelect<ExtArgs> | null
    /**
     * The filter to search for the bug_report to update in case it exists.
     */
    where: bug_reportWhereUniqueInput
    /**
     * In case the bug_report found by the `where` argument doesn't exist, create a new bug_report with this data.
     */
    create: XOR<bug_reportCreateInput, bug_reportUncheckedCreateInput>
    /**
     * In case the bug_report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bug_reportUpdateInput, bug_reportUncheckedUpdateInput>
  }


  /**
   * bug_report delete
   */
  export type bug_reportDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bug_report
     */
    select?: bug_reportSelect<ExtArgs> | null
    /**
     * Filter which bug_report to delete.
     */
    where: bug_reportWhereUniqueInput
  }


  /**
   * bug_report deleteMany
   */
  export type bug_reportDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bug_reports to delete
     */
    where?: bug_reportWhereInput
  }


  /**
   * bug_report without action
   */
  export type bug_reportArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bug_report
     */
    select?: bug_reportSelect<ExtArgs> | null
  }



  /**
   * Model suggestions
   */


  export type AggregateSuggestions = {
    _count: SuggestionsCountAggregateOutputType | null
    _min: SuggestionsMinAggregateOutputType | null
    _max: SuggestionsMaxAggregateOutputType | null
  }

  export type SuggestionsMinAggregateOutputType = {
    record_id: string | null
    type: string | null
    text: string | null
    added_by: string | null
    date_created: Date | null
  }

  export type SuggestionsMaxAggregateOutputType = {
    record_id: string | null
    type: string | null
    text: string | null
    added_by: string | null
    date_created: Date | null
  }

  export type SuggestionsCountAggregateOutputType = {
    record_id: number
    type: number
    text: number
    added_by: number
    date_created: number
    _all: number
  }


  export type SuggestionsMinAggregateInputType = {
    record_id?: true
    type?: true
    text?: true
    added_by?: true
    date_created?: true
  }

  export type SuggestionsMaxAggregateInputType = {
    record_id?: true
    type?: true
    text?: true
    added_by?: true
    date_created?: true
  }

  export type SuggestionsCountAggregateInputType = {
    record_id?: true
    type?: true
    text?: true
    added_by?: true
    date_created?: true
    _all?: true
  }

  export type SuggestionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which suggestions to aggregate.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: Enumerable<suggestionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suggestions
    **/
    _count?: true | SuggestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuggestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuggestionsMaxAggregateInputType
  }

  export type GetSuggestionsAggregateType<T extends SuggestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSuggestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuggestions[P]>
      : GetScalarType<T[P], AggregateSuggestions[P]>
  }




  export type SuggestionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: suggestionsWhereInput
    orderBy?: Enumerable<suggestionsOrderByWithAggregationInput>
    by: SuggestionsScalarFieldEnum[]
    having?: suggestionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuggestionsCountAggregateInputType | true
    _min?: SuggestionsMinAggregateInputType
    _max?: SuggestionsMaxAggregateInputType
  }


  export type SuggestionsGroupByOutputType = {
    record_id: string
    type: string | null
    text: string | null
    added_by: string | null
    date_created: Date
    _count: SuggestionsCountAggregateOutputType | null
    _min: SuggestionsMinAggregateOutputType | null
    _max: SuggestionsMaxAggregateOutputType | null
  }

  type GetSuggestionsGroupByPayload<T extends SuggestionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SuggestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuggestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuggestionsGroupByOutputType[P]>
            : GetScalarType<T[P], SuggestionsGroupByOutputType[P]>
        }
      >
    >


  export type suggestionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    type?: boolean
    text?: boolean
    added_by?: boolean
    date_created?: boolean
  }, ExtArgs["result"]["suggestions"]>

  export type suggestionsSelectScalar = {
    record_id?: boolean
    type?: boolean
    text?: boolean
    added_by?: boolean
    date_created?: boolean
  }


  type suggestionsGetPayload<S extends boolean | null | undefined | suggestionsArgs> = $Types.GetResult<suggestionsPayload, S>

  type suggestionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<suggestionsFindManyArgs, 'select' | 'include'> & {
      select?: SuggestionsCountAggregateInputType | true
    }

  export interface suggestionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['suggestions'], meta: { name: 'suggestions' } }
    /**
     * Find zero or one Suggestions that matches the filter.
     * @param {suggestionsFindUniqueArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends suggestionsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, suggestionsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'suggestions'> extends True ? Prisma__suggestionsClient<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__suggestionsClient<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Suggestions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {suggestionsFindUniqueOrThrowArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends suggestionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, suggestionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__suggestionsClient<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Suggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsFindFirstArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends suggestionsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, suggestionsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'suggestions'> extends True ? Prisma__suggestionsClient<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__suggestionsClient<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Suggestions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsFindFirstOrThrowArgs} args - Arguments to find a Suggestions
     * @example
     * // Get one Suggestions
     * const suggestions = await prisma.suggestions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends suggestionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, suggestionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__suggestionsClient<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Suggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suggestions
     * const suggestions = await prisma.suggestions.findMany()
     * 
     * // Get first 10 Suggestions
     * const suggestions = await prisma.suggestions.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const suggestionsWithRecord_idOnly = await prisma.suggestions.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends suggestionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, suggestionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Suggestions.
     * @param {suggestionsCreateArgs} args - Arguments to create a Suggestions.
     * @example
     * // Create one Suggestions
     * const Suggestions = await prisma.suggestions.create({
     *   data: {
     *     // ... data to create a Suggestions
     *   }
     * })
     * 
    **/
    create<T extends suggestionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, suggestionsCreateArgs<ExtArgs>>
    ): Prisma__suggestionsClient<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Suggestions.
     *     @param {suggestionsCreateManyArgs} args - Arguments to create many Suggestions.
     *     @example
     *     // Create many Suggestions
     *     const suggestions = await prisma.suggestions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends suggestionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, suggestionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Suggestions.
     * @param {suggestionsDeleteArgs} args - Arguments to delete one Suggestions.
     * @example
     * // Delete one Suggestions
     * const Suggestions = await prisma.suggestions.delete({
     *   where: {
     *     // ... filter to delete one Suggestions
     *   }
     * })
     * 
    **/
    delete<T extends suggestionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, suggestionsDeleteArgs<ExtArgs>>
    ): Prisma__suggestionsClient<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Suggestions.
     * @param {suggestionsUpdateArgs} args - Arguments to update one Suggestions.
     * @example
     * // Update one Suggestions
     * const suggestions = await prisma.suggestions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends suggestionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, suggestionsUpdateArgs<ExtArgs>>
    ): Prisma__suggestionsClient<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Suggestions.
     * @param {suggestionsDeleteManyArgs} args - Arguments to filter Suggestions to delete.
     * @example
     * // Delete a few Suggestions
     * const { count } = await prisma.suggestions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends suggestionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, suggestionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suggestions
     * const suggestions = await prisma.suggestions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends suggestionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, suggestionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Suggestions.
     * @param {suggestionsUpsertArgs} args - Arguments to update or create a Suggestions.
     * @example
     * // Update or create a Suggestions
     * const suggestions = await prisma.suggestions.upsert({
     *   create: {
     *     // ... data to create a Suggestions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suggestions we want to update
     *   }
     * })
    **/
    upsert<T extends suggestionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, suggestionsUpsertArgs<ExtArgs>>
    ): Prisma__suggestionsClient<$Types.GetResult<suggestionsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suggestionsCountArgs} args - Arguments to filter Suggestions to count.
     * @example
     * // Count the number of Suggestions
     * const count = await prisma.suggestions.count({
     *   where: {
     *     // ... the filter for the Suggestions we want to count
     *   }
     * })
    **/
    count<T extends suggestionsCountArgs>(
      args?: Subset<T, suggestionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuggestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuggestionsAggregateArgs>(args: Subset<T, SuggestionsAggregateArgs>): Prisma.PrismaPromise<GetSuggestionsAggregateType<T>>

    /**
     * Group by Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuggestionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuggestionsGroupByArgs['orderBy'] }
        : { orderBy?: SuggestionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuggestionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuggestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for suggestions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__suggestionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * suggestions base type for findUnique actions
   */
  export type suggestionsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where: suggestionsWhereUniqueInput
  }

  /**
   * suggestions findUnique
   */
  export interface suggestionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends suggestionsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * suggestions findUniqueOrThrow
   */
  export type suggestionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where: suggestionsWhereUniqueInput
  }


  /**
   * suggestions base type for findFirst actions
   */
  export type suggestionsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: Enumerable<suggestionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suggestions.
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suggestions.
     */
    distinct?: Enumerable<SuggestionsScalarFieldEnum>
  }

  /**
   * suggestions findFirst
   */
  export interface suggestionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends suggestionsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * suggestions findFirstOrThrow
   */
  export type suggestionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: Enumerable<suggestionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suggestions.
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suggestions.
     */
    distinct?: Enumerable<SuggestionsScalarFieldEnum>
  }


  /**
   * suggestions findMany
   */
  export type suggestionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Filter, which suggestions to fetch.
     */
    where?: suggestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suggestions to fetch.
     */
    orderBy?: Enumerable<suggestionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suggestions.
     */
    cursor?: suggestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suggestions.
     */
    skip?: number
    distinct?: Enumerable<SuggestionsScalarFieldEnum>
  }


  /**
   * suggestions create
   */
  export type suggestionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * The data needed to create a suggestions.
     */
    data?: XOR<suggestionsCreateInput, suggestionsUncheckedCreateInput>
  }


  /**
   * suggestions createMany
   */
  export type suggestionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many suggestions.
     */
    data: Enumerable<suggestionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * suggestions update
   */
  export type suggestionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * The data needed to update a suggestions.
     */
    data: XOR<suggestionsUpdateInput, suggestionsUncheckedUpdateInput>
    /**
     * Choose, which suggestions to update.
     */
    where: suggestionsWhereUniqueInput
  }


  /**
   * suggestions updateMany
   */
  export type suggestionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update suggestions.
     */
    data: XOR<suggestionsUpdateManyMutationInput, suggestionsUncheckedUpdateManyInput>
    /**
     * Filter which suggestions to update
     */
    where?: suggestionsWhereInput
  }


  /**
   * suggestions upsert
   */
  export type suggestionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * The filter to search for the suggestions to update in case it exists.
     */
    where: suggestionsWhereUniqueInput
    /**
     * In case the suggestions found by the `where` argument doesn't exist, create a new suggestions with this data.
     */
    create: XOR<suggestionsCreateInput, suggestionsUncheckedCreateInput>
    /**
     * In case the suggestions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<suggestionsUpdateInput, suggestionsUncheckedUpdateInput>
  }


  /**
   * suggestions delete
   */
  export type suggestionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
    /**
     * Filter which suggestions to delete.
     */
    where: suggestionsWhereUniqueInput
  }


  /**
   * suggestions deleteMany
   */
  export type suggestionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which suggestions to delete
     */
    where?: suggestionsWhereInput
  }


  /**
   * suggestions without action
   */
  export type suggestionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suggestions
     */
    select?: suggestionsSelect<ExtArgs> | null
  }



  /**
   * Model upcoming_changes
   */


  export type AggregateUpcoming_changes = {
    _count: Upcoming_changesCountAggregateOutputType | null
    _min: Upcoming_changesMinAggregateOutputType | null
    _max: Upcoming_changesMaxAggregateOutputType | null
  }

  export type Upcoming_changesMinAggregateOutputType = {
    record_id: string | null
    type: string | null
    title: string | null
    text: string | null
    image: string | null
    planned_released_date: Date | null
  }

  export type Upcoming_changesMaxAggregateOutputType = {
    record_id: string | null
    type: string | null
    title: string | null
    text: string | null
    image: string | null
    planned_released_date: Date | null
  }

  export type Upcoming_changesCountAggregateOutputType = {
    record_id: number
    type: number
    title: number
    text: number
    image: number
    planned_released_date: number
    _all: number
  }


  export type Upcoming_changesMinAggregateInputType = {
    record_id?: true
    type?: true
    title?: true
    text?: true
    image?: true
    planned_released_date?: true
  }

  export type Upcoming_changesMaxAggregateInputType = {
    record_id?: true
    type?: true
    title?: true
    text?: true
    image?: true
    planned_released_date?: true
  }

  export type Upcoming_changesCountAggregateInputType = {
    record_id?: true
    type?: true
    title?: true
    text?: true
    image?: true
    planned_released_date?: true
    _all?: true
  }

  export type Upcoming_changesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which upcoming_changes to aggregate.
     */
    where?: upcoming_changesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upcoming_changes to fetch.
     */
    orderBy?: Enumerable<upcoming_changesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: upcoming_changesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upcoming_changes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upcoming_changes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned upcoming_changes
    **/
    _count?: true | Upcoming_changesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Upcoming_changesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Upcoming_changesMaxAggregateInputType
  }

  export type GetUpcoming_changesAggregateType<T extends Upcoming_changesAggregateArgs> = {
        [P in keyof T & keyof AggregateUpcoming_changes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpcoming_changes[P]>
      : GetScalarType<T[P], AggregateUpcoming_changes[P]>
  }




  export type Upcoming_changesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: upcoming_changesWhereInput
    orderBy?: Enumerable<upcoming_changesOrderByWithAggregationInput>
    by: Upcoming_changesScalarFieldEnum[]
    having?: upcoming_changesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Upcoming_changesCountAggregateInputType | true
    _min?: Upcoming_changesMinAggregateInputType
    _max?: Upcoming_changesMaxAggregateInputType
  }


  export type Upcoming_changesGroupByOutputType = {
    record_id: string
    type: string | null
    title: string | null
    text: string
    image: string | null
    planned_released_date: Date | null
    _count: Upcoming_changesCountAggregateOutputType | null
    _min: Upcoming_changesMinAggregateOutputType | null
    _max: Upcoming_changesMaxAggregateOutputType | null
  }

  type GetUpcoming_changesGroupByPayload<T extends Upcoming_changesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Upcoming_changesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Upcoming_changesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Upcoming_changesGroupByOutputType[P]>
            : GetScalarType<T[P], Upcoming_changesGroupByOutputType[P]>
        }
      >
    >


  export type upcoming_changesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    type?: boolean
    title?: boolean
    text?: boolean
    image?: boolean
    planned_released_date?: boolean
  }, ExtArgs["result"]["upcoming_changes"]>

  export type upcoming_changesSelectScalar = {
    record_id?: boolean
    type?: boolean
    title?: boolean
    text?: boolean
    image?: boolean
    planned_released_date?: boolean
  }


  type upcoming_changesGetPayload<S extends boolean | null | undefined | upcoming_changesArgs> = $Types.GetResult<upcoming_changesPayload, S>

  type upcoming_changesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<upcoming_changesFindManyArgs, 'select' | 'include'> & {
      select?: Upcoming_changesCountAggregateInputType | true
    }

  export interface upcoming_changesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['upcoming_changes'], meta: { name: 'upcoming_changes' } }
    /**
     * Find zero or one Upcoming_changes that matches the filter.
     * @param {upcoming_changesFindUniqueArgs} args - Arguments to find a Upcoming_changes
     * @example
     * // Get one Upcoming_changes
     * const upcoming_changes = await prisma.upcoming_changes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends upcoming_changesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, upcoming_changesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'upcoming_changes'> extends True ? Prisma__upcoming_changesClient<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__upcoming_changesClient<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Upcoming_changes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {upcoming_changesFindUniqueOrThrowArgs} args - Arguments to find a Upcoming_changes
     * @example
     * // Get one Upcoming_changes
     * const upcoming_changes = await prisma.upcoming_changes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends upcoming_changesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, upcoming_changesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__upcoming_changesClient<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Upcoming_changes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_changesFindFirstArgs} args - Arguments to find a Upcoming_changes
     * @example
     * // Get one Upcoming_changes
     * const upcoming_changes = await prisma.upcoming_changes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends upcoming_changesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, upcoming_changesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'upcoming_changes'> extends True ? Prisma__upcoming_changesClient<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__upcoming_changesClient<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Upcoming_changes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_changesFindFirstOrThrowArgs} args - Arguments to find a Upcoming_changes
     * @example
     * // Get one Upcoming_changes
     * const upcoming_changes = await prisma.upcoming_changes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends upcoming_changesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, upcoming_changesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__upcoming_changesClient<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Upcoming_changes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_changesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Upcoming_changes
     * const upcoming_changes = await prisma.upcoming_changes.findMany()
     * 
     * // Get first 10 Upcoming_changes
     * const upcoming_changes = await prisma.upcoming_changes.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const upcoming_changesWithRecord_idOnly = await prisma.upcoming_changes.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends upcoming_changesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, upcoming_changesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Upcoming_changes.
     * @param {upcoming_changesCreateArgs} args - Arguments to create a Upcoming_changes.
     * @example
     * // Create one Upcoming_changes
     * const Upcoming_changes = await prisma.upcoming_changes.create({
     *   data: {
     *     // ... data to create a Upcoming_changes
     *   }
     * })
     * 
    **/
    create<T extends upcoming_changesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, upcoming_changesCreateArgs<ExtArgs>>
    ): Prisma__upcoming_changesClient<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Upcoming_changes.
     *     @param {upcoming_changesCreateManyArgs} args - Arguments to create many Upcoming_changes.
     *     @example
     *     // Create many Upcoming_changes
     *     const upcoming_changes = await prisma.upcoming_changes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends upcoming_changesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, upcoming_changesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Upcoming_changes.
     * @param {upcoming_changesDeleteArgs} args - Arguments to delete one Upcoming_changes.
     * @example
     * // Delete one Upcoming_changes
     * const Upcoming_changes = await prisma.upcoming_changes.delete({
     *   where: {
     *     // ... filter to delete one Upcoming_changes
     *   }
     * })
     * 
    **/
    delete<T extends upcoming_changesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, upcoming_changesDeleteArgs<ExtArgs>>
    ): Prisma__upcoming_changesClient<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Upcoming_changes.
     * @param {upcoming_changesUpdateArgs} args - Arguments to update one Upcoming_changes.
     * @example
     * // Update one Upcoming_changes
     * const upcoming_changes = await prisma.upcoming_changes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends upcoming_changesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, upcoming_changesUpdateArgs<ExtArgs>>
    ): Prisma__upcoming_changesClient<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Upcoming_changes.
     * @param {upcoming_changesDeleteManyArgs} args - Arguments to filter Upcoming_changes to delete.
     * @example
     * // Delete a few Upcoming_changes
     * const { count } = await prisma.upcoming_changes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends upcoming_changesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, upcoming_changesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Upcoming_changes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_changesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Upcoming_changes
     * const upcoming_changes = await prisma.upcoming_changes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends upcoming_changesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, upcoming_changesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Upcoming_changes.
     * @param {upcoming_changesUpsertArgs} args - Arguments to update or create a Upcoming_changes.
     * @example
     * // Update or create a Upcoming_changes
     * const upcoming_changes = await prisma.upcoming_changes.upsert({
     *   create: {
     *     // ... data to create a Upcoming_changes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Upcoming_changes we want to update
     *   }
     * })
    **/
    upsert<T extends upcoming_changesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, upcoming_changesUpsertArgs<ExtArgs>>
    ): Prisma__upcoming_changesClient<$Types.GetResult<upcoming_changesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Upcoming_changes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_changesCountArgs} args - Arguments to filter Upcoming_changes to count.
     * @example
     * // Count the number of Upcoming_changes
     * const count = await prisma.upcoming_changes.count({
     *   where: {
     *     // ... the filter for the Upcoming_changes we want to count
     *   }
     * })
    **/
    count<T extends upcoming_changesCountArgs>(
      args?: Subset<T, upcoming_changesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Upcoming_changesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Upcoming_changes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Upcoming_changesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Upcoming_changesAggregateArgs>(args: Subset<T, Upcoming_changesAggregateArgs>): Prisma.PrismaPromise<GetUpcoming_changesAggregateType<T>>

    /**
     * Group by Upcoming_changes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Upcoming_changesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Upcoming_changesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Upcoming_changesGroupByArgs['orderBy'] }
        : { orderBy?: Upcoming_changesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Upcoming_changesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpcoming_changesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for upcoming_changes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__upcoming_changesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * upcoming_changes base type for findUnique actions
   */
  export type upcoming_changesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_changes
     */
    select?: upcoming_changesSelect<ExtArgs> | null
    /**
     * Filter, which upcoming_changes to fetch.
     */
    where: upcoming_changesWhereUniqueInput
  }

  /**
   * upcoming_changes findUnique
   */
  export interface upcoming_changesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends upcoming_changesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * upcoming_changes findUniqueOrThrow
   */
  export type upcoming_changesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_changes
     */
    select?: upcoming_changesSelect<ExtArgs> | null
    /**
     * Filter, which upcoming_changes to fetch.
     */
    where: upcoming_changesWhereUniqueInput
  }


  /**
   * upcoming_changes base type for findFirst actions
   */
  export type upcoming_changesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_changes
     */
    select?: upcoming_changesSelect<ExtArgs> | null
    /**
     * Filter, which upcoming_changes to fetch.
     */
    where?: upcoming_changesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upcoming_changes to fetch.
     */
    orderBy?: Enumerable<upcoming_changesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for upcoming_changes.
     */
    cursor?: upcoming_changesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upcoming_changes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upcoming_changes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of upcoming_changes.
     */
    distinct?: Enumerable<Upcoming_changesScalarFieldEnum>
  }

  /**
   * upcoming_changes findFirst
   */
  export interface upcoming_changesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends upcoming_changesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * upcoming_changes findFirstOrThrow
   */
  export type upcoming_changesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_changes
     */
    select?: upcoming_changesSelect<ExtArgs> | null
    /**
     * Filter, which upcoming_changes to fetch.
     */
    where?: upcoming_changesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upcoming_changes to fetch.
     */
    orderBy?: Enumerable<upcoming_changesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for upcoming_changes.
     */
    cursor?: upcoming_changesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upcoming_changes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upcoming_changes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of upcoming_changes.
     */
    distinct?: Enumerable<Upcoming_changesScalarFieldEnum>
  }


  /**
   * upcoming_changes findMany
   */
  export type upcoming_changesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_changes
     */
    select?: upcoming_changesSelect<ExtArgs> | null
    /**
     * Filter, which upcoming_changes to fetch.
     */
    where?: upcoming_changesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upcoming_changes to fetch.
     */
    orderBy?: Enumerable<upcoming_changesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing upcoming_changes.
     */
    cursor?: upcoming_changesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upcoming_changes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upcoming_changes.
     */
    skip?: number
    distinct?: Enumerable<Upcoming_changesScalarFieldEnum>
  }


  /**
   * upcoming_changes create
   */
  export type upcoming_changesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_changes
     */
    select?: upcoming_changesSelect<ExtArgs> | null
    /**
     * The data needed to create a upcoming_changes.
     */
    data: XOR<upcoming_changesCreateInput, upcoming_changesUncheckedCreateInput>
  }


  /**
   * upcoming_changes createMany
   */
  export type upcoming_changesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many upcoming_changes.
     */
    data: Enumerable<upcoming_changesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * upcoming_changes update
   */
  export type upcoming_changesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_changes
     */
    select?: upcoming_changesSelect<ExtArgs> | null
    /**
     * The data needed to update a upcoming_changes.
     */
    data: XOR<upcoming_changesUpdateInput, upcoming_changesUncheckedUpdateInput>
    /**
     * Choose, which upcoming_changes to update.
     */
    where: upcoming_changesWhereUniqueInput
  }


  /**
   * upcoming_changes updateMany
   */
  export type upcoming_changesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update upcoming_changes.
     */
    data: XOR<upcoming_changesUpdateManyMutationInput, upcoming_changesUncheckedUpdateManyInput>
    /**
     * Filter which upcoming_changes to update
     */
    where?: upcoming_changesWhereInput
  }


  /**
   * upcoming_changes upsert
   */
  export type upcoming_changesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_changes
     */
    select?: upcoming_changesSelect<ExtArgs> | null
    /**
     * The filter to search for the upcoming_changes to update in case it exists.
     */
    where: upcoming_changesWhereUniqueInput
    /**
     * In case the upcoming_changes found by the `where` argument doesn't exist, create a new upcoming_changes with this data.
     */
    create: XOR<upcoming_changesCreateInput, upcoming_changesUncheckedCreateInput>
    /**
     * In case the upcoming_changes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<upcoming_changesUpdateInput, upcoming_changesUncheckedUpdateInput>
  }


  /**
   * upcoming_changes delete
   */
  export type upcoming_changesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_changes
     */
    select?: upcoming_changesSelect<ExtArgs> | null
    /**
     * Filter which upcoming_changes to delete.
     */
    where: upcoming_changesWhereUniqueInput
  }


  /**
   * upcoming_changes deleteMany
   */
  export type upcoming_changesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which upcoming_changes to delete
     */
    where?: upcoming_changesWhereInput
  }


  /**
   * upcoming_changes without action
   */
  export type upcoming_changesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_changes
     */
    select?: upcoming_changesSelect<ExtArgs> | null
  }



  /**
   * Model conclusion
   */


  export type AggregateConclusion = {
    _count: ConclusionCountAggregateOutputType | null
    _min: ConclusionMinAggregateOutputType | null
    _max: ConclusionMaxAggregateOutputType | null
  }

  export type ConclusionMinAggregateOutputType = {
    record_id: string | null
    text: string | null
    date_created: Date | null
  }

  export type ConclusionMaxAggregateOutputType = {
    record_id: string | null
    text: string | null
    date_created: Date | null
  }

  export type ConclusionCountAggregateOutputType = {
    record_id: number
    text: number
    date_created: number
    _all: number
  }


  export type ConclusionMinAggregateInputType = {
    record_id?: true
    text?: true
    date_created?: true
  }

  export type ConclusionMaxAggregateInputType = {
    record_id?: true
    text?: true
    date_created?: true
  }

  export type ConclusionCountAggregateInputType = {
    record_id?: true
    text?: true
    date_created?: true
    _all?: true
  }

  export type ConclusionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which conclusion to aggregate.
     */
    where?: conclusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conclusions to fetch.
     */
    orderBy?: Enumerable<conclusionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conclusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conclusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conclusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conclusions
    **/
    _count?: true | ConclusionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConclusionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConclusionMaxAggregateInputType
  }

  export type GetConclusionAggregateType<T extends ConclusionAggregateArgs> = {
        [P in keyof T & keyof AggregateConclusion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConclusion[P]>
      : GetScalarType<T[P], AggregateConclusion[P]>
  }




  export type ConclusionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: conclusionWhereInput
    orderBy?: Enumerable<conclusionOrderByWithAggregationInput>
    by: ConclusionScalarFieldEnum[]
    having?: conclusionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConclusionCountAggregateInputType | true
    _min?: ConclusionMinAggregateInputType
    _max?: ConclusionMaxAggregateInputType
  }


  export type ConclusionGroupByOutputType = {
    record_id: string
    text: string
    date_created: Date
    _count: ConclusionCountAggregateOutputType | null
    _min: ConclusionMinAggregateOutputType | null
    _max: ConclusionMaxAggregateOutputType | null
  }

  type GetConclusionGroupByPayload<T extends ConclusionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ConclusionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConclusionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConclusionGroupByOutputType[P]>
            : GetScalarType<T[P], ConclusionGroupByOutputType[P]>
        }
      >
    >


  export type conclusionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    text?: boolean
    date_created?: boolean
  }, ExtArgs["result"]["conclusion"]>

  export type conclusionSelectScalar = {
    record_id?: boolean
    text?: boolean
    date_created?: boolean
  }


  type conclusionGetPayload<S extends boolean | null | undefined | conclusionArgs> = $Types.GetResult<conclusionPayload, S>

  type conclusionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<conclusionFindManyArgs, 'select' | 'include'> & {
      select?: ConclusionCountAggregateInputType | true
    }

  export interface conclusionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conclusion'], meta: { name: 'conclusion' } }
    /**
     * Find zero or one Conclusion that matches the filter.
     * @param {conclusionFindUniqueArgs} args - Arguments to find a Conclusion
     * @example
     * // Get one Conclusion
     * const conclusion = await prisma.conclusion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends conclusionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, conclusionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'conclusion'> extends True ? Prisma__conclusionClient<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__conclusionClient<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Conclusion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {conclusionFindUniqueOrThrowArgs} args - Arguments to find a Conclusion
     * @example
     * // Get one Conclusion
     * const conclusion = await prisma.conclusion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends conclusionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conclusionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__conclusionClient<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Conclusion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conclusionFindFirstArgs} args - Arguments to find a Conclusion
     * @example
     * // Get one Conclusion
     * const conclusion = await prisma.conclusion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends conclusionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, conclusionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'conclusion'> extends True ? Prisma__conclusionClient<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__conclusionClient<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Conclusion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conclusionFindFirstOrThrowArgs} args - Arguments to find a Conclusion
     * @example
     * // Get one Conclusion
     * const conclusion = await prisma.conclusion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends conclusionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conclusionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__conclusionClient<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Conclusions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conclusionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conclusions
     * const conclusions = await prisma.conclusion.findMany()
     * 
     * // Get first 10 Conclusions
     * const conclusions = await prisma.conclusion.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const conclusionWithRecord_idOnly = await prisma.conclusion.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends conclusionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conclusionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Conclusion.
     * @param {conclusionCreateArgs} args - Arguments to create a Conclusion.
     * @example
     * // Create one Conclusion
     * const Conclusion = await prisma.conclusion.create({
     *   data: {
     *     // ... data to create a Conclusion
     *   }
     * })
     * 
    **/
    create<T extends conclusionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, conclusionCreateArgs<ExtArgs>>
    ): Prisma__conclusionClient<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Conclusions.
     *     @param {conclusionCreateManyArgs} args - Arguments to create many Conclusions.
     *     @example
     *     // Create many Conclusions
     *     const conclusion = await prisma.conclusion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends conclusionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conclusionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conclusion.
     * @param {conclusionDeleteArgs} args - Arguments to delete one Conclusion.
     * @example
     * // Delete one Conclusion
     * const Conclusion = await prisma.conclusion.delete({
     *   where: {
     *     // ... filter to delete one Conclusion
     *   }
     * })
     * 
    **/
    delete<T extends conclusionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, conclusionDeleteArgs<ExtArgs>>
    ): Prisma__conclusionClient<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Conclusion.
     * @param {conclusionUpdateArgs} args - Arguments to update one Conclusion.
     * @example
     * // Update one Conclusion
     * const conclusion = await prisma.conclusion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends conclusionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, conclusionUpdateArgs<ExtArgs>>
    ): Prisma__conclusionClient<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Conclusions.
     * @param {conclusionDeleteManyArgs} args - Arguments to filter Conclusions to delete.
     * @example
     * // Delete a few Conclusions
     * const { count } = await prisma.conclusion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends conclusionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conclusionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conclusions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conclusionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conclusions
     * const conclusion = await prisma.conclusion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends conclusionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, conclusionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conclusion.
     * @param {conclusionUpsertArgs} args - Arguments to update or create a Conclusion.
     * @example
     * // Update or create a Conclusion
     * const conclusion = await prisma.conclusion.upsert({
     *   create: {
     *     // ... data to create a Conclusion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conclusion we want to update
     *   }
     * })
    **/
    upsert<T extends conclusionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, conclusionUpsertArgs<ExtArgs>>
    ): Prisma__conclusionClient<$Types.GetResult<conclusionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Conclusions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conclusionCountArgs} args - Arguments to filter Conclusions to count.
     * @example
     * // Count the number of Conclusions
     * const count = await prisma.conclusion.count({
     *   where: {
     *     // ... the filter for the Conclusions we want to count
     *   }
     * })
    **/
    count<T extends conclusionCountArgs>(
      args?: Subset<T, conclusionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConclusionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conclusion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConclusionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConclusionAggregateArgs>(args: Subset<T, ConclusionAggregateArgs>): Prisma.PrismaPromise<GetConclusionAggregateType<T>>

    /**
     * Group by Conclusion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConclusionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConclusionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConclusionGroupByArgs['orderBy'] }
        : { orderBy?: ConclusionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConclusionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConclusionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for conclusion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__conclusionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * conclusion base type for findUnique actions
   */
  export type conclusionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conclusion
     */
    select?: conclusionSelect<ExtArgs> | null
    /**
     * Filter, which conclusion to fetch.
     */
    where: conclusionWhereUniqueInput
  }

  /**
   * conclusion findUnique
   */
  export interface conclusionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends conclusionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * conclusion findUniqueOrThrow
   */
  export type conclusionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conclusion
     */
    select?: conclusionSelect<ExtArgs> | null
    /**
     * Filter, which conclusion to fetch.
     */
    where: conclusionWhereUniqueInput
  }


  /**
   * conclusion base type for findFirst actions
   */
  export type conclusionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conclusion
     */
    select?: conclusionSelect<ExtArgs> | null
    /**
     * Filter, which conclusion to fetch.
     */
    where?: conclusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conclusions to fetch.
     */
    orderBy?: Enumerable<conclusionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conclusions.
     */
    cursor?: conclusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conclusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conclusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conclusions.
     */
    distinct?: Enumerable<ConclusionScalarFieldEnum>
  }

  /**
   * conclusion findFirst
   */
  export interface conclusionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends conclusionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * conclusion findFirstOrThrow
   */
  export type conclusionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conclusion
     */
    select?: conclusionSelect<ExtArgs> | null
    /**
     * Filter, which conclusion to fetch.
     */
    where?: conclusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conclusions to fetch.
     */
    orderBy?: Enumerable<conclusionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conclusions.
     */
    cursor?: conclusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conclusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conclusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conclusions.
     */
    distinct?: Enumerable<ConclusionScalarFieldEnum>
  }


  /**
   * conclusion findMany
   */
  export type conclusionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conclusion
     */
    select?: conclusionSelect<ExtArgs> | null
    /**
     * Filter, which conclusions to fetch.
     */
    where?: conclusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conclusions to fetch.
     */
    orderBy?: Enumerable<conclusionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conclusions.
     */
    cursor?: conclusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conclusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conclusions.
     */
    skip?: number
    distinct?: Enumerable<ConclusionScalarFieldEnum>
  }


  /**
   * conclusion create
   */
  export type conclusionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conclusion
     */
    select?: conclusionSelect<ExtArgs> | null
    /**
     * The data needed to create a conclusion.
     */
    data: XOR<conclusionCreateInput, conclusionUncheckedCreateInput>
  }


  /**
   * conclusion createMany
   */
  export type conclusionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conclusions.
     */
    data: Enumerable<conclusionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * conclusion update
   */
  export type conclusionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conclusion
     */
    select?: conclusionSelect<ExtArgs> | null
    /**
     * The data needed to update a conclusion.
     */
    data: XOR<conclusionUpdateInput, conclusionUncheckedUpdateInput>
    /**
     * Choose, which conclusion to update.
     */
    where: conclusionWhereUniqueInput
  }


  /**
   * conclusion updateMany
   */
  export type conclusionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conclusions.
     */
    data: XOR<conclusionUpdateManyMutationInput, conclusionUncheckedUpdateManyInput>
    /**
     * Filter which conclusions to update
     */
    where?: conclusionWhereInput
  }


  /**
   * conclusion upsert
   */
  export type conclusionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conclusion
     */
    select?: conclusionSelect<ExtArgs> | null
    /**
     * The filter to search for the conclusion to update in case it exists.
     */
    where: conclusionWhereUniqueInput
    /**
     * In case the conclusion found by the `where` argument doesn't exist, create a new conclusion with this data.
     */
    create: XOR<conclusionCreateInput, conclusionUncheckedCreateInput>
    /**
     * In case the conclusion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conclusionUpdateInput, conclusionUncheckedUpdateInput>
  }


  /**
   * conclusion delete
   */
  export type conclusionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conclusion
     */
    select?: conclusionSelect<ExtArgs> | null
    /**
     * Filter which conclusion to delete.
     */
    where: conclusionWhereUniqueInput
  }


  /**
   * conclusion deleteMany
   */
  export type conclusionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which conclusions to delete
     */
    where?: conclusionWhereInput
  }


  /**
   * conclusion without action
   */
  export type conclusionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conclusion
     */
    select?: conclusionSelect<ExtArgs> | null
  }



  /**
   * Model Demo_Requests
   */


  export type AggregateDemo_Requests = {
    _count: Demo_RequestsCountAggregateOutputType | null
    _min: Demo_RequestsMinAggregateOutputType | null
    _max: Demo_RequestsMaxAggregateOutputType | null
  }

  export type Demo_RequestsMinAggregateOutputType = {
    record_id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    company_name: string | null
    company_type: string | null
    preferred_date: Date | null
    preferred_time: Date | null
    date_created: Date | null
  }

  export type Demo_RequestsMaxAggregateOutputType = {
    record_id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    company_name: string | null
    company_type: string | null
    preferred_date: Date | null
    preferred_time: Date | null
    date_created: Date | null
  }

  export type Demo_RequestsCountAggregateOutputType = {
    record_id: number
    first_name: number
    last_name: number
    email: number
    company_name: number
    company_type: number
    preferred_date: number
    preferred_time: number
    date_created: number
    _all: number
  }


  export type Demo_RequestsMinAggregateInputType = {
    record_id?: true
    first_name?: true
    last_name?: true
    email?: true
    company_name?: true
    company_type?: true
    preferred_date?: true
    preferred_time?: true
    date_created?: true
  }

  export type Demo_RequestsMaxAggregateInputType = {
    record_id?: true
    first_name?: true
    last_name?: true
    email?: true
    company_name?: true
    company_type?: true
    preferred_date?: true
    preferred_time?: true
    date_created?: true
  }

  export type Demo_RequestsCountAggregateInputType = {
    record_id?: true
    first_name?: true
    last_name?: true
    email?: true
    company_name?: true
    company_type?: true
    preferred_date?: true
    preferred_time?: true
    date_created?: true
    _all?: true
  }

  export type Demo_RequestsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Demo_Requests to aggregate.
     */
    where?: Demo_RequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demo_Requests to fetch.
     */
    orderBy?: Enumerable<Demo_RequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Demo_RequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demo_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demo_Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Demo_Requests
    **/
    _count?: true | Demo_RequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Demo_RequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Demo_RequestsMaxAggregateInputType
  }

  export type GetDemo_RequestsAggregateType<T extends Demo_RequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateDemo_Requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDemo_Requests[P]>
      : GetScalarType<T[P], AggregateDemo_Requests[P]>
  }




  export type Demo_RequestsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Demo_RequestsWhereInput
    orderBy?: Enumerable<Demo_RequestsOrderByWithAggregationInput>
    by: Demo_RequestsScalarFieldEnum[]
    having?: Demo_RequestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Demo_RequestsCountAggregateInputType | true
    _min?: Demo_RequestsMinAggregateInputType
    _max?: Demo_RequestsMaxAggregateInputType
  }


  export type Demo_RequestsGroupByOutputType = {
    record_id: string
    first_name: string
    last_name: string
    email: string
    company_name: string | null
    company_type: string | null
    preferred_date: Date | null
    preferred_time: Date | null
    date_created: Date
    _count: Demo_RequestsCountAggregateOutputType | null
    _min: Demo_RequestsMinAggregateOutputType | null
    _max: Demo_RequestsMaxAggregateOutputType | null
  }

  type GetDemo_RequestsGroupByPayload<T extends Demo_RequestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Demo_RequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Demo_RequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Demo_RequestsGroupByOutputType[P]>
            : GetScalarType<T[P], Demo_RequestsGroupByOutputType[P]>
        }
      >
    >


  export type Demo_RequestsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    company_name?: boolean
    company_type?: boolean
    preferred_date?: boolean
    preferred_time?: boolean
    date_created?: boolean
  }, ExtArgs["result"]["demo_Requests"]>

  export type Demo_RequestsSelectScalar = {
    record_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    company_name?: boolean
    company_type?: boolean
    preferred_date?: boolean
    preferred_time?: boolean
    date_created?: boolean
  }


  type Demo_RequestsGetPayload<S extends boolean | null | undefined | Demo_RequestsArgs> = $Types.GetResult<Demo_RequestsPayload, S>

  type Demo_RequestsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<Demo_RequestsFindManyArgs, 'select' | 'include'> & {
      select?: Demo_RequestsCountAggregateInputType | true
    }

  export interface Demo_RequestsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Demo_Requests'], meta: { name: 'Demo_Requests' } }
    /**
     * Find zero or one Demo_Requests that matches the filter.
     * @param {Demo_RequestsFindUniqueArgs} args - Arguments to find a Demo_Requests
     * @example
     * // Get one Demo_Requests
     * const demo_Requests = await prisma.demo_Requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Demo_RequestsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Demo_RequestsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Demo_Requests'> extends True ? Prisma__Demo_RequestsClient<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__Demo_RequestsClient<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Demo_Requests that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Demo_RequestsFindUniqueOrThrowArgs} args - Arguments to find a Demo_Requests
     * @example
     * // Get one Demo_Requests
     * const demo_Requests = await prisma.demo_Requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Demo_RequestsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Demo_RequestsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Demo_RequestsClient<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Demo_Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Demo_RequestsFindFirstArgs} args - Arguments to find a Demo_Requests
     * @example
     * // Get one Demo_Requests
     * const demo_Requests = await prisma.demo_Requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Demo_RequestsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Demo_RequestsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Demo_Requests'> extends True ? Prisma__Demo_RequestsClient<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__Demo_RequestsClient<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Demo_Requests that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Demo_RequestsFindFirstOrThrowArgs} args - Arguments to find a Demo_Requests
     * @example
     * // Get one Demo_Requests
     * const demo_Requests = await prisma.demo_Requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Demo_RequestsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Demo_RequestsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Demo_RequestsClient<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Demo_Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Demo_RequestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Demo_Requests
     * const demo_Requests = await prisma.demo_Requests.findMany()
     * 
     * // Get first 10 Demo_Requests
     * const demo_Requests = await prisma.demo_Requests.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const demo_RequestsWithRecord_idOnly = await prisma.demo_Requests.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends Demo_RequestsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Demo_RequestsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Demo_Requests.
     * @param {Demo_RequestsCreateArgs} args - Arguments to create a Demo_Requests.
     * @example
     * // Create one Demo_Requests
     * const Demo_Requests = await prisma.demo_Requests.create({
     *   data: {
     *     // ... data to create a Demo_Requests
     *   }
     * })
     * 
    **/
    create<T extends Demo_RequestsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Demo_RequestsCreateArgs<ExtArgs>>
    ): Prisma__Demo_RequestsClient<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Demo_Requests.
     *     @param {Demo_RequestsCreateManyArgs} args - Arguments to create many Demo_Requests.
     *     @example
     *     // Create many Demo_Requests
     *     const demo_Requests = await prisma.demo_Requests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Demo_RequestsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Demo_RequestsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Demo_Requests.
     * @param {Demo_RequestsDeleteArgs} args - Arguments to delete one Demo_Requests.
     * @example
     * // Delete one Demo_Requests
     * const Demo_Requests = await prisma.demo_Requests.delete({
     *   where: {
     *     // ... filter to delete one Demo_Requests
     *   }
     * })
     * 
    **/
    delete<T extends Demo_RequestsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Demo_RequestsDeleteArgs<ExtArgs>>
    ): Prisma__Demo_RequestsClient<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Demo_Requests.
     * @param {Demo_RequestsUpdateArgs} args - Arguments to update one Demo_Requests.
     * @example
     * // Update one Demo_Requests
     * const demo_Requests = await prisma.demo_Requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Demo_RequestsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Demo_RequestsUpdateArgs<ExtArgs>>
    ): Prisma__Demo_RequestsClient<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Demo_Requests.
     * @param {Demo_RequestsDeleteManyArgs} args - Arguments to filter Demo_Requests to delete.
     * @example
     * // Delete a few Demo_Requests
     * const { count } = await prisma.demo_Requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Demo_RequestsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Demo_RequestsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Demo_Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Demo_RequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Demo_Requests
     * const demo_Requests = await prisma.demo_Requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Demo_RequestsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Demo_RequestsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Demo_Requests.
     * @param {Demo_RequestsUpsertArgs} args - Arguments to update or create a Demo_Requests.
     * @example
     * // Update or create a Demo_Requests
     * const demo_Requests = await prisma.demo_Requests.upsert({
     *   create: {
     *     // ... data to create a Demo_Requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Demo_Requests we want to update
     *   }
     * })
    **/
    upsert<T extends Demo_RequestsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Demo_RequestsUpsertArgs<ExtArgs>>
    ): Prisma__Demo_RequestsClient<$Types.GetResult<Demo_RequestsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Demo_Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Demo_RequestsCountArgs} args - Arguments to filter Demo_Requests to count.
     * @example
     * // Count the number of Demo_Requests
     * const count = await prisma.demo_Requests.count({
     *   where: {
     *     // ... the filter for the Demo_Requests we want to count
     *   }
     * })
    **/
    count<T extends Demo_RequestsCountArgs>(
      args?: Subset<T, Demo_RequestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Demo_RequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Demo_Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Demo_RequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Demo_RequestsAggregateArgs>(args: Subset<T, Demo_RequestsAggregateArgs>): Prisma.PrismaPromise<GetDemo_RequestsAggregateType<T>>

    /**
     * Group by Demo_Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Demo_RequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Demo_RequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Demo_RequestsGroupByArgs['orderBy'] }
        : { orderBy?: Demo_RequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Demo_RequestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDemo_RequestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Demo_Requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Demo_RequestsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Demo_Requests base type for findUnique actions
   */
  export type Demo_RequestsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demo_Requests
     */
    select?: Demo_RequestsSelect<ExtArgs> | null
    /**
     * Filter, which Demo_Requests to fetch.
     */
    where: Demo_RequestsWhereUniqueInput
  }

  /**
   * Demo_Requests findUnique
   */
  export interface Demo_RequestsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Demo_RequestsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Demo_Requests findUniqueOrThrow
   */
  export type Demo_RequestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demo_Requests
     */
    select?: Demo_RequestsSelect<ExtArgs> | null
    /**
     * Filter, which Demo_Requests to fetch.
     */
    where: Demo_RequestsWhereUniqueInput
  }


  /**
   * Demo_Requests base type for findFirst actions
   */
  export type Demo_RequestsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demo_Requests
     */
    select?: Demo_RequestsSelect<ExtArgs> | null
    /**
     * Filter, which Demo_Requests to fetch.
     */
    where?: Demo_RequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demo_Requests to fetch.
     */
    orderBy?: Enumerable<Demo_RequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Demo_Requests.
     */
    cursor?: Demo_RequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demo_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demo_Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Demo_Requests.
     */
    distinct?: Enumerable<Demo_RequestsScalarFieldEnum>
  }

  /**
   * Demo_Requests findFirst
   */
  export interface Demo_RequestsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Demo_RequestsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Demo_Requests findFirstOrThrow
   */
  export type Demo_RequestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demo_Requests
     */
    select?: Demo_RequestsSelect<ExtArgs> | null
    /**
     * Filter, which Demo_Requests to fetch.
     */
    where?: Demo_RequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demo_Requests to fetch.
     */
    orderBy?: Enumerable<Demo_RequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Demo_Requests.
     */
    cursor?: Demo_RequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demo_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demo_Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Demo_Requests.
     */
    distinct?: Enumerable<Demo_RequestsScalarFieldEnum>
  }


  /**
   * Demo_Requests findMany
   */
  export type Demo_RequestsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demo_Requests
     */
    select?: Demo_RequestsSelect<ExtArgs> | null
    /**
     * Filter, which Demo_Requests to fetch.
     */
    where?: Demo_RequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demo_Requests to fetch.
     */
    orderBy?: Enumerable<Demo_RequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Demo_Requests.
     */
    cursor?: Demo_RequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demo_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demo_Requests.
     */
    skip?: number
    distinct?: Enumerable<Demo_RequestsScalarFieldEnum>
  }


  /**
   * Demo_Requests create
   */
  export type Demo_RequestsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demo_Requests
     */
    select?: Demo_RequestsSelect<ExtArgs> | null
    /**
     * The data needed to create a Demo_Requests.
     */
    data: XOR<Demo_RequestsCreateInput, Demo_RequestsUncheckedCreateInput>
  }


  /**
   * Demo_Requests createMany
   */
  export type Demo_RequestsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Demo_Requests.
     */
    data: Enumerable<Demo_RequestsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Demo_Requests update
   */
  export type Demo_RequestsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demo_Requests
     */
    select?: Demo_RequestsSelect<ExtArgs> | null
    /**
     * The data needed to update a Demo_Requests.
     */
    data: XOR<Demo_RequestsUpdateInput, Demo_RequestsUncheckedUpdateInput>
    /**
     * Choose, which Demo_Requests to update.
     */
    where: Demo_RequestsWhereUniqueInput
  }


  /**
   * Demo_Requests updateMany
   */
  export type Demo_RequestsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Demo_Requests.
     */
    data: XOR<Demo_RequestsUpdateManyMutationInput, Demo_RequestsUncheckedUpdateManyInput>
    /**
     * Filter which Demo_Requests to update
     */
    where?: Demo_RequestsWhereInput
  }


  /**
   * Demo_Requests upsert
   */
  export type Demo_RequestsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demo_Requests
     */
    select?: Demo_RequestsSelect<ExtArgs> | null
    /**
     * The filter to search for the Demo_Requests to update in case it exists.
     */
    where: Demo_RequestsWhereUniqueInput
    /**
     * In case the Demo_Requests found by the `where` argument doesn't exist, create a new Demo_Requests with this data.
     */
    create: XOR<Demo_RequestsCreateInput, Demo_RequestsUncheckedCreateInput>
    /**
     * In case the Demo_Requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Demo_RequestsUpdateInput, Demo_RequestsUncheckedUpdateInput>
  }


  /**
   * Demo_Requests delete
   */
  export type Demo_RequestsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demo_Requests
     */
    select?: Demo_RequestsSelect<ExtArgs> | null
    /**
     * Filter which Demo_Requests to delete.
     */
    where: Demo_RequestsWhereUniqueInput
  }


  /**
   * Demo_Requests deleteMany
   */
  export type Demo_RequestsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Demo_Requests to delete
     */
    where?: Demo_RequestsWhereInput
  }


  /**
   * Demo_Requests without action
   */
  export type Demo_RequestsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Demo_Requests
     */
    select?: Demo_RequestsSelect<ExtArgs> | null
  }



  /**
   * Model General_Inquiries
   */


  export type AggregateGeneral_Inquiries = {
    _count: General_InquiriesCountAggregateOutputType | null
    _min: General_InquiriesMinAggregateOutputType | null
    _max: General_InquiriesMaxAggregateOutputType | null
  }

  export type General_InquiriesMinAggregateOutputType = {
    record_id: string | null
    name: string | null
    email: string | null
    company: string | null
    message: string | null
    date_created: Date | null
  }

  export type General_InquiriesMaxAggregateOutputType = {
    record_id: string | null
    name: string | null
    email: string | null
    company: string | null
    message: string | null
    date_created: Date | null
  }

  export type General_InquiriesCountAggregateOutputType = {
    record_id: number
    name: number
    email: number
    company: number
    message: number
    date_created: number
    _all: number
  }


  export type General_InquiriesMinAggregateInputType = {
    record_id?: true
    name?: true
    email?: true
    company?: true
    message?: true
    date_created?: true
  }

  export type General_InquiriesMaxAggregateInputType = {
    record_id?: true
    name?: true
    email?: true
    company?: true
    message?: true
    date_created?: true
  }

  export type General_InquiriesCountAggregateInputType = {
    record_id?: true
    name?: true
    email?: true
    company?: true
    message?: true
    date_created?: true
    _all?: true
  }

  export type General_InquiriesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which General_Inquiries to aggregate.
     */
    where?: General_InquiriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of General_Inquiries to fetch.
     */
    orderBy?: Enumerable<General_InquiriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: General_InquiriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` General_Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` General_Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned General_Inquiries
    **/
    _count?: true | General_InquiriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: General_InquiriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: General_InquiriesMaxAggregateInputType
  }

  export type GetGeneral_InquiriesAggregateType<T extends General_InquiriesAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneral_Inquiries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneral_Inquiries[P]>
      : GetScalarType<T[P], AggregateGeneral_Inquiries[P]>
  }




  export type General_InquiriesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: General_InquiriesWhereInput
    orderBy?: Enumerable<General_InquiriesOrderByWithAggregationInput>
    by: General_InquiriesScalarFieldEnum[]
    having?: General_InquiriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: General_InquiriesCountAggregateInputType | true
    _min?: General_InquiriesMinAggregateInputType
    _max?: General_InquiriesMaxAggregateInputType
  }


  export type General_InquiriesGroupByOutputType = {
    record_id: string
    name: string | null
    email: string | null
    company: string | null
    message: string | null
    date_created: Date
    _count: General_InquiriesCountAggregateOutputType | null
    _min: General_InquiriesMinAggregateOutputType | null
    _max: General_InquiriesMaxAggregateOutputType | null
  }

  type GetGeneral_InquiriesGroupByPayload<T extends General_InquiriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<General_InquiriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof General_InquiriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], General_InquiriesGroupByOutputType[P]>
            : GetScalarType<T[P], General_InquiriesGroupByOutputType[P]>
        }
      >
    >


  export type General_InquiriesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    name?: boolean
    email?: boolean
    company?: boolean
    message?: boolean
    date_created?: boolean
  }, ExtArgs["result"]["general_Inquiries"]>

  export type General_InquiriesSelectScalar = {
    record_id?: boolean
    name?: boolean
    email?: boolean
    company?: boolean
    message?: boolean
    date_created?: boolean
  }


  type General_InquiriesGetPayload<S extends boolean | null | undefined | General_InquiriesArgs> = $Types.GetResult<General_InquiriesPayload, S>

  type General_InquiriesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<General_InquiriesFindManyArgs, 'select' | 'include'> & {
      select?: General_InquiriesCountAggregateInputType | true
    }

  export interface General_InquiriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['General_Inquiries'], meta: { name: 'General_Inquiries' } }
    /**
     * Find zero or one General_Inquiries that matches the filter.
     * @param {General_InquiriesFindUniqueArgs} args - Arguments to find a General_Inquiries
     * @example
     * // Get one General_Inquiries
     * const general_Inquiries = await prisma.general_Inquiries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends General_InquiriesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, General_InquiriesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'General_Inquiries'> extends True ? Prisma__General_InquiriesClient<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__General_InquiriesClient<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one General_Inquiries that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {General_InquiriesFindUniqueOrThrowArgs} args - Arguments to find a General_Inquiries
     * @example
     * // Get one General_Inquiries
     * const general_Inquiries = await prisma.general_Inquiries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends General_InquiriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, General_InquiriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__General_InquiriesClient<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first General_Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {General_InquiriesFindFirstArgs} args - Arguments to find a General_Inquiries
     * @example
     * // Get one General_Inquiries
     * const general_Inquiries = await prisma.general_Inquiries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends General_InquiriesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, General_InquiriesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'General_Inquiries'> extends True ? Prisma__General_InquiriesClient<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__General_InquiriesClient<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first General_Inquiries that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {General_InquiriesFindFirstOrThrowArgs} args - Arguments to find a General_Inquiries
     * @example
     * // Get one General_Inquiries
     * const general_Inquiries = await prisma.general_Inquiries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends General_InquiriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, General_InquiriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__General_InquiriesClient<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more General_Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {General_InquiriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all General_Inquiries
     * const general_Inquiries = await prisma.general_Inquiries.findMany()
     * 
     * // Get first 10 General_Inquiries
     * const general_Inquiries = await prisma.general_Inquiries.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const general_InquiriesWithRecord_idOnly = await prisma.general_Inquiries.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends General_InquiriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, General_InquiriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a General_Inquiries.
     * @param {General_InquiriesCreateArgs} args - Arguments to create a General_Inquiries.
     * @example
     * // Create one General_Inquiries
     * const General_Inquiries = await prisma.general_Inquiries.create({
     *   data: {
     *     // ... data to create a General_Inquiries
     *   }
     * })
     * 
    **/
    create<T extends General_InquiriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, General_InquiriesCreateArgs<ExtArgs>>
    ): Prisma__General_InquiriesClient<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many General_Inquiries.
     *     @param {General_InquiriesCreateManyArgs} args - Arguments to create many General_Inquiries.
     *     @example
     *     // Create many General_Inquiries
     *     const general_Inquiries = await prisma.general_Inquiries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends General_InquiriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, General_InquiriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a General_Inquiries.
     * @param {General_InquiriesDeleteArgs} args - Arguments to delete one General_Inquiries.
     * @example
     * // Delete one General_Inquiries
     * const General_Inquiries = await prisma.general_Inquiries.delete({
     *   where: {
     *     // ... filter to delete one General_Inquiries
     *   }
     * })
     * 
    **/
    delete<T extends General_InquiriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, General_InquiriesDeleteArgs<ExtArgs>>
    ): Prisma__General_InquiriesClient<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one General_Inquiries.
     * @param {General_InquiriesUpdateArgs} args - Arguments to update one General_Inquiries.
     * @example
     * // Update one General_Inquiries
     * const general_Inquiries = await prisma.general_Inquiries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends General_InquiriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, General_InquiriesUpdateArgs<ExtArgs>>
    ): Prisma__General_InquiriesClient<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more General_Inquiries.
     * @param {General_InquiriesDeleteManyArgs} args - Arguments to filter General_Inquiries to delete.
     * @example
     * // Delete a few General_Inquiries
     * const { count } = await prisma.general_Inquiries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends General_InquiriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, General_InquiriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more General_Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {General_InquiriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many General_Inquiries
     * const general_Inquiries = await prisma.general_Inquiries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends General_InquiriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, General_InquiriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one General_Inquiries.
     * @param {General_InquiriesUpsertArgs} args - Arguments to update or create a General_Inquiries.
     * @example
     * // Update or create a General_Inquiries
     * const general_Inquiries = await prisma.general_Inquiries.upsert({
     *   create: {
     *     // ... data to create a General_Inquiries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the General_Inquiries we want to update
     *   }
     * })
    **/
    upsert<T extends General_InquiriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, General_InquiriesUpsertArgs<ExtArgs>>
    ): Prisma__General_InquiriesClient<$Types.GetResult<General_InquiriesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of General_Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {General_InquiriesCountArgs} args - Arguments to filter General_Inquiries to count.
     * @example
     * // Count the number of General_Inquiries
     * const count = await prisma.general_Inquiries.count({
     *   where: {
     *     // ... the filter for the General_Inquiries we want to count
     *   }
     * })
    **/
    count<T extends General_InquiriesCountArgs>(
      args?: Subset<T, General_InquiriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], General_InquiriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a General_Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {General_InquiriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends General_InquiriesAggregateArgs>(args: Subset<T, General_InquiriesAggregateArgs>): Prisma.PrismaPromise<GetGeneral_InquiriesAggregateType<T>>

    /**
     * Group by General_Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {General_InquiriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends General_InquiriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: General_InquiriesGroupByArgs['orderBy'] }
        : { orderBy?: General_InquiriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, General_InquiriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneral_InquiriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for General_Inquiries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__General_InquiriesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * General_Inquiries base type for findUnique actions
   */
  export type General_InquiriesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the General_Inquiries
     */
    select?: General_InquiriesSelect<ExtArgs> | null
    /**
     * Filter, which General_Inquiries to fetch.
     */
    where: General_InquiriesWhereUniqueInput
  }

  /**
   * General_Inquiries findUnique
   */
  export interface General_InquiriesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends General_InquiriesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * General_Inquiries findUniqueOrThrow
   */
  export type General_InquiriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the General_Inquiries
     */
    select?: General_InquiriesSelect<ExtArgs> | null
    /**
     * Filter, which General_Inquiries to fetch.
     */
    where: General_InquiriesWhereUniqueInput
  }


  /**
   * General_Inquiries base type for findFirst actions
   */
  export type General_InquiriesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the General_Inquiries
     */
    select?: General_InquiriesSelect<ExtArgs> | null
    /**
     * Filter, which General_Inquiries to fetch.
     */
    where?: General_InquiriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of General_Inquiries to fetch.
     */
    orderBy?: Enumerable<General_InquiriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for General_Inquiries.
     */
    cursor?: General_InquiriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` General_Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` General_Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of General_Inquiries.
     */
    distinct?: Enumerable<General_InquiriesScalarFieldEnum>
  }

  /**
   * General_Inquiries findFirst
   */
  export interface General_InquiriesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends General_InquiriesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * General_Inquiries findFirstOrThrow
   */
  export type General_InquiriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the General_Inquiries
     */
    select?: General_InquiriesSelect<ExtArgs> | null
    /**
     * Filter, which General_Inquiries to fetch.
     */
    where?: General_InquiriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of General_Inquiries to fetch.
     */
    orderBy?: Enumerable<General_InquiriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for General_Inquiries.
     */
    cursor?: General_InquiriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` General_Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` General_Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of General_Inquiries.
     */
    distinct?: Enumerable<General_InquiriesScalarFieldEnum>
  }


  /**
   * General_Inquiries findMany
   */
  export type General_InquiriesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the General_Inquiries
     */
    select?: General_InquiriesSelect<ExtArgs> | null
    /**
     * Filter, which General_Inquiries to fetch.
     */
    where?: General_InquiriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of General_Inquiries to fetch.
     */
    orderBy?: Enumerable<General_InquiriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing General_Inquiries.
     */
    cursor?: General_InquiriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` General_Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` General_Inquiries.
     */
    skip?: number
    distinct?: Enumerable<General_InquiriesScalarFieldEnum>
  }


  /**
   * General_Inquiries create
   */
  export type General_InquiriesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the General_Inquiries
     */
    select?: General_InquiriesSelect<ExtArgs> | null
    /**
     * The data needed to create a General_Inquiries.
     */
    data?: XOR<General_InquiriesCreateInput, General_InquiriesUncheckedCreateInput>
  }


  /**
   * General_Inquiries createMany
   */
  export type General_InquiriesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many General_Inquiries.
     */
    data: Enumerable<General_InquiriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * General_Inquiries update
   */
  export type General_InquiriesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the General_Inquiries
     */
    select?: General_InquiriesSelect<ExtArgs> | null
    /**
     * The data needed to update a General_Inquiries.
     */
    data: XOR<General_InquiriesUpdateInput, General_InquiriesUncheckedUpdateInput>
    /**
     * Choose, which General_Inquiries to update.
     */
    where: General_InquiriesWhereUniqueInput
  }


  /**
   * General_Inquiries updateMany
   */
  export type General_InquiriesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update General_Inquiries.
     */
    data: XOR<General_InquiriesUpdateManyMutationInput, General_InquiriesUncheckedUpdateManyInput>
    /**
     * Filter which General_Inquiries to update
     */
    where?: General_InquiriesWhereInput
  }


  /**
   * General_Inquiries upsert
   */
  export type General_InquiriesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the General_Inquiries
     */
    select?: General_InquiriesSelect<ExtArgs> | null
    /**
     * The filter to search for the General_Inquiries to update in case it exists.
     */
    where: General_InquiriesWhereUniqueInput
    /**
     * In case the General_Inquiries found by the `where` argument doesn't exist, create a new General_Inquiries with this data.
     */
    create: XOR<General_InquiriesCreateInput, General_InquiriesUncheckedCreateInput>
    /**
     * In case the General_Inquiries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<General_InquiriesUpdateInput, General_InquiriesUncheckedUpdateInput>
  }


  /**
   * General_Inquiries delete
   */
  export type General_InquiriesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the General_Inquiries
     */
    select?: General_InquiriesSelect<ExtArgs> | null
    /**
     * Filter which General_Inquiries to delete.
     */
    where: General_InquiriesWhereUniqueInput
  }


  /**
   * General_Inquiries deleteMany
   */
  export type General_InquiriesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which General_Inquiries to delete
     */
    where?: General_InquiriesWhereInput
  }


  /**
   * General_Inquiries without action
   */
  export type General_InquiriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the General_Inquiries
     */
    select?: General_InquiriesSelect<ExtArgs> | null
  }



  /**
   * Model things_to_review
   */


  export type AggregateThings_to_review = {
    _count: Things_to_reviewCountAggregateOutputType | null
    _min: Things_to_reviewMinAggregateOutputType | null
    _max: Things_to_reviewMaxAggregateOutputType | null
  }

  export type Things_to_reviewMinAggregateOutputType = {
    record_id: string | null
    added_by: string | null
    table: string | null
    type: string | null
    thing_id: string | null
    information: string | null
    date_created: Date | null
  }

  export type Things_to_reviewMaxAggregateOutputType = {
    record_id: string | null
    added_by: string | null
    table: string | null
    type: string | null
    thing_id: string | null
    information: string | null
    date_created: Date | null
  }

  export type Things_to_reviewCountAggregateOutputType = {
    record_id: number
    added_by: number
    table: number
    type: number
    thing_id: number
    information: number
    date_created: number
    _all: number
  }


  export type Things_to_reviewMinAggregateInputType = {
    record_id?: true
    added_by?: true
    table?: true
    type?: true
    thing_id?: true
    information?: true
    date_created?: true
  }

  export type Things_to_reviewMaxAggregateInputType = {
    record_id?: true
    added_by?: true
    table?: true
    type?: true
    thing_id?: true
    information?: true
    date_created?: true
  }

  export type Things_to_reviewCountAggregateInputType = {
    record_id?: true
    added_by?: true
    table?: true
    type?: true
    thing_id?: true
    information?: true
    date_created?: true
    _all?: true
  }

  export type Things_to_reviewAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which things_to_review to aggregate.
     */
    where?: things_to_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of things_to_reviews to fetch.
     */
    orderBy?: Enumerable<things_to_reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: things_to_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` things_to_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` things_to_reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned things_to_reviews
    **/
    _count?: true | Things_to_reviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Things_to_reviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Things_to_reviewMaxAggregateInputType
  }

  export type GetThings_to_reviewAggregateType<T extends Things_to_reviewAggregateArgs> = {
        [P in keyof T & keyof AggregateThings_to_review]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThings_to_review[P]>
      : GetScalarType<T[P], AggregateThings_to_review[P]>
  }




  export type Things_to_reviewGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: things_to_reviewWhereInput
    orderBy?: Enumerable<things_to_reviewOrderByWithAggregationInput>
    by: Things_to_reviewScalarFieldEnum[]
    having?: things_to_reviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Things_to_reviewCountAggregateInputType | true
    _min?: Things_to_reviewMinAggregateInputType
    _max?: Things_to_reviewMaxAggregateInputType
  }


  export type Things_to_reviewGroupByOutputType = {
    record_id: string
    added_by: string
    table: string
    type: string
    thing_id: string | null
    information: string
    date_created: Date
    _count: Things_to_reviewCountAggregateOutputType | null
    _min: Things_to_reviewMinAggregateOutputType | null
    _max: Things_to_reviewMaxAggregateOutputType | null
  }

  type GetThings_to_reviewGroupByPayload<T extends Things_to_reviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Things_to_reviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Things_to_reviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Things_to_reviewGroupByOutputType[P]>
            : GetScalarType<T[P], Things_to_reviewGroupByOutputType[P]>
        }
      >
    >


  export type things_to_reviewSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    added_by?: boolean
    table?: boolean
    type?: boolean
    thing_id?: boolean
    information?: boolean
    date_created?: boolean
  }, ExtArgs["result"]["things_to_review"]>

  export type things_to_reviewSelectScalar = {
    record_id?: boolean
    added_by?: boolean
    table?: boolean
    type?: boolean
    thing_id?: boolean
    information?: boolean
    date_created?: boolean
  }


  type things_to_reviewGetPayload<S extends boolean | null | undefined | things_to_reviewArgs> = $Types.GetResult<things_to_reviewPayload, S>

  type things_to_reviewCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<things_to_reviewFindManyArgs, 'select' | 'include'> & {
      select?: Things_to_reviewCountAggregateInputType | true
    }

  export interface things_to_reviewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['things_to_review'], meta: { name: 'things_to_review' } }
    /**
     * Find zero or one Things_to_review that matches the filter.
     * @param {things_to_reviewFindUniqueArgs} args - Arguments to find a Things_to_review
     * @example
     * // Get one Things_to_review
     * const things_to_review = await prisma.things_to_review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends things_to_reviewFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, things_to_reviewFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'things_to_review'> extends True ? Prisma__things_to_reviewClient<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__things_to_reviewClient<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Things_to_review that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {things_to_reviewFindUniqueOrThrowArgs} args - Arguments to find a Things_to_review
     * @example
     * // Get one Things_to_review
     * const things_to_review = await prisma.things_to_review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends things_to_reviewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, things_to_reviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__things_to_reviewClient<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Things_to_review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {things_to_reviewFindFirstArgs} args - Arguments to find a Things_to_review
     * @example
     * // Get one Things_to_review
     * const things_to_review = await prisma.things_to_review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends things_to_reviewFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, things_to_reviewFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'things_to_review'> extends True ? Prisma__things_to_reviewClient<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__things_to_reviewClient<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Things_to_review that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {things_to_reviewFindFirstOrThrowArgs} args - Arguments to find a Things_to_review
     * @example
     * // Get one Things_to_review
     * const things_to_review = await prisma.things_to_review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends things_to_reviewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, things_to_reviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__things_to_reviewClient<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Things_to_reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {things_to_reviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Things_to_reviews
     * const things_to_reviews = await prisma.things_to_review.findMany()
     * 
     * // Get first 10 Things_to_reviews
     * const things_to_reviews = await prisma.things_to_review.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const things_to_reviewWithRecord_idOnly = await prisma.things_to_review.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends things_to_reviewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, things_to_reviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Things_to_review.
     * @param {things_to_reviewCreateArgs} args - Arguments to create a Things_to_review.
     * @example
     * // Create one Things_to_review
     * const Things_to_review = await prisma.things_to_review.create({
     *   data: {
     *     // ... data to create a Things_to_review
     *   }
     * })
     * 
    **/
    create<T extends things_to_reviewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, things_to_reviewCreateArgs<ExtArgs>>
    ): Prisma__things_to_reviewClient<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Things_to_reviews.
     *     @param {things_to_reviewCreateManyArgs} args - Arguments to create many Things_to_reviews.
     *     @example
     *     // Create many Things_to_reviews
     *     const things_to_review = await prisma.things_to_review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends things_to_reviewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, things_to_reviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Things_to_review.
     * @param {things_to_reviewDeleteArgs} args - Arguments to delete one Things_to_review.
     * @example
     * // Delete one Things_to_review
     * const Things_to_review = await prisma.things_to_review.delete({
     *   where: {
     *     // ... filter to delete one Things_to_review
     *   }
     * })
     * 
    **/
    delete<T extends things_to_reviewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, things_to_reviewDeleteArgs<ExtArgs>>
    ): Prisma__things_to_reviewClient<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Things_to_review.
     * @param {things_to_reviewUpdateArgs} args - Arguments to update one Things_to_review.
     * @example
     * // Update one Things_to_review
     * const things_to_review = await prisma.things_to_review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends things_to_reviewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, things_to_reviewUpdateArgs<ExtArgs>>
    ): Prisma__things_to_reviewClient<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Things_to_reviews.
     * @param {things_to_reviewDeleteManyArgs} args - Arguments to filter Things_to_reviews to delete.
     * @example
     * // Delete a few Things_to_reviews
     * const { count } = await prisma.things_to_review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends things_to_reviewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, things_to_reviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Things_to_reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {things_to_reviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Things_to_reviews
     * const things_to_review = await prisma.things_to_review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends things_to_reviewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, things_to_reviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Things_to_review.
     * @param {things_to_reviewUpsertArgs} args - Arguments to update or create a Things_to_review.
     * @example
     * // Update or create a Things_to_review
     * const things_to_review = await prisma.things_to_review.upsert({
     *   create: {
     *     // ... data to create a Things_to_review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Things_to_review we want to update
     *   }
     * })
    **/
    upsert<T extends things_to_reviewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, things_to_reviewUpsertArgs<ExtArgs>>
    ): Prisma__things_to_reviewClient<$Types.GetResult<things_to_reviewPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Things_to_reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {things_to_reviewCountArgs} args - Arguments to filter Things_to_reviews to count.
     * @example
     * // Count the number of Things_to_reviews
     * const count = await prisma.things_to_review.count({
     *   where: {
     *     // ... the filter for the Things_to_reviews we want to count
     *   }
     * })
    **/
    count<T extends things_to_reviewCountArgs>(
      args?: Subset<T, things_to_reviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Things_to_reviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Things_to_review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Things_to_reviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Things_to_reviewAggregateArgs>(args: Subset<T, Things_to_reviewAggregateArgs>): Prisma.PrismaPromise<GetThings_to_reviewAggregateType<T>>

    /**
     * Group by Things_to_review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Things_to_reviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Things_to_reviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Things_to_reviewGroupByArgs['orderBy'] }
        : { orderBy?: Things_to_reviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Things_to_reviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThings_to_reviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for things_to_review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__things_to_reviewClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * things_to_review base type for findUnique actions
   */
  export type things_to_reviewFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the things_to_review
     */
    select?: things_to_reviewSelect<ExtArgs> | null
    /**
     * Filter, which things_to_review to fetch.
     */
    where: things_to_reviewWhereUniqueInput
  }

  /**
   * things_to_review findUnique
   */
  export interface things_to_reviewFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends things_to_reviewFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * things_to_review findUniqueOrThrow
   */
  export type things_to_reviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the things_to_review
     */
    select?: things_to_reviewSelect<ExtArgs> | null
    /**
     * Filter, which things_to_review to fetch.
     */
    where: things_to_reviewWhereUniqueInput
  }


  /**
   * things_to_review base type for findFirst actions
   */
  export type things_to_reviewFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the things_to_review
     */
    select?: things_to_reviewSelect<ExtArgs> | null
    /**
     * Filter, which things_to_review to fetch.
     */
    where?: things_to_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of things_to_reviews to fetch.
     */
    orderBy?: Enumerable<things_to_reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for things_to_reviews.
     */
    cursor?: things_to_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` things_to_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` things_to_reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of things_to_reviews.
     */
    distinct?: Enumerable<Things_to_reviewScalarFieldEnum>
  }

  /**
   * things_to_review findFirst
   */
  export interface things_to_reviewFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends things_to_reviewFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * things_to_review findFirstOrThrow
   */
  export type things_to_reviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the things_to_review
     */
    select?: things_to_reviewSelect<ExtArgs> | null
    /**
     * Filter, which things_to_review to fetch.
     */
    where?: things_to_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of things_to_reviews to fetch.
     */
    orderBy?: Enumerable<things_to_reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for things_to_reviews.
     */
    cursor?: things_to_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` things_to_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` things_to_reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of things_to_reviews.
     */
    distinct?: Enumerable<Things_to_reviewScalarFieldEnum>
  }


  /**
   * things_to_review findMany
   */
  export type things_to_reviewFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the things_to_review
     */
    select?: things_to_reviewSelect<ExtArgs> | null
    /**
     * Filter, which things_to_reviews to fetch.
     */
    where?: things_to_reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of things_to_reviews to fetch.
     */
    orderBy?: Enumerable<things_to_reviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing things_to_reviews.
     */
    cursor?: things_to_reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` things_to_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` things_to_reviews.
     */
    skip?: number
    distinct?: Enumerable<Things_to_reviewScalarFieldEnum>
  }


  /**
   * things_to_review create
   */
  export type things_to_reviewCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the things_to_review
     */
    select?: things_to_reviewSelect<ExtArgs> | null
    /**
     * The data needed to create a things_to_review.
     */
    data: XOR<things_to_reviewCreateInput, things_to_reviewUncheckedCreateInput>
  }


  /**
   * things_to_review createMany
   */
  export type things_to_reviewCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many things_to_reviews.
     */
    data: Enumerable<things_to_reviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * things_to_review update
   */
  export type things_to_reviewUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the things_to_review
     */
    select?: things_to_reviewSelect<ExtArgs> | null
    /**
     * The data needed to update a things_to_review.
     */
    data: XOR<things_to_reviewUpdateInput, things_to_reviewUncheckedUpdateInput>
    /**
     * Choose, which things_to_review to update.
     */
    where: things_to_reviewWhereUniqueInput
  }


  /**
   * things_to_review updateMany
   */
  export type things_to_reviewUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update things_to_reviews.
     */
    data: XOR<things_to_reviewUpdateManyMutationInput, things_to_reviewUncheckedUpdateManyInput>
    /**
     * Filter which things_to_reviews to update
     */
    where?: things_to_reviewWhereInput
  }


  /**
   * things_to_review upsert
   */
  export type things_to_reviewUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the things_to_review
     */
    select?: things_to_reviewSelect<ExtArgs> | null
    /**
     * The filter to search for the things_to_review to update in case it exists.
     */
    where: things_to_reviewWhereUniqueInput
    /**
     * In case the things_to_review found by the `where` argument doesn't exist, create a new things_to_review with this data.
     */
    create: XOR<things_to_reviewCreateInput, things_to_reviewUncheckedCreateInput>
    /**
     * In case the things_to_review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<things_to_reviewUpdateInput, things_to_reviewUncheckedUpdateInput>
  }


  /**
   * things_to_review delete
   */
  export type things_to_reviewDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the things_to_review
     */
    select?: things_to_reviewSelect<ExtArgs> | null
    /**
     * Filter which things_to_review to delete.
     */
    where: things_to_reviewWhereUniqueInput
  }


  /**
   * things_to_review deleteMany
   */
  export type things_to_reviewDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which things_to_reviews to delete
     */
    where?: things_to_reviewWhereInput
  }


  /**
   * things_to_review without action
   */
  export type things_to_reviewArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the things_to_review
     */
    select?: things_to_reviewSelect<ExtArgs> | null
  }



  /**
   * Model External_Links
   */


  export type AggregateExternal_Links = {
    _count: External_LinksCountAggregateOutputType | null
    _min: External_LinksMinAggregateOutputType | null
    _max: External_LinksMaxAggregateOutputType | null
  }

  export type External_LinksMinAggregateOutputType = {
    record_id: string | null
    type: string | null
    url: string | null
    language: string | null
    date_created: Date | null
  }

  export type External_LinksMaxAggregateOutputType = {
    record_id: string | null
    type: string | null
    url: string | null
    language: string | null
    date_created: Date | null
  }

  export type External_LinksCountAggregateOutputType = {
    record_id: number
    type: number
    url: number
    language: number
    date_created: number
    _all: number
  }


  export type External_LinksMinAggregateInputType = {
    record_id?: true
    type?: true
    url?: true
    language?: true
    date_created?: true
  }

  export type External_LinksMaxAggregateInputType = {
    record_id?: true
    type?: true
    url?: true
    language?: true
    date_created?: true
  }

  export type External_LinksCountAggregateInputType = {
    record_id?: true
    type?: true
    url?: true
    language?: true
    date_created?: true
    _all?: true
  }

  export type External_LinksAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which External_Links to aggregate.
     */
    where?: External_LinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of External_Links to fetch.
     */
    orderBy?: Enumerable<External_LinksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: External_LinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` External_Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` External_Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned External_Links
    **/
    _count?: true | External_LinksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: External_LinksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: External_LinksMaxAggregateInputType
  }

  export type GetExternal_LinksAggregateType<T extends External_LinksAggregateArgs> = {
        [P in keyof T & keyof AggregateExternal_Links]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternal_Links[P]>
      : GetScalarType<T[P], AggregateExternal_Links[P]>
  }




  export type External_LinksGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: External_LinksWhereInput
    orderBy?: Enumerable<External_LinksOrderByWithAggregationInput>
    by: External_LinksScalarFieldEnum[]
    having?: External_LinksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: External_LinksCountAggregateInputType | true
    _min?: External_LinksMinAggregateInputType
    _max?: External_LinksMaxAggregateInputType
  }


  export type External_LinksGroupByOutputType = {
    record_id: string
    type: string
    url: string
    language: string | null
    date_created: Date
    _count: External_LinksCountAggregateOutputType | null
    _min: External_LinksMinAggregateOutputType | null
    _max: External_LinksMaxAggregateOutputType | null
  }

  type GetExternal_LinksGroupByPayload<T extends External_LinksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<External_LinksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof External_LinksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], External_LinksGroupByOutputType[P]>
            : GetScalarType<T[P], External_LinksGroupByOutputType[P]>
        }
      >
    >


  export type External_LinksSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    type?: boolean
    url?: boolean
    language?: boolean
    date_created?: boolean
  }, ExtArgs["result"]["external_Links"]>

  export type External_LinksSelectScalar = {
    record_id?: boolean
    type?: boolean
    url?: boolean
    language?: boolean
    date_created?: boolean
  }


  type External_LinksGetPayload<S extends boolean | null | undefined | External_LinksArgs> = $Types.GetResult<External_LinksPayload, S>

  type External_LinksCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<External_LinksFindManyArgs, 'select' | 'include'> & {
      select?: External_LinksCountAggregateInputType | true
    }

  export interface External_LinksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['External_Links'], meta: { name: 'External_Links' } }
    /**
     * Find zero or one External_Links that matches the filter.
     * @param {External_LinksFindUniqueArgs} args - Arguments to find a External_Links
     * @example
     * // Get one External_Links
     * const external_Links = await prisma.external_Links.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends External_LinksFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, External_LinksFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'External_Links'> extends True ? Prisma__External_LinksClient<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__External_LinksClient<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one External_Links that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {External_LinksFindUniqueOrThrowArgs} args - Arguments to find a External_Links
     * @example
     * // Get one External_Links
     * const external_Links = await prisma.external_Links.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends External_LinksFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, External_LinksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__External_LinksClient<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first External_Links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_LinksFindFirstArgs} args - Arguments to find a External_Links
     * @example
     * // Get one External_Links
     * const external_Links = await prisma.external_Links.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends External_LinksFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, External_LinksFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'External_Links'> extends True ? Prisma__External_LinksClient<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__External_LinksClient<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first External_Links that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_LinksFindFirstOrThrowArgs} args - Arguments to find a External_Links
     * @example
     * // Get one External_Links
     * const external_Links = await prisma.external_Links.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends External_LinksFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, External_LinksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__External_LinksClient<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more External_Links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_LinksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all External_Links
     * const external_Links = await prisma.external_Links.findMany()
     * 
     * // Get first 10 External_Links
     * const external_Links = await prisma.external_Links.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const external_LinksWithRecord_idOnly = await prisma.external_Links.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends External_LinksFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, External_LinksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a External_Links.
     * @param {External_LinksCreateArgs} args - Arguments to create a External_Links.
     * @example
     * // Create one External_Links
     * const External_Links = await prisma.external_Links.create({
     *   data: {
     *     // ... data to create a External_Links
     *   }
     * })
     * 
    **/
    create<T extends External_LinksCreateArgs<ExtArgs>>(
      args: SelectSubset<T, External_LinksCreateArgs<ExtArgs>>
    ): Prisma__External_LinksClient<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many External_Links.
     *     @param {External_LinksCreateManyArgs} args - Arguments to create many External_Links.
     *     @example
     *     // Create many External_Links
     *     const external_Links = await prisma.external_Links.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends External_LinksCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, External_LinksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a External_Links.
     * @param {External_LinksDeleteArgs} args - Arguments to delete one External_Links.
     * @example
     * // Delete one External_Links
     * const External_Links = await prisma.external_Links.delete({
     *   where: {
     *     // ... filter to delete one External_Links
     *   }
     * })
     * 
    **/
    delete<T extends External_LinksDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, External_LinksDeleteArgs<ExtArgs>>
    ): Prisma__External_LinksClient<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one External_Links.
     * @param {External_LinksUpdateArgs} args - Arguments to update one External_Links.
     * @example
     * // Update one External_Links
     * const external_Links = await prisma.external_Links.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends External_LinksUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, External_LinksUpdateArgs<ExtArgs>>
    ): Prisma__External_LinksClient<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more External_Links.
     * @param {External_LinksDeleteManyArgs} args - Arguments to filter External_Links to delete.
     * @example
     * // Delete a few External_Links
     * const { count } = await prisma.external_Links.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends External_LinksDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, External_LinksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more External_Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_LinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many External_Links
     * const external_Links = await prisma.external_Links.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends External_LinksUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, External_LinksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one External_Links.
     * @param {External_LinksUpsertArgs} args - Arguments to update or create a External_Links.
     * @example
     * // Update or create a External_Links
     * const external_Links = await prisma.external_Links.upsert({
     *   create: {
     *     // ... data to create a External_Links
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the External_Links we want to update
     *   }
     * })
    **/
    upsert<T extends External_LinksUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, External_LinksUpsertArgs<ExtArgs>>
    ): Prisma__External_LinksClient<$Types.GetResult<External_LinksPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of External_Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_LinksCountArgs} args - Arguments to filter External_Links to count.
     * @example
     * // Count the number of External_Links
     * const count = await prisma.external_Links.count({
     *   where: {
     *     // ... the filter for the External_Links we want to count
     *   }
     * })
    **/
    count<T extends External_LinksCountArgs>(
      args?: Subset<T, External_LinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], External_LinksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a External_Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_LinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends External_LinksAggregateArgs>(args: Subset<T, External_LinksAggregateArgs>): Prisma.PrismaPromise<GetExternal_LinksAggregateType<T>>

    /**
     * Group by External_Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {External_LinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends External_LinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: External_LinksGroupByArgs['orderBy'] }
        : { orderBy?: External_LinksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, External_LinksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternal_LinksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for External_Links.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__External_LinksClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * External_Links base type for findUnique actions
   */
  export type External_LinksFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_Links
     */
    select?: External_LinksSelect<ExtArgs> | null
    /**
     * Filter, which External_Links to fetch.
     */
    where: External_LinksWhereUniqueInput
  }

  /**
   * External_Links findUnique
   */
  export interface External_LinksFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends External_LinksFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * External_Links findUniqueOrThrow
   */
  export type External_LinksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_Links
     */
    select?: External_LinksSelect<ExtArgs> | null
    /**
     * Filter, which External_Links to fetch.
     */
    where: External_LinksWhereUniqueInput
  }


  /**
   * External_Links base type for findFirst actions
   */
  export type External_LinksFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_Links
     */
    select?: External_LinksSelect<ExtArgs> | null
    /**
     * Filter, which External_Links to fetch.
     */
    where?: External_LinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of External_Links to fetch.
     */
    orderBy?: Enumerable<External_LinksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for External_Links.
     */
    cursor?: External_LinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` External_Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` External_Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of External_Links.
     */
    distinct?: Enumerable<External_LinksScalarFieldEnum>
  }

  /**
   * External_Links findFirst
   */
  export interface External_LinksFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends External_LinksFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * External_Links findFirstOrThrow
   */
  export type External_LinksFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_Links
     */
    select?: External_LinksSelect<ExtArgs> | null
    /**
     * Filter, which External_Links to fetch.
     */
    where?: External_LinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of External_Links to fetch.
     */
    orderBy?: Enumerable<External_LinksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for External_Links.
     */
    cursor?: External_LinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` External_Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` External_Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of External_Links.
     */
    distinct?: Enumerable<External_LinksScalarFieldEnum>
  }


  /**
   * External_Links findMany
   */
  export type External_LinksFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_Links
     */
    select?: External_LinksSelect<ExtArgs> | null
    /**
     * Filter, which External_Links to fetch.
     */
    where?: External_LinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of External_Links to fetch.
     */
    orderBy?: Enumerable<External_LinksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing External_Links.
     */
    cursor?: External_LinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` External_Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` External_Links.
     */
    skip?: number
    distinct?: Enumerable<External_LinksScalarFieldEnum>
  }


  /**
   * External_Links create
   */
  export type External_LinksCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_Links
     */
    select?: External_LinksSelect<ExtArgs> | null
    /**
     * The data needed to create a External_Links.
     */
    data: XOR<External_LinksCreateInput, External_LinksUncheckedCreateInput>
  }


  /**
   * External_Links createMany
   */
  export type External_LinksCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many External_Links.
     */
    data: Enumerable<External_LinksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * External_Links update
   */
  export type External_LinksUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_Links
     */
    select?: External_LinksSelect<ExtArgs> | null
    /**
     * The data needed to update a External_Links.
     */
    data: XOR<External_LinksUpdateInput, External_LinksUncheckedUpdateInput>
    /**
     * Choose, which External_Links to update.
     */
    where: External_LinksWhereUniqueInput
  }


  /**
   * External_Links updateMany
   */
  export type External_LinksUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update External_Links.
     */
    data: XOR<External_LinksUpdateManyMutationInput, External_LinksUncheckedUpdateManyInput>
    /**
     * Filter which External_Links to update
     */
    where?: External_LinksWhereInput
  }


  /**
   * External_Links upsert
   */
  export type External_LinksUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_Links
     */
    select?: External_LinksSelect<ExtArgs> | null
    /**
     * The filter to search for the External_Links to update in case it exists.
     */
    where: External_LinksWhereUniqueInput
    /**
     * In case the External_Links found by the `where` argument doesn't exist, create a new External_Links with this data.
     */
    create: XOR<External_LinksCreateInput, External_LinksUncheckedCreateInput>
    /**
     * In case the External_Links was found with the provided `where` argument, update it with this data.
     */
    update: XOR<External_LinksUpdateInput, External_LinksUncheckedUpdateInput>
  }


  /**
   * External_Links delete
   */
  export type External_LinksDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_Links
     */
    select?: External_LinksSelect<ExtArgs> | null
    /**
     * Filter which External_Links to delete.
     */
    where: External_LinksWhereUniqueInput
  }


  /**
   * External_Links deleteMany
   */
  export type External_LinksDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which External_Links to delete
     */
    where?: External_LinksWhereInput
  }


  /**
   * External_Links without action
   */
  export type External_LinksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the External_Links
     */
    select?: External_LinksSelect<ExtArgs> | null
  }



  /**
   * Model supply_and_demand
   */


  export type AggregateSupply_and_demand = {
    _count: Supply_and_demandCountAggregateOutputType | null
    _avg: Supply_and_demandAvgAggregateOutputType | null
    _sum: Supply_and_demandSumAggregateOutputType | null
    _min: Supply_and_demandMinAggregateOutputType | null
    _max: Supply_and_demandMaxAggregateOutputType | null
  }

  export type Supply_and_demandAvgAggregateOutputType = {
    beginning_stocks_usda: Decimal | null
    beginning_stocks_eap: Decimal | null
    production_usda: Decimal | null
    production_eap: Decimal | null
    imports_usda: Decimal | null
    imports_eap: Decimal | null
    domestic_use_usda: Decimal | null
    domestic_use_eap: Decimal | null
    exports_usda: Decimal | null
    exports_eap: Decimal | null
    ending_stocks_usda: Decimal | null
    ending_stocks_eap: Decimal | null
  }

  export type Supply_and_demandSumAggregateOutputType = {
    beginning_stocks_usda: Decimal | null
    beginning_stocks_eap: Decimal | null
    production_usda: Decimal | null
    production_eap: Decimal | null
    imports_usda: Decimal | null
    imports_eap: Decimal | null
    domestic_use_usda: Decimal | null
    domestic_use_eap: Decimal | null
    exports_usda: Decimal | null
    exports_eap: Decimal | null
    ending_stocks_usda: Decimal | null
    ending_stocks_eap: Decimal | null
  }

  export type Supply_and_demandMinAggregateOutputType = {
    record_id: string | null
    date: Date | null
    season: string | null
    country: string | null
    beginning_stocks_usda: Decimal | null
    beginning_stocks_eap: Decimal | null
    production_usda: Decimal | null
    production_eap: Decimal | null
    imports_usda: Decimal | null
    imports_eap: Decimal | null
    domestic_use_usda: Decimal | null
    domestic_use_eap: Decimal | null
    exports_usda: Decimal | null
    exports_eap: Decimal | null
    ending_stocks_usda: Decimal | null
    ending_stocks_eap: Decimal | null
    projected: boolean | null
  }

  export type Supply_and_demandMaxAggregateOutputType = {
    record_id: string | null
    date: Date | null
    season: string | null
    country: string | null
    beginning_stocks_usda: Decimal | null
    beginning_stocks_eap: Decimal | null
    production_usda: Decimal | null
    production_eap: Decimal | null
    imports_usda: Decimal | null
    imports_eap: Decimal | null
    domestic_use_usda: Decimal | null
    domestic_use_eap: Decimal | null
    exports_usda: Decimal | null
    exports_eap: Decimal | null
    ending_stocks_usda: Decimal | null
    ending_stocks_eap: Decimal | null
    projected: boolean | null
  }

  export type Supply_and_demandCountAggregateOutputType = {
    record_id: number
    date: number
    season: number
    country: number
    beginning_stocks_usda: number
    beginning_stocks_eap: number
    production_usda: number
    production_eap: number
    imports_usda: number
    imports_eap: number
    domestic_use_usda: number
    domestic_use_eap: number
    exports_usda: number
    exports_eap: number
    ending_stocks_usda: number
    ending_stocks_eap: number
    projected: number
    _all: number
  }


  export type Supply_and_demandAvgAggregateInputType = {
    beginning_stocks_usda?: true
    beginning_stocks_eap?: true
    production_usda?: true
    production_eap?: true
    imports_usda?: true
    imports_eap?: true
    domestic_use_usda?: true
    domestic_use_eap?: true
    exports_usda?: true
    exports_eap?: true
    ending_stocks_usda?: true
    ending_stocks_eap?: true
  }

  export type Supply_and_demandSumAggregateInputType = {
    beginning_stocks_usda?: true
    beginning_stocks_eap?: true
    production_usda?: true
    production_eap?: true
    imports_usda?: true
    imports_eap?: true
    domestic_use_usda?: true
    domestic_use_eap?: true
    exports_usda?: true
    exports_eap?: true
    ending_stocks_usda?: true
    ending_stocks_eap?: true
  }

  export type Supply_and_demandMinAggregateInputType = {
    record_id?: true
    date?: true
    season?: true
    country?: true
    beginning_stocks_usda?: true
    beginning_stocks_eap?: true
    production_usda?: true
    production_eap?: true
    imports_usda?: true
    imports_eap?: true
    domestic_use_usda?: true
    domestic_use_eap?: true
    exports_usda?: true
    exports_eap?: true
    ending_stocks_usda?: true
    ending_stocks_eap?: true
    projected?: true
  }

  export type Supply_and_demandMaxAggregateInputType = {
    record_id?: true
    date?: true
    season?: true
    country?: true
    beginning_stocks_usda?: true
    beginning_stocks_eap?: true
    production_usda?: true
    production_eap?: true
    imports_usda?: true
    imports_eap?: true
    domestic_use_usda?: true
    domestic_use_eap?: true
    exports_usda?: true
    exports_eap?: true
    ending_stocks_usda?: true
    ending_stocks_eap?: true
    projected?: true
  }

  export type Supply_and_demandCountAggregateInputType = {
    record_id?: true
    date?: true
    season?: true
    country?: true
    beginning_stocks_usda?: true
    beginning_stocks_eap?: true
    production_usda?: true
    production_eap?: true
    imports_usda?: true
    imports_eap?: true
    domestic_use_usda?: true
    domestic_use_eap?: true
    exports_usda?: true
    exports_eap?: true
    ending_stocks_usda?: true
    ending_stocks_eap?: true
    projected?: true
    _all?: true
  }

  export type Supply_and_demandAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which supply_and_demand to aggregate.
     */
    where?: supply_and_demandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supply_and_demands to fetch.
     */
    orderBy?: Enumerable<supply_and_demandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supply_and_demandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supply_and_demands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supply_and_demands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned supply_and_demands
    **/
    _count?: true | Supply_and_demandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Supply_and_demandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Supply_and_demandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Supply_and_demandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Supply_and_demandMaxAggregateInputType
  }

  export type GetSupply_and_demandAggregateType<T extends Supply_and_demandAggregateArgs> = {
        [P in keyof T & keyof AggregateSupply_and_demand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupply_and_demand[P]>
      : GetScalarType<T[P], AggregateSupply_and_demand[P]>
  }




  export type Supply_and_demandGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: supply_and_demandWhereInput
    orderBy?: Enumerable<supply_and_demandOrderByWithAggregationInput>
    by: Supply_and_demandScalarFieldEnum[]
    having?: supply_and_demandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Supply_and_demandCountAggregateInputType | true
    _avg?: Supply_and_demandAvgAggregateInputType
    _sum?: Supply_and_demandSumAggregateInputType
    _min?: Supply_and_demandMinAggregateInputType
    _max?: Supply_and_demandMaxAggregateInputType
  }


  export type Supply_and_demandGroupByOutputType = {
    record_id: string
    date: Date
    season: string | null
    country: string | null
    beginning_stocks_usda: Decimal | null
    beginning_stocks_eap: Decimal | null
    production_usda: Decimal | null
    production_eap: Decimal | null
    imports_usda: Decimal | null
    imports_eap: Decimal | null
    domestic_use_usda: Decimal | null
    domestic_use_eap: Decimal | null
    exports_usda: Decimal | null
    exports_eap: Decimal | null
    ending_stocks_usda: Decimal | null
    ending_stocks_eap: Decimal | null
    projected: boolean | null
    _count: Supply_and_demandCountAggregateOutputType | null
    _avg: Supply_and_demandAvgAggregateOutputType | null
    _sum: Supply_and_demandSumAggregateOutputType | null
    _min: Supply_and_demandMinAggregateOutputType | null
    _max: Supply_and_demandMaxAggregateOutputType | null
  }

  type GetSupply_and_demandGroupByPayload<T extends Supply_and_demandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Supply_and_demandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Supply_and_demandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Supply_and_demandGroupByOutputType[P]>
            : GetScalarType<T[P], Supply_and_demandGroupByOutputType[P]>
        }
      >
    >


  export type supply_and_demandSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    date?: boolean
    season?: boolean
    country?: boolean
    beginning_stocks_usda?: boolean
    beginning_stocks_eap?: boolean
    production_usda?: boolean
    production_eap?: boolean
    imports_usda?: boolean
    imports_eap?: boolean
    domestic_use_usda?: boolean
    domestic_use_eap?: boolean
    exports_usda?: boolean
    exports_eap?: boolean
    ending_stocks_usda?: boolean
    ending_stocks_eap?: boolean
    projected?: boolean
  }, ExtArgs["result"]["supply_and_demand"]>

  export type supply_and_demandSelectScalar = {
    record_id?: boolean
    date?: boolean
    season?: boolean
    country?: boolean
    beginning_stocks_usda?: boolean
    beginning_stocks_eap?: boolean
    production_usda?: boolean
    production_eap?: boolean
    imports_usda?: boolean
    imports_eap?: boolean
    domestic_use_usda?: boolean
    domestic_use_eap?: boolean
    exports_usda?: boolean
    exports_eap?: boolean
    ending_stocks_usda?: boolean
    ending_stocks_eap?: boolean
    projected?: boolean
  }


  type supply_and_demandGetPayload<S extends boolean | null | undefined | supply_and_demandArgs> = $Types.GetResult<supply_and_demandPayload, S>

  type supply_and_demandCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<supply_and_demandFindManyArgs, 'select' | 'include'> & {
      select?: Supply_and_demandCountAggregateInputType | true
    }

  export interface supply_and_demandDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supply_and_demand'], meta: { name: 'supply_and_demand' } }
    /**
     * Find zero or one Supply_and_demand that matches the filter.
     * @param {supply_and_demandFindUniqueArgs} args - Arguments to find a Supply_and_demand
     * @example
     * // Get one Supply_and_demand
     * const supply_and_demand = await prisma.supply_and_demand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends supply_and_demandFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, supply_and_demandFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'supply_and_demand'> extends True ? Prisma__supply_and_demandClient<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__supply_and_demandClient<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Supply_and_demand that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {supply_and_demandFindUniqueOrThrowArgs} args - Arguments to find a Supply_and_demand
     * @example
     * // Get one Supply_and_demand
     * const supply_and_demand = await prisma.supply_and_demand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends supply_and_demandFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, supply_and_demandFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__supply_and_demandClient<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Supply_and_demand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supply_and_demandFindFirstArgs} args - Arguments to find a Supply_and_demand
     * @example
     * // Get one Supply_and_demand
     * const supply_and_demand = await prisma.supply_and_demand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends supply_and_demandFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, supply_and_demandFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'supply_and_demand'> extends True ? Prisma__supply_and_demandClient<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__supply_and_demandClient<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Supply_and_demand that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supply_and_demandFindFirstOrThrowArgs} args - Arguments to find a Supply_and_demand
     * @example
     * // Get one Supply_and_demand
     * const supply_and_demand = await prisma.supply_and_demand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends supply_and_demandFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, supply_and_demandFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__supply_and_demandClient<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Supply_and_demands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supply_and_demandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supply_and_demands
     * const supply_and_demands = await prisma.supply_and_demand.findMany()
     * 
     * // Get first 10 Supply_and_demands
     * const supply_and_demands = await prisma.supply_and_demand.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const supply_and_demandWithRecord_idOnly = await prisma.supply_and_demand.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends supply_and_demandFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supply_and_demandFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Supply_and_demand.
     * @param {supply_and_demandCreateArgs} args - Arguments to create a Supply_and_demand.
     * @example
     * // Create one Supply_and_demand
     * const Supply_and_demand = await prisma.supply_and_demand.create({
     *   data: {
     *     // ... data to create a Supply_and_demand
     *   }
     * })
     * 
    **/
    create<T extends supply_and_demandCreateArgs<ExtArgs>>(
      args: SelectSubset<T, supply_and_demandCreateArgs<ExtArgs>>
    ): Prisma__supply_and_demandClient<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Supply_and_demands.
     *     @param {supply_and_demandCreateManyArgs} args - Arguments to create many Supply_and_demands.
     *     @example
     *     // Create many Supply_and_demands
     *     const supply_and_demand = await prisma.supply_and_demand.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends supply_and_demandCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supply_and_demandCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supply_and_demand.
     * @param {supply_and_demandDeleteArgs} args - Arguments to delete one Supply_and_demand.
     * @example
     * // Delete one Supply_and_demand
     * const Supply_and_demand = await prisma.supply_and_demand.delete({
     *   where: {
     *     // ... filter to delete one Supply_and_demand
     *   }
     * })
     * 
    **/
    delete<T extends supply_and_demandDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, supply_and_demandDeleteArgs<ExtArgs>>
    ): Prisma__supply_and_demandClient<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Supply_and_demand.
     * @param {supply_and_demandUpdateArgs} args - Arguments to update one Supply_and_demand.
     * @example
     * // Update one Supply_and_demand
     * const supply_and_demand = await prisma.supply_and_demand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends supply_and_demandUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, supply_and_demandUpdateArgs<ExtArgs>>
    ): Prisma__supply_and_demandClient<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Supply_and_demands.
     * @param {supply_and_demandDeleteManyArgs} args - Arguments to filter Supply_and_demands to delete.
     * @example
     * // Delete a few Supply_and_demands
     * const { count } = await prisma.supply_and_demand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends supply_and_demandDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, supply_and_demandDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supply_and_demands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supply_and_demandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supply_and_demands
     * const supply_and_demand = await prisma.supply_and_demand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends supply_and_demandUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, supply_and_demandUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supply_and_demand.
     * @param {supply_and_demandUpsertArgs} args - Arguments to update or create a Supply_and_demand.
     * @example
     * // Update or create a Supply_and_demand
     * const supply_and_demand = await prisma.supply_and_demand.upsert({
     *   create: {
     *     // ... data to create a Supply_and_demand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supply_and_demand we want to update
     *   }
     * })
    **/
    upsert<T extends supply_and_demandUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, supply_and_demandUpsertArgs<ExtArgs>>
    ): Prisma__supply_and_demandClient<$Types.GetResult<supply_and_demandPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Supply_and_demands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supply_and_demandCountArgs} args - Arguments to filter Supply_and_demands to count.
     * @example
     * // Count the number of Supply_and_demands
     * const count = await prisma.supply_and_demand.count({
     *   where: {
     *     // ... the filter for the Supply_and_demands we want to count
     *   }
     * })
    **/
    count<T extends supply_and_demandCountArgs>(
      args?: Subset<T, supply_and_demandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Supply_and_demandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supply_and_demand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Supply_and_demandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Supply_and_demandAggregateArgs>(args: Subset<T, Supply_and_demandAggregateArgs>): Prisma.PrismaPromise<GetSupply_and_demandAggregateType<T>>

    /**
     * Group by Supply_and_demand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Supply_and_demandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Supply_and_demandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Supply_and_demandGroupByArgs['orderBy'] }
        : { orderBy?: Supply_and_demandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Supply_and_demandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupply_and_demandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for supply_and_demand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__supply_and_demandClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * supply_and_demand base type for findUnique actions
   */
  export type supply_and_demandFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supply_and_demand
     */
    select?: supply_and_demandSelect<ExtArgs> | null
    /**
     * Filter, which supply_and_demand to fetch.
     */
    where: supply_and_demandWhereUniqueInput
  }

  /**
   * supply_and_demand findUnique
   */
  export interface supply_and_demandFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends supply_and_demandFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * supply_and_demand findUniqueOrThrow
   */
  export type supply_and_demandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supply_and_demand
     */
    select?: supply_and_demandSelect<ExtArgs> | null
    /**
     * Filter, which supply_and_demand to fetch.
     */
    where: supply_and_demandWhereUniqueInput
  }


  /**
   * supply_and_demand base type for findFirst actions
   */
  export type supply_and_demandFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supply_and_demand
     */
    select?: supply_and_demandSelect<ExtArgs> | null
    /**
     * Filter, which supply_and_demand to fetch.
     */
    where?: supply_and_demandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supply_and_demands to fetch.
     */
    orderBy?: Enumerable<supply_and_demandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supply_and_demands.
     */
    cursor?: supply_and_demandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supply_and_demands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supply_and_demands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supply_and_demands.
     */
    distinct?: Enumerable<Supply_and_demandScalarFieldEnum>
  }

  /**
   * supply_and_demand findFirst
   */
  export interface supply_and_demandFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends supply_and_demandFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * supply_and_demand findFirstOrThrow
   */
  export type supply_and_demandFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supply_and_demand
     */
    select?: supply_and_demandSelect<ExtArgs> | null
    /**
     * Filter, which supply_and_demand to fetch.
     */
    where?: supply_and_demandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supply_and_demands to fetch.
     */
    orderBy?: Enumerable<supply_and_demandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supply_and_demands.
     */
    cursor?: supply_and_demandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supply_and_demands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supply_and_demands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supply_and_demands.
     */
    distinct?: Enumerable<Supply_and_demandScalarFieldEnum>
  }


  /**
   * supply_and_demand findMany
   */
  export type supply_and_demandFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supply_and_demand
     */
    select?: supply_and_demandSelect<ExtArgs> | null
    /**
     * Filter, which supply_and_demands to fetch.
     */
    where?: supply_and_demandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supply_and_demands to fetch.
     */
    orderBy?: Enumerable<supply_and_demandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing supply_and_demands.
     */
    cursor?: supply_and_demandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supply_and_demands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supply_and_demands.
     */
    skip?: number
    distinct?: Enumerable<Supply_and_demandScalarFieldEnum>
  }


  /**
   * supply_and_demand create
   */
  export type supply_and_demandCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supply_and_demand
     */
    select?: supply_and_demandSelect<ExtArgs> | null
    /**
     * The data needed to create a supply_and_demand.
     */
    data: XOR<supply_and_demandCreateInput, supply_and_demandUncheckedCreateInput>
  }


  /**
   * supply_and_demand createMany
   */
  export type supply_and_demandCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many supply_and_demands.
     */
    data: Enumerable<supply_and_demandCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * supply_and_demand update
   */
  export type supply_and_demandUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supply_and_demand
     */
    select?: supply_and_demandSelect<ExtArgs> | null
    /**
     * The data needed to update a supply_and_demand.
     */
    data: XOR<supply_and_demandUpdateInput, supply_and_demandUncheckedUpdateInput>
    /**
     * Choose, which supply_and_demand to update.
     */
    where: supply_and_demandWhereUniqueInput
  }


  /**
   * supply_and_demand updateMany
   */
  export type supply_and_demandUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update supply_and_demands.
     */
    data: XOR<supply_and_demandUpdateManyMutationInput, supply_and_demandUncheckedUpdateManyInput>
    /**
     * Filter which supply_and_demands to update
     */
    where?: supply_and_demandWhereInput
  }


  /**
   * supply_and_demand upsert
   */
  export type supply_and_demandUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supply_and_demand
     */
    select?: supply_and_demandSelect<ExtArgs> | null
    /**
     * The filter to search for the supply_and_demand to update in case it exists.
     */
    where: supply_and_demandWhereUniqueInput
    /**
     * In case the supply_and_demand found by the `where` argument doesn't exist, create a new supply_and_demand with this data.
     */
    create: XOR<supply_and_demandCreateInput, supply_and_demandUncheckedCreateInput>
    /**
     * In case the supply_and_demand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supply_and_demandUpdateInput, supply_and_demandUncheckedUpdateInput>
  }


  /**
   * supply_and_demand delete
   */
  export type supply_and_demandDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supply_and_demand
     */
    select?: supply_and_demandSelect<ExtArgs> | null
    /**
     * Filter which supply_and_demand to delete.
     */
    where: supply_and_demandWhereUniqueInput
  }


  /**
   * supply_and_demand deleteMany
   */
  export type supply_and_demandDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which supply_and_demands to delete
     */
    where?: supply_and_demandWhereInput
  }


  /**
   * supply_and_demand without action
   */
  export type supply_and_demandArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supply_and_demand
     */
    select?: supply_and_demandSelect<ExtArgs> | null
  }



  /**
   * Model us_export_sales
   */


  export type AggregateUs_export_sales = {
    _count: Us_export_salesCountAggregateOutputType | null
    _avg: Us_export_salesAvgAggregateOutputType | null
    _sum: Us_export_salesSumAggregateOutputType | null
    _min: Us_export_salesMinAggregateOutputType | null
    _max: Us_export_salesMaxAggregateOutputType | null
  }

  export type Us_export_salesAvgAggregateOutputType = {
    weekly_exports: number | null
    accumulated_exports: number | null
    net_sales: number | null
    outstanding_sales: number | null
    next_marketing_year_net_sales: number | null
    next_marketing_year_outstanding_sales: number | null
  }

  export type Us_export_salesSumAggregateOutputType = {
    weekly_exports: number | null
    accumulated_exports: number | null
    net_sales: number | null
    outstanding_sales: number | null
    next_marketing_year_net_sales: number | null
    next_marketing_year_outstanding_sales: number | null
  }

  export type Us_export_salesMinAggregateOutputType = {
    record_id: string | null
    week_ending: Date | null
    weekly_exports: number | null
    accumulated_exports: number | null
    net_sales: number | null
    outstanding_sales: number | null
    next_marketing_year_net_sales: number | null
    next_marketing_year_outstanding_sales: number | null
  }

  export type Us_export_salesMaxAggregateOutputType = {
    record_id: string | null
    week_ending: Date | null
    weekly_exports: number | null
    accumulated_exports: number | null
    net_sales: number | null
    outstanding_sales: number | null
    next_marketing_year_net_sales: number | null
    next_marketing_year_outstanding_sales: number | null
  }

  export type Us_export_salesCountAggregateOutputType = {
    record_id: number
    week_ending: number
    weekly_exports: number
    accumulated_exports: number
    net_sales: number
    outstanding_sales: number
    next_marketing_year_net_sales: number
    next_marketing_year_outstanding_sales: number
    _all: number
  }


  export type Us_export_salesAvgAggregateInputType = {
    weekly_exports?: true
    accumulated_exports?: true
    net_sales?: true
    outstanding_sales?: true
    next_marketing_year_net_sales?: true
    next_marketing_year_outstanding_sales?: true
  }

  export type Us_export_salesSumAggregateInputType = {
    weekly_exports?: true
    accumulated_exports?: true
    net_sales?: true
    outstanding_sales?: true
    next_marketing_year_net_sales?: true
    next_marketing_year_outstanding_sales?: true
  }

  export type Us_export_salesMinAggregateInputType = {
    record_id?: true
    week_ending?: true
    weekly_exports?: true
    accumulated_exports?: true
    net_sales?: true
    outstanding_sales?: true
    next_marketing_year_net_sales?: true
    next_marketing_year_outstanding_sales?: true
  }

  export type Us_export_salesMaxAggregateInputType = {
    record_id?: true
    week_ending?: true
    weekly_exports?: true
    accumulated_exports?: true
    net_sales?: true
    outstanding_sales?: true
    next_marketing_year_net_sales?: true
    next_marketing_year_outstanding_sales?: true
  }

  export type Us_export_salesCountAggregateInputType = {
    record_id?: true
    week_ending?: true
    weekly_exports?: true
    accumulated_exports?: true
    net_sales?: true
    outstanding_sales?: true
    next_marketing_year_net_sales?: true
    next_marketing_year_outstanding_sales?: true
    _all?: true
  }

  export type Us_export_salesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which us_export_sales to aggregate.
     */
    where?: us_export_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of us_export_sales to fetch.
     */
    orderBy?: Enumerable<us_export_salesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: us_export_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` us_export_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` us_export_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned us_export_sales
    **/
    _count?: true | Us_export_salesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Us_export_salesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Us_export_salesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Us_export_salesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Us_export_salesMaxAggregateInputType
  }

  export type GetUs_export_salesAggregateType<T extends Us_export_salesAggregateArgs> = {
        [P in keyof T & keyof AggregateUs_export_sales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUs_export_sales[P]>
      : GetScalarType<T[P], AggregateUs_export_sales[P]>
  }




  export type Us_export_salesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: us_export_salesWhereInput
    orderBy?: Enumerable<us_export_salesOrderByWithAggregationInput>
    by: Us_export_salesScalarFieldEnum[]
    having?: us_export_salesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Us_export_salesCountAggregateInputType | true
    _avg?: Us_export_salesAvgAggregateInputType
    _sum?: Us_export_salesSumAggregateInputType
    _min?: Us_export_salesMinAggregateInputType
    _max?: Us_export_salesMaxAggregateInputType
  }


  export type Us_export_salesGroupByOutputType = {
    record_id: string
    week_ending: Date
    weekly_exports: number | null
    accumulated_exports: number | null
    net_sales: number | null
    outstanding_sales: number | null
    next_marketing_year_net_sales: number | null
    next_marketing_year_outstanding_sales: number | null
    _count: Us_export_salesCountAggregateOutputType | null
    _avg: Us_export_salesAvgAggregateOutputType | null
    _sum: Us_export_salesSumAggregateOutputType | null
    _min: Us_export_salesMinAggregateOutputType | null
    _max: Us_export_salesMaxAggregateOutputType | null
  }

  type GetUs_export_salesGroupByPayload<T extends Us_export_salesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Us_export_salesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Us_export_salesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Us_export_salesGroupByOutputType[P]>
            : GetScalarType<T[P], Us_export_salesGroupByOutputType[P]>
        }
      >
    >


  export type us_export_salesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    week_ending?: boolean
    weekly_exports?: boolean
    accumulated_exports?: boolean
    net_sales?: boolean
    outstanding_sales?: boolean
    next_marketing_year_net_sales?: boolean
    next_marketing_year_outstanding_sales?: boolean
  }, ExtArgs["result"]["us_export_sales"]>

  export type us_export_salesSelectScalar = {
    record_id?: boolean
    week_ending?: boolean
    weekly_exports?: boolean
    accumulated_exports?: boolean
    net_sales?: boolean
    outstanding_sales?: boolean
    next_marketing_year_net_sales?: boolean
    next_marketing_year_outstanding_sales?: boolean
  }


  type us_export_salesGetPayload<S extends boolean | null | undefined | us_export_salesArgs> = $Types.GetResult<us_export_salesPayload, S>

  type us_export_salesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<us_export_salesFindManyArgs, 'select' | 'include'> & {
      select?: Us_export_salesCountAggregateInputType | true
    }

  export interface us_export_salesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['us_export_sales'], meta: { name: 'us_export_sales' } }
    /**
     * Find zero or one Us_export_sales that matches the filter.
     * @param {us_export_salesFindUniqueArgs} args - Arguments to find a Us_export_sales
     * @example
     * // Get one Us_export_sales
     * const us_export_sales = await prisma.us_export_sales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends us_export_salesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, us_export_salesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'us_export_sales'> extends True ? Prisma__us_export_salesClient<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__us_export_salesClient<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Us_export_sales that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {us_export_salesFindUniqueOrThrowArgs} args - Arguments to find a Us_export_sales
     * @example
     * // Get one Us_export_sales
     * const us_export_sales = await prisma.us_export_sales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends us_export_salesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, us_export_salesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__us_export_salesClient<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Us_export_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {us_export_salesFindFirstArgs} args - Arguments to find a Us_export_sales
     * @example
     * // Get one Us_export_sales
     * const us_export_sales = await prisma.us_export_sales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends us_export_salesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, us_export_salesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'us_export_sales'> extends True ? Prisma__us_export_salesClient<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__us_export_salesClient<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Us_export_sales that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {us_export_salesFindFirstOrThrowArgs} args - Arguments to find a Us_export_sales
     * @example
     * // Get one Us_export_sales
     * const us_export_sales = await prisma.us_export_sales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends us_export_salesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, us_export_salesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__us_export_salesClient<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Us_export_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {us_export_salesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Us_export_sales
     * const us_export_sales = await prisma.us_export_sales.findMany()
     * 
     * // Get first 10 Us_export_sales
     * const us_export_sales = await prisma.us_export_sales.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const us_export_salesWithRecord_idOnly = await prisma.us_export_sales.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends us_export_salesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, us_export_salesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Us_export_sales.
     * @param {us_export_salesCreateArgs} args - Arguments to create a Us_export_sales.
     * @example
     * // Create one Us_export_sales
     * const Us_export_sales = await prisma.us_export_sales.create({
     *   data: {
     *     // ... data to create a Us_export_sales
     *   }
     * })
     * 
    **/
    create<T extends us_export_salesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, us_export_salesCreateArgs<ExtArgs>>
    ): Prisma__us_export_salesClient<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Us_export_sales.
     *     @param {us_export_salesCreateManyArgs} args - Arguments to create many Us_export_sales.
     *     @example
     *     // Create many Us_export_sales
     *     const us_export_sales = await prisma.us_export_sales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends us_export_salesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, us_export_salesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Us_export_sales.
     * @param {us_export_salesDeleteArgs} args - Arguments to delete one Us_export_sales.
     * @example
     * // Delete one Us_export_sales
     * const Us_export_sales = await prisma.us_export_sales.delete({
     *   where: {
     *     // ... filter to delete one Us_export_sales
     *   }
     * })
     * 
    **/
    delete<T extends us_export_salesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, us_export_salesDeleteArgs<ExtArgs>>
    ): Prisma__us_export_salesClient<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Us_export_sales.
     * @param {us_export_salesUpdateArgs} args - Arguments to update one Us_export_sales.
     * @example
     * // Update one Us_export_sales
     * const us_export_sales = await prisma.us_export_sales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends us_export_salesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, us_export_salesUpdateArgs<ExtArgs>>
    ): Prisma__us_export_salesClient<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Us_export_sales.
     * @param {us_export_salesDeleteManyArgs} args - Arguments to filter Us_export_sales to delete.
     * @example
     * // Delete a few Us_export_sales
     * const { count } = await prisma.us_export_sales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends us_export_salesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, us_export_salesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Us_export_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {us_export_salesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Us_export_sales
     * const us_export_sales = await prisma.us_export_sales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends us_export_salesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, us_export_salesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Us_export_sales.
     * @param {us_export_salesUpsertArgs} args - Arguments to update or create a Us_export_sales.
     * @example
     * // Update or create a Us_export_sales
     * const us_export_sales = await prisma.us_export_sales.upsert({
     *   create: {
     *     // ... data to create a Us_export_sales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Us_export_sales we want to update
     *   }
     * })
    **/
    upsert<T extends us_export_salesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, us_export_salesUpsertArgs<ExtArgs>>
    ): Prisma__us_export_salesClient<$Types.GetResult<us_export_salesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Us_export_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {us_export_salesCountArgs} args - Arguments to filter Us_export_sales to count.
     * @example
     * // Count the number of Us_export_sales
     * const count = await prisma.us_export_sales.count({
     *   where: {
     *     // ... the filter for the Us_export_sales we want to count
     *   }
     * })
    **/
    count<T extends us_export_salesCountArgs>(
      args?: Subset<T, us_export_salesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Us_export_salesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Us_export_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Us_export_salesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Us_export_salesAggregateArgs>(args: Subset<T, Us_export_salesAggregateArgs>): Prisma.PrismaPromise<GetUs_export_salesAggregateType<T>>

    /**
     * Group by Us_export_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Us_export_salesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Us_export_salesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Us_export_salesGroupByArgs['orderBy'] }
        : { orderBy?: Us_export_salesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Us_export_salesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUs_export_salesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for us_export_sales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__us_export_salesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * us_export_sales base type for findUnique actions
   */
  export type us_export_salesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the us_export_sales
     */
    select?: us_export_salesSelect<ExtArgs> | null
    /**
     * Filter, which us_export_sales to fetch.
     */
    where: us_export_salesWhereUniqueInput
  }

  /**
   * us_export_sales findUnique
   */
  export interface us_export_salesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends us_export_salesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * us_export_sales findUniqueOrThrow
   */
  export type us_export_salesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the us_export_sales
     */
    select?: us_export_salesSelect<ExtArgs> | null
    /**
     * Filter, which us_export_sales to fetch.
     */
    where: us_export_salesWhereUniqueInput
  }


  /**
   * us_export_sales base type for findFirst actions
   */
  export type us_export_salesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the us_export_sales
     */
    select?: us_export_salesSelect<ExtArgs> | null
    /**
     * Filter, which us_export_sales to fetch.
     */
    where?: us_export_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of us_export_sales to fetch.
     */
    orderBy?: Enumerable<us_export_salesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for us_export_sales.
     */
    cursor?: us_export_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` us_export_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` us_export_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of us_export_sales.
     */
    distinct?: Enumerable<Us_export_salesScalarFieldEnum>
  }

  /**
   * us_export_sales findFirst
   */
  export interface us_export_salesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends us_export_salesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * us_export_sales findFirstOrThrow
   */
  export type us_export_salesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the us_export_sales
     */
    select?: us_export_salesSelect<ExtArgs> | null
    /**
     * Filter, which us_export_sales to fetch.
     */
    where?: us_export_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of us_export_sales to fetch.
     */
    orderBy?: Enumerable<us_export_salesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for us_export_sales.
     */
    cursor?: us_export_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` us_export_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` us_export_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of us_export_sales.
     */
    distinct?: Enumerable<Us_export_salesScalarFieldEnum>
  }


  /**
   * us_export_sales findMany
   */
  export type us_export_salesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the us_export_sales
     */
    select?: us_export_salesSelect<ExtArgs> | null
    /**
     * Filter, which us_export_sales to fetch.
     */
    where?: us_export_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of us_export_sales to fetch.
     */
    orderBy?: Enumerable<us_export_salesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing us_export_sales.
     */
    cursor?: us_export_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` us_export_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` us_export_sales.
     */
    skip?: number
    distinct?: Enumerable<Us_export_salesScalarFieldEnum>
  }


  /**
   * us_export_sales create
   */
  export type us_export_salesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the us_export_sales
     */
    select?: us_export_salesSelect<ExtArgs> | null
    /**
     * The data needed to create a us_export_sales.
     */
    data: XOR<us_export_salesCreateInput, us_export_salesUncheckedCreateInput>
  }


  /**
   * us_export_sales createMany
   */
  export type us_export_salesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many us_export_sales.
     */
    data: Enumerable<us_export_salesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * us_export_sales update
   */
  export type us_export_salesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the us_export_sales
     */
    select?: us_export_salesSelect<ExtArgs> | null
    /**
     * The data needed to update a us_export_sales.
     */
    data: XOR<us_export_salesUpdateInput, us_export_salesUncheckedUpdateInput>
    /**
     * Choose, which us_export_sales to update.
     */
    where: us_export_salesWhereUniqueInput
  }


  /**
   * us_export_sales updateMany
   */
  export type us_export_salesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update us_export_sales.
     */
    data: XOR<us_export_salesUpdateManyMutationInput, us_export_salesUncheckedUpdateManyInput>
    /**
     * Filter which us_export_sales to update
     */
    where?: us_export_salesWhereInput
  }


  /**
   * us_export_sales upsert
   */
  export type us_export_salesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the us_export_sales
     */
    select?: us_export_salesSelect<ExtArgs> | null
    /**
     * The filter to search for the us_export_sales to update in case it exists.
     */
    where: us_export_salesWhereUniqueInput
    /**
     * In case the us_export_sales found by the `where` argument doesn't exist, create a new us_export_sales with this data.
     */
    create: XOR<us_export_salesCreateInput, us_export_salesUncheckedCreateInput>
    /**
     * In case the us_export_sales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<us_export_salesUpdateInput, us_export_salesUncheckedUpdateInput>
  }


  /**
   * us_export_sales delete
   */
  export type us_export_salesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the us_export_sales
     */
    select?: us_export_salesSelect<ExtArgs> | null
    /**
     * Filter which us_export_sales to delete.
     */
    where: us_export_salesWhereUniqueInput
  }


  /**
   * us_export_sales deleteMany
   */
  export type us_export_salesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which us_export_sales to delete
     */
    where?: us_export_salesWhereInput
  }


  /**
   * us_export_sales without action
   */
  export type us_export_salesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the us_export_sales
     */
    select?: us_export_salesSelect<ExtArgs> | null
  }



  /**
   * Model commitment_of_traders
   */


  export type AggregateCommitment_of_traders = {
    _count: Commitment_of_tradersCountAggregateOutputType | null
    _avg: Commitment_of_tradersAvgAggregateOutputType | null
    _sum: Commitment_of_tradersSumAggregateOutputType | null
    _min: Commitment_of_tradersMinAggregateOutputType | null
    _max: Commitment_of_tradersMaxAggregateOutputType | null
  }

  export type Commitment_of_tradersAvgAggregateOutputType = {
    calendar_year: number | null
    week: number | null
    open_interest_all: number | null
    producer_merchant_net: number | null
    swap_position_net: number | null
    managed_money_long: number | null
    managed_money_short: number | null
    managed_money_net: number | null
    other_reportables_net: number | null
    total_reportables_net: number | null
    non_reportables_net: number | null
    specs_net: number | null
  }

  export type Commitment_of_tradersSumAggregateOutputType = {
    calendar_year: number | null
    week: number | null
    open_interest_all: number | null
    producer_merchant_net: number | null
    swap_position_net: number | null
    managed_money_long: number | null
    managed_money_short: number | null
    managed_money_net: number | null
    other_reportables_net: number | null
    total_reportables_net: number | null
    non_reportables_net: number | null
    specs_net: number | null
  }

  export type Commitment_of_tradersMinAggregateOutputType = {
    record_id: string | null
    calendar_year: number | null
    crop_year: string | null
    month: string | null
    week: number | null
    report_date_as_dd_mm_yyyy: Date | null
    open_interest_all: number | null
    producer_merchant_net: number | null
    swap_position_net: number | null
    managed_money_long: number | null
    managed_money_short: number | null
    managed_money_net: number | null
    other_reportables_net: number | null
    total_reportables_net: number | null
    non_reportables_net: number | null
    specs_net: number | null
  }

  export type Commitment_of_tradersMaxAggregateOutputType = {
    record_id: string | null
    calendar_year: number | null
    crop_year: string | null
    month: string | null
    week: number | null
    report_date_as_dd_mm_yyyy: Date | null
    open_interest_all: number | null
    producer_merchant_net: number | null
    swap_position_net: number | null
    managed_money_long: number | null
    managed_money_short: number | null
    managed_money_net: number | null
    other_reportables_net: number | null
    total_reportables_net: number | null
    non_reportables_net: number | null
    specs_net: number | null
  }

  export type Commitment_of_tradersCountAggregateOutputType = {
    record_id: number
    calendar_year: number
    crop_year: number
    month: number
    week: number
    report_date_as_dd_mm_yyyy: number
    open_interest_all: number
    producer_merchant_net: number
    swap_position_net: number
    managed_money_long: number
    managed_money_short: number
    managed_money_net: number
    other_reportables_net: number
    total_reportables_net: number
    non_reportables_net: number
    specs_net: number
    _all: number
  }


  export type Commitment_of_tradersAvgAggregateInputType = {
    calendar_year?: true
    week?: true
    open_interest_all?: true
    producer_merchant_net?: true
    swap_position_net?: true
    managed_money_long?: true
    managed_money_short?: true
    managed_money_net?: true
    other_reportables_net?: true
    total_reportables_net?: true
    non_reportables_net?: true
    specs_net?: true
  }

  export type Commitment_of_tradersSumAggregateInputType = {
    calendar_year?: true
    week?: true
    open_interest_all?: true
    producer_merchant_net?: true
    swap_position_net?: true
    managed_money_long?: true
    managed_money_short?: true
    managed_money_net?: true
    other_reportables_net?: true
    total_reportables_net?: true
    non_reportables_net?: true
    specs_net?: true
  }

  export type Commitment_of_tradersMinAggregateInputType = {
    record_id?: true
    calendar_year?: true
    crop_year?: true
    month?: true
    week?: true
    report_date_as_dd_mm_yyyy?: true
    open_interest_all?: true
    producer_merchant_net?: true
    swap_position_net?: true
    managed_money_long?: true
    managed_money_short?: true
    managed_money_net?: true
    other_reportables_net?: true
    total_reportables_net?: true
    non_reportables_net?: true
    specs_net?: true
  }

  export type Commitment_of_tradersMaxAggregateInputType = {
    record_id?: true
    calendar_year?: true
    crop_year?: true
    month?: true
    week?: true
    report_date_as_dd_mm_yyyy?: true
    open_interest_all?: true
    producer_merchant_net?: true
    swap_position_net?: true
    managed_money_long?: true
    managed_money_short?: true
    managed_money_net?: true
    other_reportables_net?: true
    total_reportables_net?: true
    non_reportables_net?: true
    specs_net?: true
  }

  export type Commitment_of_tradersCountAggregateInputType = {
    record_id?: true
    calendar_year?: true
    crop_year?: true
    month?: true
    week?: true
    report_date_as_dd_mm_yyyy?: true
    open_interest_all?: true
    producer_merchant_net?: true
    swap_position_net?: true
    managed_money_long?: true
    managed_money_short?: true
    managed_money_net?: true
    other_reportables_net?: true
    total_reportables_net?: true
    non_reportables_net?: true
    specs_net?: true
    _all?: true
  }

  export type Commitment_of_tradersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which commitment_of_traders to aggregate.
     */
    where?: commitment_of_tradersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commitment_of_traders to fetch.
     */
    orderBy?: Enumerable<commitment_of_tradersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commitment_of_tradersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commitment_of_traders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commitment_of_traders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned commitment_of_traders
    **/
    _count?: true | Commitment_of_tradersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Commitment_of_tradersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Commitment_of_tradersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Commitment_of_tradersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Commitment_of_tradersMaxAggregateInputType
  }

  export type GetCommitment_of_tradersAggregateType<T extends Commitment_of_tradersAggregateArgs> = {
        [P in keyof T & keyof AggregateCommitment_of_traders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommitment_of_traders[P]>
      : GetScalarType<T[P], AggregateCommitment_of_traders[P]>
  }




  export type Commitment_of_tradersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: commitment_of_tradersWhereInput
    orderBy?: Enumerable<commitment_of_tradersOrderByWithAggregationInput>
    by: Commitment_of_tradersScalarFieldEnum[]
    having?: commitment_of_tradersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Commitment_of_tradersCountAggregateInputType | true
    _avg?: Commitment_of_tradersAvgAggregateInputType
    _sum?: Commitment_of_tradersSumAggregateInputType
    _min?: Commitment_of_tradersMinAggregateInputType
    _max?: Commitment_of_tradersMaxAggregateInputType
  }


  export type Commitment_of_tradersGroupByOutputType = {
    record_id: string
    calendar_year: number
    crop_year: string
    month: string
    week: number | null
    report_date_as_dd_mm_yyyy: Date
    open_interest_all: number | null
    producer_merchant_net: number | null
    swap_position_net: number | null
    managed_money_long: number | null
    managed_money_short: number | null
    managed_money_net: number | null
    other_reportables_net: number | null
    total_reportables_net: number | null
    non_reportables_net: number | null
    specs_net: number | null
    _count: Commitment_of_tradersCountAggregateOutputType | null
    _avg: Commitment_of_tradersAvgAggregateOutputType | null
    _sum: Commitment_of_tradersSumAggregateOutputType | null
    _min: Commitment_of_tradersMinAggregateOutputType | null
    _max: Commitment_of_tradersMaxAggregateOutputType | null
  }

  type GetCommitment_of_tradersGroupByPayload<T extends Commitment_of_tradersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Commitment_of_tradersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Commitment_of_tradersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Commitment_of_tradersGroupByOutputType[P]>
            : GetScalarType<T[P], Commitment_of_tradersGroupByOutputType[P]>
        }
      >
    >


  export type commitment_of_tradersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    calendar_year?: boolean
    crop_year?: boolean
    month?: boolean
    week?: boolean
    report_date_as_dd_mm_yyyy?: boolean
    open_interest_all?: boolean
    producer_merchant_net?: boolean
    swap_position_net?: boolean
    managed_money_long?: boolean
    managed_money_short?: boolean
    managed_money_net?: boolean
    other_reportables_net?: boolean
    total_reportables_net?: boolean
    non_reportables_net?: boolean
    specs_net?: boolean
  }, ExtArgs["result"]["commitment_of_traders"]>

  export type commitment_of_tradersSelectScalar = {
    record_id?: boolean
    calendar_year?: boolean
    crop_year?: boolean
    month?: boolean
    week?: boolean
    report_date_as_dd_mm_yyyy?: boolean
    open_interest_all?: boolean
    producer_merchant_net?: boolean
    swap_position_net?: boolean
    managed_money_long?: boolean
    managed_money_short?: boolean
    managed_money_net?: boolean
    other_reportables_net?: boolean
    total_reportables_net?: boolean
    non_reportables_net?: boolean
    specs_net?: boolean
  }


  type commitment_of_tradersGetPayload<S extends boolean | null | undefined | commitment_of_tradersArgs> = $Types.GetResult<commitment_of_tradersPayload, S>

  type commitment_of_tradersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<commitment_of_tradersFindManyArgs, 'select' | 'include'> & {
      select?: Commitment_of_tradersCountAggregateInputType | true
    }

  export interface commitment_of_tradersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['commitment_of_traders'], meta: { name: 'commitment_of_traders' } }
    /**
     * Find zero or one Commitment_of_traders that matches the filter.
     * @param {commitment_of_tradersFindUniqueArgs} args - Arguments to find a Commitment_of_traders
     * @example
     * // Get one Commitment_of_traders
     * const commitment_of_traders = await prisma.commitment_of_traders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends commitment_of_tradersFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, commitment_of_tradersFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'commitment_of_traders'> extends True ? Prisma__commitment_of_tradersClient<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__commitment_of_tradersClient<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Commitment_of_traders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {commitment_of_tradersFindUniqueOrThrowArgs} args - Arguments to find a Commitment_of_traders
     * @example
     * // Get one Commitment_of_traders
     * const commitment_of_traders = await prisma.commitment_of_traders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends commitment_of_tradersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, commitment_of_tradersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__commitment_of_tradersClient<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Commitment_of_traders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commitment_of_tradersFindFirstArgs} args - Arguments to find a Commitment_of_traders
     * @example
     * // Get one Commitment_of_traders
     * const commitment_of_traders = await prisma.commitment_of_traders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends commitment_of_tradersFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, commitment_of_tradersFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'commitment_of_traders'> extends True ? Prisma__commitment_of_tradersClient<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__commitment_of_tradersClient<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Commitment_of_traders that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commitment_of_tradersFindFirstOrThrowArgs} args - Arguments to find a Commitment_of_traders
     * @example
     * // Get one Commitment_of_traders
     * const commitment_of_traders = await prisma.commitment_of_traders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends commitment_of_tradersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, commitment_of_tradersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__commitment_of_tradersClient<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Commitment_of_traders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commitment_of_tradersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commitment_of_traders
     * const commitment_of_traders = await prisma.commitment_of_traders.findMany()
     * 
     * // Get first 10 Commitment_of_traders
     * const commitment_of_traders = await prisma.commitment_of_traders.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const commitment_of_tradersWithRecord_idOnly = await prisma.commitment_of_traders.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends commitment_of_tradersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commitment_of_tradersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Commitment_of_traders.
     * @param {commitment_of_tradersCreateArgs} args - Arguments to create a Commitment_of_traders.
     * @example
     * // Create one Commitment_of_traders
     * const Commitment_of_traders = await prisma.commitment_of_traders.create({
     *   data: {
     *     // ... data to create a Commitment_of_traders
     *   }
     * })
     * 
    **/
    create<T extends commitment_of_tradersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, commitment_of_tradersCreateArgs<ExtArgs>>
    ): Prisma__commitment_of_tradersClient<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Commitment_of_traders.
     *     @param {commitment_of_tradersCreateManyArgs} args - Arguments to create many Commitment_of_traders.
     *     @example
     *     // Create many Commitment_of_traders
     *     const commitment_of_traders = await prisma.commitment_of_traders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends commitment_of_tradersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commitment_of_tradersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Commitment_of_traders.
     * @param {commitment_of_tradersDeleteArgs} args - Arguments to delete one Commitment_of_traders.
     * @example
     * // Delete one Commitment_of_traders
     * const Commitment_of_traders = await prisma.commitment_of_traders.delete({
     *   where: {
     *     // ... filter to delete one Commitment_of_traders
     *   }
     * })
     * 
    **/
    delete<T extends commitment_of_tradersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, commitment_of_tradersDeleteArgs<ExtArgs>>
    ): Prisma__commitment_of_tradersClient<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Commitment_of_traders.
     * @param {commitment_of_tradersUpdateArgs} args - Arguments to update one Commitment_of_traders.
     * @example
     * // Update one Commitment_of_traders
     * const commitment_of_traders = await prisma.commitment_of_traders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends commitment_of_tradersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, commitment_of_tradersUpdateArgs<ExtArgs>>
    ): Prisma__commitment_of_tradersClient<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Commitment_of_traders.
     * @param {commitment_of_tradersDeleteManyArgs} args - Arguments to filter Commitment_of_traders to delete.
     * @example
     * // Delete a few Commitment_of_traders
     * const { count } = await prisma.commitment_of_traders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends commitment_of_tradersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commitment_of_tradersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commitment_of_traders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commitment_of_tradersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commitment_of_traders
     * const commitment_of_traders = await prisma.commitment_of_traders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends commitment_of_tradersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, commitment_of_tradersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commitment_of_traders.
     * @param {commitment_of_tradersUpsertArgs} args - Arguments to update or create a Commitment_of_traders.
     * @example
     * // Update or create a Commitment_of_traders
     * const commitment_of_traders = await prisma.commitment_of_traders.upsert({
     *   create: {
     *     // ... data to create a Commitment_of_traders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commitment_of_traders we want to update
     *   }
     * })
    **/
    upsert<T extends commitment_of_tradersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, commitment_of_tradersUpsertArgs<ExtArgs>>
    ): Prisma__commitment_of_tradersClient<$Types.GetResult<commitment_of_tradersPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Commitment_of_traders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commitment_of_tradersCountArgs} args - Arguments to filter Commitment_of_traders to count.
     * @example
     * // Count the number of Commitment_of_traders
     * const count = await prisma.commitment_of_traders.count({
     *   where: {
     *     // ... the filter for the Commitment_of_traders we want to count
     *   }
     * })
    **/
    count<T extends commitment_of_tradersCountArgs>(
      args?: Subset<T, commitment_of_tradersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Commitment_of_tradersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commitment_of_traders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Commitment_of_tradersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Commitment_of_tradersAggregateArgs>(args: Subset<T, Commitment_of_tradersAggregateArgs>): Prisma.PrismaPromise<GetCommitment_of_tradersAggregateType<T>>

    /**
     * Group by Commitment_of_traders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Commitment_of_tradersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Commitment_of_tradersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Commitment_of_tradersGroupByArgs['orderBy'] }
        : { orderBy?: Commitment_of_tradersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Commitment_of_tradersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommitment_of_tradersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for commitment_of_traders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__commitment_of_tradersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * commitment_of_traders base type for findUnique actions
   */
  export type commitment_of_tradersFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commitment_of_traders
     */
    select?: commitment_of_tradersSelect<ExtArgs> | null
    /**
     * Filter, which commitment_of_traders to fetch.
     */
    where: commitment_of_tradersWhereUniqueInput
  }

  /**
   * commitment_of_traders findUnique
   */
  export interface commitment_of_tradersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends commitment_of_tradersFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * commitment_of_traders findUniqueOrThrow
   */
  export type commitment_of_tradersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commitment_of_traders
     */
    select?: commitment_of_tradersSelect<ExtArgs> | null
    /**
     * Filter, which commitment_of_traders to fetch.
     */
    where: commitment_of_tradersWhereUniqueInput
  }


  /**
   * commitment_of_traders base type for findFirst actions
   */
  export type commitment_of_tradersFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commitment_of_traders
     */
    select?: commitment_of_tradersSelect<ExtArgs> | null
    /**
     * Filter, which commitment_of_traders to fetch.
     */
    where?: commitment_of_tradersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commitment_of_traders to fetch.
     */
    orderBy?: Enumerable<commitment_of_tradersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commitment_of_traders.
     */
    cursor?: commitment_of_tradersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commitment_of_traders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commitment_of_traders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commitment_of_traders.
     */
    distinct?: Enumerable<Commitment_of_tradersScalarFieldEnum>
  }

  /**
   * commitment_of_traders findFirst
   */
  export interface commitment_of_tradersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends commitment_of_tradersFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * commitment_of_traders findFirstOrThrow
   */
  export type commitment_of_tradersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commitment_of_traders
     */
    select?: commitment_of_tradersSelect<ExtArgs> | null
    /**
     * Filter, which commitment_of_traders to fetch.
     */
    where?: commitment_of_tradersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commitment_of_traders to fetch.
     */
    orderBy?: Enumerable<commitment_of_tradersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commitment_of_traders.
     */
    cursor?: commitment_of_tradersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commitment_of_traders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commitment_of_traders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commitment_of_traders.
     */
    distinct?: Enumerable<Commitment_of_tradersScalarFieldEnum>
  }


  /**
   * commitment_of_traders findMany
   */
  export type commitment_of_tradersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commitment_of_traders
     */
    select?: commitment_of_tradersSelect<ExtArgs> | null
    /**
     * Filter, which commitment_of_traders to fetch.
     */
    where?: commitment_of_tradersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commitment_of_traders to fetch.
     */
    orderBy?: Enumerable<commitment_of_tradersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing commitment_of_traders.
     */
    cursor?: commitment_of_tradersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commitment_of_traders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commitment_of_traders.
     */
    skip?: number
    distinct?: Enumerable<Commitment_of_tradersScalarFieldEnum>
  }


  /**
   * commitment_of_traders create
   */
  export type commitment_of_tradersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commitment_of_traders
     */
    select?: commitment_of_tradersSelect<ExtArgs> | null
    /**
     * The data needed to create a commitment_of_traders.
     */
    data: XOR<commitment_of_tradersCreateInput, commitment_of_tradersUncheckedCreateInput>
  }


  /**
   * commitment_of_traders createMany
   */
  export type commitment_of_tradersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many commitment_of_traders.
     */
    data: Enumerable<commitment_of_tradersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * commitment_of_traders update
   */
  export type commitment_of_tradersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commitment_of_traders
     */
    select?: commitment_of_tradersSelect<ExtArgs> | null
    /**
     * The data needed to update a commitment_of_traders.
     */
    data: XOR<commitment_of_tradersUpdateInput, commitment_of_tradersUncheckedUpdateInput>
    /**
     * Choose, which commitment_of_traders to update.
     */
    where: commitment_of_tradersWhereUniqueInput
  }


  /**
   * commitment_of_traders updateMany
   */
  export type commitment_of_tradersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update commitment_of_traders.
     */
    data: XOR<commitment_of_tradersUpdateManyMutationInput, commitment_of_tradersUncheckedUpdateManyInput>
    /**
     * Filter which commitment_of_traders to update
     */
    where?: commitment_of_tradersWhereInput
  }


  /**
   * commitment_of_traders upsert
   */
  export type commitment_of_tradersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commitment_of_traders
     */
    select?: commitment_of_tradersSelect<ExtArgs> | null
    /**
     * The filter to search for the commitment_of_traders to update in case it exists.
     */
    where: commitment_of_tradersWhereUniqueInput
    /**
     * In case the commitment_of_traders found by the `where` argument doesn't exist, create a new commitment_of_traders with this data.
     */
    create: XOR<commitment_of_tradersCreateInput, commitment_of_tradersUncheckedCreateInput>
    /**
     * In case the commitment_of_traders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commitment_of_tradersUpdateInput, commitment_of_tradersUncheckedUpdateInput>
  }


  /**
   * commitment_of_traders delete
   */
  export type commitment_of_tradersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commitment_of_traders
     */
    select?: commitment_of_tradersSelect<ExtArgs> | null
    /**
     * Filter which commitment_of_traders to delete.
     */
    where: commitment_of_tradersWhereUniqueInput
  }


  /**
   * commitment_of_traders deleteMany
   */
  export type commitment_of_tradersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which commitment_of_traders to delete
     */
    where?: commitment_of_tradersWhereInput
  }


  /**
   * commitment_of_traders without action
   */
  export type commitment_of_tradersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commitment_of_traders
     */
    select?: commitment_of_tradersSelect<ExtArgs> | null
  }



  /**
   * Model cotton_on_call
   */


  export type AggregateCotton_on_call = {
    _count: Cotton_on_callCountAggregateOutputType | null
    _avg: Cotton_on_callAvgAggregateOutputType | null
    _sum: Cotton_on_callSumAggregateOutputType | null
    _min: Cotton_on_callMinAggregateOutputType | null
    _max: Cotton_on_callMaxAggregateOutputType | null
  }

  export type Cotton_on_callAvgAggregateOutputType = {
    season_week: number | null
    week: number | null
    october_sales: number | null
    december_sales: number | null
    march_sales: number | null
    may_sales: number | null
    july_sales: number | null
    total_on_call_sales: number | null
    october_purchases: number | null
    december_purchases: number | null
    march_purchases: number | null
    may_purchases: number | null
    july_purchases: number | null
    total_on_call_purchases: number | null
    total_net_u_oc_position: number | null
    total_net_change: number | null
  }

  export type Cotton_on_callSumAggregateOutputType = {
    season_week: number | null
    week: number | null
    october_sales: number | null
    december_sales: number | null
    march_sales: number | null
    may_sales: number | null
    july_sales: number | null
    total_on_call_sales: number | null
    october_purchases: number | null
    december_purchases: number | null
    march_purchases: number | null
    may_purchases: number | null
    july_purchases: number | null
    total_on_call_purchases: number | null
    total_net_u_oc_position: number | null
    total_net_change: number | null
  }

  export type Cotton_on_callMinAggregateOutputType = {
    record_id: string | null
    date: Date | null
    season_week: number | null
    week: number | null
    season: string | null
    october_sales: number | null
    december_sales: number | null
    march_sales: number | null
    may_sales: number | null
    july_sales: number | null
    total_on_call_sales: number | null
    october_purchases: number | null
    december_purchases: number | null
    march_purchases: number | null
    may_purchases: number | null
    july_purchases: number | null
    total_on_call_purchases: number | null
    total_net_u_oc_position: number | null
    total_net_change: number | null
  }

  export type Cotton_on_callMaxAggregateOutputType = {
    record_id: string | null
    date: Date | null
    season_week: number | null
    week: number | null
    season: string | null
    october_sales: number | null
    december_sales: number | null
    march_sales: number | null
    may_sales: number | null
    july_sales: number | null
    total_on_call_sales: number | null
    october_purchases: number | null
    december_purchases: number | null
    march_purchases: number | null
    may_purchases: number | null
    july_purchases: number | null
    total_on_call_purchases: number | null
    total_net_u_oc_position: number | null
    total_net_change: number | null
  }

  export type Cotton_on_callCountAggregateOutputType = {
    record_id: number
    date: number
    season_week: number
    week: number
    season: number
    october_sales: number
    december_sales: number
    march_sales: number
    may_sales: number
    july_sales: number
    total_on_call_sales: number
    october_purchases: number
    december_purchases: number
    march_purchases: number
    may_purchases: number
    july_purchases: number
    total_on_call_purchases: number
    total_net_u_oc_position: number
    total_net_change: number
    _all: number
  }


  export type Cotton_on_callAvgAggregateInputType = {
    season_week?: true
    week?: true
    october_sales?: true
    december_sales?: true
    march_sales?: true
    may_sales?: true
    july_sales?: true
    total_on_call_sales?: true
    october_purchases?: true
    december_purchases?: true
    march_purchases?: true
    may_purchases?: true
    july_purchases?: true
    total_on_call_purchases?: true
    total_net_u_oc_position?: true
    total_net_change?: true
  }

  export type Cotton_on_callSumAggregateInputType = {
    season_week?: true
    week?: true
    october_sales?: true
    december_sales?: true
    march_sales?: true
    may_sales?: true
    july_sales?: true
    total_on_call_sales?: true
    october_purchases?: true
    december_purchases?: true
    march_purchases?: true
    may_purchases?: true
    july_purchases?: true
    total_on_call_purchases?: true
    total_net_u_oc_position?: true
    total_net_change?: true
  }

  export type Cotton_on_callMinAggregateInputType = {
    record_id?: true
    date?: true
    season_week?: true
    week?: true
    season?: true
    october_sales?: true
    december_sales?: true
    march_sales?: true
    may_sales?: true
    july_sales?: true
    total_on_call_sales?: true
    october_purchases?: true
    december_purchases?: true
    march_purchases?: true
    may_purchases?: true
    july_purchases?: true
    total_on_call_purchases?: true
    total_net_u_oc_position?: true
    total_net_change?: true
  }

  export type Cotton_on_callMaxAggregateInputType = {
    record_id?: true
    date?: true
    season_week?: true
    week?: true
    season?: true
    october_sales?: true
    december_sales?: true
    march_sales?: true
    may_sales?: true
    july_sales?: true
    total_on_call_sales?: true
    october_purchases?: true
    december_purchases?: true
    march_purchases?: true
    may_purchases?: true
    july_purchases?: true
    total_on_call_purchases?: true
    total_net_u_oc_position?: true
    total_net_change?: true
  }

  export type Cotton_on_callCountAggregateInputType = {
    record_id?: true
    date?: true
    season_week?: true
    week?: true
    season?: true
    october_sales?: true
    december_sales?: true
    march_sales?: true
    may_sales?: true
    july_sales?: true
    total_on_call_sales?: true
    october_purchases?: true
    december_purchases?: true
    march_purchases?: true
    may_purchases?: true
    july_purchases?: true
    total_on_call_purchases?: true
    total_net_u_oc_position?: true
    total_net_change?: true
    _all?: true
  }

  export type Cotton_on_callAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which cotton_on_call to aggregate.
     */
    where?: cotton_on_callWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotton_on_calls to fetch.
     */
    orderBy?: Enumerable<cotton_on_callOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cotton_on_callWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotton_on_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotton_on_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cotton_on_calls
    **/
    _count?: true | Cotton_on_callCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cotton_on_callAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cotton_on_callSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cotton_on_callMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cotton_on_callMaxAggregateInputType
  }

  export type GetCotton_on_callAggregateType<T extends Cotton_on_callAggregateArgs> = {
        [P in keyof T & keyof AggregateCotton_on_call]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotton_on_call[P]>
      : GetScalarType<T[P], AggregateCotton_on_call[P]>
  }




  export type Cotton_on_callGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: cotton_on_callWhereInput
    orderBy?: Enumerable<cotton_on_callOrderByWithAggregationInput>
    by: Cotton_on_callScalarFieldEnum[]
    having?: cotton_on_callScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cotton_on_callCountAggregateInputType | true
    _avg?: Cotton_on_callAvgAggregateInputType
    _sum?: Cotton_on_callSumAggregateInputType
    _min?: Cotton_on_callMinAggregateInputType
    _max?: Cotton_on_callMaxAggregateInputType
  }


  export type Cotton_on_callGroupByOutputType = {
    record_id: string
    date: Date
    season_week: number | null
    week: number
    season: string
    october_sales: number | null
    december_sales: number | null
    march_sales: number | null
    may_sales: number | null
    july_sales: number | null
    total_on_call_sales: number | null
    october_purchases: number | null
    december_purchases: number | null
    march_purchases: number | null
    may_purchases: number | null
    july_purchases: number | null
    total_on_call_purchases: number | null
    total_net_u_oc_position: number | null
    total_net_change: number | null
    _count: Cotton_on_callCountAggregateOutputType | null
    _avg: Cotton_on_callAvgAggregateOutputType | null
    _sum: Cotton_on_callSumAggregateOutputType | null
    _min: Cotton_on_callMinAggregateOutputType | null
    _max: Cotton_on_callMaxAggregateOutputType | null
  }

  type GetCotton_on_callGroupByPayload<T extends Cotton_on_callGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Cotton_on_callGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cotton_on_callGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cotton_on_callGroupByOutputType[P]>
            : GetScalarType<T[P], Cotton_on_callGroupByOutputType[P]>
        }
      >
    >


  export type cotton_on_callSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    date?: boolean
    season_week?: boolean
    week?: boolean
    season?: boolean
    october_sales?: boolean
    december_sales?: boolean
    march_sales?: boolean
    may_sales?: boolean
    july_sales?: boolean
    total_on_call_sales?: boolean
    october_purchases?: boolean
    december_purchases?: boolean
    march_purchases?: boolean
    may_purchases?: boolean
    july_purchases?: boolean
    total_on_call_purchases?: boolean
    total_net_u_oc_position?: boolean
    total_net_change?: boolean
  }, ExtArgs["result"]["cotton_on_call"]>

  export type cotton_on_callSelectScalar = {
    record_id?: boolean
    date?: boolean
    season_week?: boolean
    week?: boolean
    season?: boolean
    october_sales?: boolean
    december_sales?: boolean
    march_sales?: boolean
    may_sales?: boolean
    july_sales?: boolean
    total_on_call_sales?: boolean
    october_purchases?: boolean
    december_purchases?: boolean
    march_purchases?: boolean
    may_purchases?: boolean
    july_purchases?: boolean
    total_on_call_purchases?: boolean
    total_net_u_oc_position?: boolean
    total_net_change?: boolean
  }


  type cotton_on_callGetPayload<S extends boolean | null | undefined | cotton_on_callArgs> = $Types.GetResult<cotton_on_callPayload, S>

  type cotton_on_callCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<cotton_on_callFindManyArgs, 'select' | 'include'> & {
      select?: Cotton_on_callCountAggregateInputType | true
    }

  export interface cotton_on_callDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cotton_on_call'], meta: { name: 'cotton_on_call' } }
    /**
     * Find zero or one Cotton_on_call that matches the filter.
     * @param {cotton_on_callFindUniqueArgs} args - Arguments to find a Cotton_on_call
     * @example
     * // Get one Cotton_on_call
     * const cotton_on_call = await prisma.cotton_on_call.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cotton_on_callFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cotton_on_callFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cotton_on_call'> extends True ? Prisma__cotton_on_callClient<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__cotton_on_callClient<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Cotton_on_call that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cotton_on_callFindUniqueOrThrowArgs} args - Arguments to find a Cotton_on_call
     * @example
     * // Get one Cotton_on_call
     * const cotton_on_call = await prisma.cotton_on_call.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cotton_on_callFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cotton_on_callFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__cotton_on_callClient<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Cotton_on_call that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotton_on_callFindFirstArgs} args - Arguments to find a Cotton_on_call
     * @example
     * // Get one Cotton_on_call
     * const cotton_on_call = await prisma.cotton_on_call.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cotton_on_callFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cotton_on_callFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cotton_on_call'> extends True ? Prisma__cotton_on_callClient<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__cotton_on_callClient<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Cotton_on_call that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotton_on_callFindFirstOrThrowArgs} args - Arguments to find a Cotton_on_call
     * @example
     * // Get one Cotton_on_call
     * const cotton_on_call = await prisma.cotton_on_call.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cotton_on_callFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cotton_on_callFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__cotton_on_callClient<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Cotton_on_calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotton_on_callFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cotton_on_calls
     * const cotton_on_calls = await prisma.cotton_on_call.findMany()
     * 
     * // Get first 10 Cotton_on_calls
     * const cotton_on_calls = await prisma.cotton_on_call.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const cotton_on_callWithRecord_idOnly = await prisma.cotton_on_call.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends cotton_on_callFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cotton_on_callFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Cotton_on_call.
     * @param {cotton_on_callCreateArgs} args - Arguments to create a Cotton_on_call.
     * @example
     * // Create one Cotton_on_call
     * const Cotton_on_call = await prisma.cotton_on_call.create({
     *   data: {
     *     // ... data to create a Cotton_on_call
     *   }
     * })
     * 
    **/
    create<T extends cotton_on_callCreateArgs<ExtArgs>>(
      args: SelectSubset<T, cotton_on_callCreateArgs<ExtArgs>>
    ): Prisma__cotton_on_callClient<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Cotton_on_calls.
     *     @param {cotton_on_callCreateManyArgs} args - Arguments to create many Cotton_on_calls.
     *     @example
     *     // Create many Cotton_on_calls
     *     const cotton_on_call = await prisma.cotton_on_call.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cotton_on_callCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cotton_on_callCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cotton_on_call.
     * @param {cotton_on_callDeleteArgs} args - Arguments to delete one Cotton_on_call.
     * @example
     * // Delete one Cotton_on_call
     * const Cotton_on_call = await prisma.cotton_on_call.delete({
     *   where: {
     *     // ... filter to delete one Cotton_on_call
     *   }
     * })
     * 
    **/
    delete<T extends cotton_on_callDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, cotton_on_callDeleteArgs<ExtArgs>>
    ): Prisma__cotton_on_callClient<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Cotton_on_call.
     * @param {cotton_on_callUpdateArgs} args - Arguments to update one Cotton_on_call.
     * @example
     * // Update one Cotton_on_call
     * const cotton_on_call = await prisma.cotton_on_call.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cotton_on_callUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, cotton_on_callUpdateArgs<ExtArgs>>
    ): Prisma__cotton_on_callClient<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Cotton_on_calls.
     * @param {cotton_on_callDeleteManyArgs} args - Arguments to filter Cotton_on_calls to delete.
     * @example
     * // Delete a few Cotton_on_calls
     * const { count } = await prisma.cotton_on_call.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cotton_on_callDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cotton_on_callDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cotton_on_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotton_on_callUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cotton_on_calls
     * const cotton_on_call = await prisma.cotton_on_call.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cotton_on_callUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, cotton_on_callUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cotton_on_call.
     * @param {cotton_on_callUpsertArgs} args - Arguments to update or create a Cotton_on_call.
     * @example
     * // Update or create a Cotton_on_call
     * const cotton_on_call = await prisma.cotton_on_call.upsert({
     *   create: {
     *     // ... data to create a Cotton_on_call
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cotton_on_call we want to update
     *   }
     * })
    **/
    upsert<T extends cotton_on_callUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, cotton_on_callUpsertArgs<ExtArgs>>
    ): Prisma__cotton_on_callClient<$Types.GetResult<cotton_on_callPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Cotton_on_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotton_on_callCountArgs} args - Arguments to filter Cotton_on_calls to count.
     * @example
     * // Count the number of Cotton_on_calls
     * const count = await prisma.cotton_on_call.count({
     *   where: {
     *     // ... the filter for the Cotton_on_calls we want to count
     *   }
     * })
    **/
    count<T extends cotton_on_callCountArgs>(
      args?: Subset<T, cotton_on_callCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cotton_on_callCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cotton_on_call.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cotton_on_callAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cotton_on_callAggregateArgs>(args: Subset<T, Cotton_on_callAggregateArgs>): Prisma.PrismaPromise<GetCotton_on_callAggregateType<T>>

    /**
     * Group by Cotton_on_call.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cotton_on_callGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Cotton_on_callGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Cotton_on_callGroupByArgs['orderBy'] }
        : { orderBy?: Cotton_on_callGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Cotton_on_callGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotton_on_callGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cotton_on_call.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cotton_on_callClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cotton_on_call base type for findUnique actions
   */
  export type cotton_on_callFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_on_call
     */
    select?: cotton_on_callSelect<ExtArgs> | null
    /**
     * Filter, which cotton_on_call to fetch.
     */
    where: cotton_on_callWhereUniqueInput
  }

  /**
   * cotton_on_call findUnique
   */
  export interface cotton_on_callFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends cotton_on_callFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cotton_on_call findUniqueOrThrow
   */
  export type cotton_on_callFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_on_call
     */
    select?: cotton_on_callSelect<ExtArgs> | null
    /**
     * Filter, which cotton_on_call to fetch.
     */
    where: cotton_on_callWhereUniqueInput
  }


  /**
   * cotton_on_call base type for findFirst actions
   */
  export type cotton_on_callFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_on_call
     */
    select?: cotton_on_callSelect<ExtArgs> | null
    /**
     * Filter, which cotton_on_call to fetch.
     */
    where?: cotton_on_callWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotton_on_calls to fetch.
     */
    orderBy?: Enumerable<cotton_on_callOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cotton_on_calls.
     */
    cursor?: cotton_on_callWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotton_on_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotton_on_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cotton_on_calls.
     */
    distinct?: Enumerable<Cotton_on_callScalarFieldEnum>
  }

  /**
   * cotton_on_call findFirst
   */
  export interface cotton_on_callFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends cotton_on_callFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cotton_on_call findFirstOrThrow
   */
  export type cotton_on_callFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_on_call
     */
    select?: cotton_on_callSelect<ExtArgs> | null
    /**
     * Filter, which cotton_on_call to fetch.
     */
    where?: cotton_on_callWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotton_on_calls to fetch.
     */
    orderBy?: Enumerable<cotton_on_callOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cotton_on_calls.
     */
    cursor?: cotton_on_callWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotton_on_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotton_on_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cotton_on_calls.
     */
    distinct?: Enumerable<Cotton_on_callScalarFieldEnum>
  }


  /**
   * cotton_on_call findMany
   */
  export type cotton_on_callFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_on_call
     */
    select?: cotton_on_callSelect<ExtArgs> | null
    /**
     * Filter, which cotton_on_calls to fetch.
     */
    where?: cotton_on_callWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotton_on_calls to fetch.
     */
    orderBy?: Enumerable<cotton_on_callOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cotton_on_calls.
     */
    cursor?: cotton_on_callWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotton_on_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotton_on_calls.
     */
    skip?: number
    distinct?: Enumerable<Cotton_on_callScalarFieldEnum>
  }


  /**
   * cotton_on_call create
   */
  export type cotton_on_callCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_on_call
     */
    select?: cotton_on_callSelect<ExtArgs> | null
    /**
     * The data needed to create a cotton_on_call.
     */
    data: XOR<cotton_on_callCreateInput, cotton_on_callUncheckedCreateInput>
  }


  /**
   * cotton_on_call createMany
   */
  export type cotton_on_callCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cotton_on_calls.
     */
    data: Enumerable<cotton_on_callCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cotton_on_call update
   */
  export type cotton_on_callUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_on_call
     */
    select?: cotton_on_callSelect<ExtArgs> | null
    /**
     * The data needed to update a cotton_on_call.
     */
    data: XOR<cotton_on_callUpdateInput, cotton_on_callUncheckedUpdateInput>
    /**
     * Choose, which cotton_on_call to update.
     */
    where: cotton_on_callWhereUniqueInput
  }


  /**
   * cotton_on_call updateMany
   */
  export type cotton_on_callUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cotton_on_calls.
     */
    data: XOR<cotton_on_callUpdateManyMutationInput, cotton_on_callUncheckedUpdateManyInput>
    /**
     * Filter which cotton_on_calls to update
     */
    where?: cotton_on_callWhereInput
  }


  /**
   * cotton_on_call upsert
   */
  export type cotton_on_callUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_on_call
     */
    select?: cotton_on_callSelect<ExtArgs> | null
    /**
     * The filter to search for the cotton_on_call to update in case it exists.
     */
    where: cotton_on_callWhereUniqueInput
    /**
     * In case the cotton_on_call found by the `where` argument doesn't exist, create a new cotton_on_call with this data.
     */
    create: XOR<cotton_on_callCreateInput, cotton_on_callUncheckedCreateInput>
    /**
     * In case the cotton_on_call was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cotton_on_callUpdateInput, cotton_on_callUncheckedUpdateInput>
  }


  /**
   * cotton_on_call delete
   */
  export type cotton_on_callDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_on_call
     */
    select?: cotton_on_callSelect<ExtArgs> | null
    /**
     * Filter which cotton_on_call to delete.
     */
    where: cotton_on_callWhereUniqueInput
  }


  /**
   * cotton_on_call deleteMany
   */
  export type cotton_on_callDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which cotton_on_calls to delete
     */
    where?: cotton_on_callWhereInput
  }


  /**
   * cotton_on_call without action
   */
  export type cotton_on_callArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_on_call
     */
    select?: cotton_on_callSelect<ExtArgs> | null
  }



  /**
   * Model comments
   */


  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsMinAggregateOutputType = {
    record_id: string | null
    comment: string | null
    section: string | null
    date_of_comment: Date | null
    added_by: string | null
  }

  export type CommentsMaxAggregateOutputType = {
    record_id: string | null
    comment: string | null
    section: string | null
    date_of_comment: Date | null
    added_by: string | null
  }

  export type CommentsCountAggregateOutputType = {
    record_id: number
    comment: number
    section: number
    date_of_comment: number
    added_by: number
    _all: number
  }


  export type CommentsMinAggregateInputType = {
    record_id?: true
    comment?: true
    section?: true
    date_of_comment?: true
    added_by?: true
  }

  export type CommentsMaxAggregateInputType = {
    record_id?: true
    comment?: true
    section?: true
    date_of_comment?: true
    added_by?: true
  }

  export type CommentsCountAggregateInputType = {
    record_id?: true
    comment?: true
    section?: true
    date_of_comment?: true
    added_by?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to aggregate.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: Enumerable<commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type CommentsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
    orderBy?: Enumerable<commentsOrderByWithAggregationInput>
    by: CommentsScalarFieldEnum[]
    having?: commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }


  export type CommentsGroupByOutputType = {
    record_id: string
    comment: string
    section: string
    date_of_comment: Date
    added_by: string
    _count: CommentsCountAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends CommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type commentsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    comment?: boolean
    section?: boolean
    date_of_comment?: boolean
    added_by?: boolean
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectScalar = {
    record_id?: boolean
    comment?: boolean
    section?: boolean
    date_of_comment?: boolean
    added_by?: boolean
  }


  type commentsGetPayload<S extends boolean | null | undefined | commentsArgs> = $Types.GetResult<commentsPayload, S>

  type commentsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<commentsFindManyArgs, 'select' | 'include'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface commentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comments'], meta: { name: 'comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends commentsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'comments'> extends True ? Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Comments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends commentsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'comments'> extends True ? Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Comments that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const commentsWithRecord_idOnly = await prisma.comments.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends commentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<commentsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Comments.
     * @param {commentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
    **/
    create<T extends commentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, commentsCreateArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {commentsCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comments = await prisma.comments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends commentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comments.
     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
    **/
    delete<T extends commentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Comments.
     * @param {commentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends commentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends commentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends commentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comments.
     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
    **/
    upsert<T extends commentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>
    ): Prisma__commentsClient<$Types.GetResult<commentsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends commentsCountArgs>(
      args?: Subset<T, commentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentsGroupByArgs['orderBy'] }
        : { orderBy?: CommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__commentsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * comments base type for findUnique actions
   */
  export type commentsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findUnique
   */
  export interface commentsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends commentsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * comments findUniqueOrThrow
   */
  export type commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }


  /**
   * comments base type for findFirst actions
   */
  export type commentsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: Enumerable<commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }

  /**
   * comments findFirst
   */
  export interface commentsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends commentsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * comments findFirstOrThrow
   */
  export type commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: Enumerable<commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }


  /**
   * comments findMany
   */
  export type commentsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: Enumerable<commentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }


  /**
   * comments create
   */
  export type commentsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * The data needed to create a comments.
     */
    data: XOR<commentsCreateInput, commentsUncheckedCreateInput>
  }


  /**
   * comments createMany
   */
  export type commentsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comments.
     */
    data: Enumerable<commentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * comments update
   */
  export type commentsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * The data needed to update a comments.
     */
    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
    /**
     * Choose, which comments to update.
     */
    where: commentsWhereUniqueInput
  }


  /**
   * comments updateMany
   */
  export type commentsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
  }


  /**
   * comments upsert
   */
  export type commentsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * The filter to search for the comments to update in case it exists.
     */
    where: commentsWhereUniqueInput
    /**
     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.
     */
    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>
    /**
     * In case the comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
  }


  /**
   * comments delete
   */
  export type commentsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Filter which comments to delete.
     */
    where: commentsWhereUniqueInput
  }


  /**
   * comments deleteMany
   */
  export type commentsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to delete
     */
    where?: commentsWhereInput
  }


  /**
   * comments without action
   */
  export type commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
  }



  /**
   * Model future_contracts_study
   */


  export type AggregateFuture_contracts_study = {
    _count: Future_contracts_studyCountAggregateOutputType | null
    _avg: Future_contracts_studyAvgAggregateOutputType | null
    _sum: Future_contracts_studySumAggregateOutputType | null
    _min: Future_contracts_studyMinAggregateOutputType | null
    _max: Future_contracts_studyMaxAggregateOutputType | null
  }

  export type Future_contracts_studyAvgAggregateOutputType = {
    month_of_high: number | null
    high: Decimal | null
    month_of_low: number | null
    low: Decimal | null
    price_range_between_high_and_low: Decimal | null
    day_range_between_high_and_low: Decimal | null
  }

  export type Future_contracts_studySumAggregateOutputType = {
    month_of_high: number | null
    high: Decimal | null
    month_of_low: number | null
    low: Decimal | null
    price_range_between_high_and_low: Decimal | null
    day_range_between_high_and_low: Decimal | null
  }

  export type Future_contracts_studyMinAggregateOutputType = {
    record_id: string | null
    year: string | null
    month_of_high: number | null
    date_of_high: Date | null
    high: Decimal | null
    month_of_low: number | null
    date_of_low: Date | null
    low: Decimal | null
    price_range_between_high_and_low: Decimal | null
    day_range_between_high_and_low: Decimal | null
    inverse: string | null
    comments: string | null
  }

  export type Future_contracts_studyMaxAggregateOutputType = {
    record_id: string | null
    year: string | null
    month_of_high: number | null
    date_of_high: Date | null
    high: Decimal | null
    month_of_low: number | null
    date_of_low: Date | null
    low: Decimal | null
    price_range_between_high_and_low: Decimal | null
    day_range_between_high_and_low: Decimal | null
    inverse: string | null
    comments: string | null
  }

  export type Future_contracts_studyCountAggregateOutputType = {
    record_id: number
    year: number
    month_of_high: number
    date_of_high: number
    high: number
    month_of_low: number
    date_of_low: number
    low: number
    price_range_between_high_and_low: number
    day_range_between_high_and_low: number
    inverse: number
    comments: number
    _all: number
  }


  export type Future_contracts_studyAvgAggregateInputType = {
    month_of_high?: true
    high?: true
    month_of_low?: true
    low?: true
    price_range_between_high_and_low?: true
    day_range_between_high_and_low?: true
  }

  export type Future_contracts_studySumAggregateInputType = {
    month_of_high?: true
    high?: true
    month_of_low?: true
    low?: true
    price_range_between_high_and_low?: true
    day_range_between_high_and_low?: true
  }

  export type Future_contracts_studyMinAggregateInputType = {
    record_id?: true
    year?: true
    month_of_high?: true
    date_of_high?: true
    high?: true
    month_of_low?: true
    date_of_low?: true
    low?: true
    price_range_between_high_and_low?: true
    day_range_between_high_and_low?: true
    inverse?: true
    comments?: true
  }

  export type Future_contracts_studyMaxAggregateInputType = {
    record_id?: true
    year?: true
    month_of_high?: true
    date_of_high?: true
    high?: true
    month_of_low?: true
    date_of_low?: true
    low?: true
    price_range_between_high_and_low?: true
    day_range_between_high_and_low?: true
    inverse?: true
    comments?: true
  }

  export type Future_contracts_studyCountAggregateInputType = {
    record_id?: true
    year?: true
    month_of_high?: true
    date_of_high?: true
    high?: true
    month_of_low?: true
    date_of_low?: true
    low?: true
    price_range_between_high_and_low?: true
    day_range_between_high_and_low?: true
    inverse?: true
    comments?: true
    _all?: true
  }

  export type Future_contracts_studyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which future_contracts_study to aggregate.
     */
    where?: future_contracts_studyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of future_contracts_studies to fetch.
     */
    orderBy?: Enumerable<future_contracts_studyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: future_contracts_studyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` future_contracts_studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` future_contracts_studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned future_contracts_studies
    **/
    _count?: true | Future_contracts_studyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Future_contracts_studyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Future_contracts_studySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Future_contracts_studyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Future_contracts_studyMaxAggregateInputType
  }

  export type GetFuture_contracts_studyAggregateType<T extends Future_contracts_studyAggregateArgs> = {
        [P in keyof T & keyof AggregateFuture_contracts_study]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFuture_contracts_study[P]>
      : GetScalarType<T[P], AggregateFuture_contracts_study[P]>
  }




  export type Future_contracts_studyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: future_contracts_studyWhereInput
    orderBy?: Enumerable<future_contracts_studyOrderByWithAggregationInput>
    by: Future_contracts_studyScalarFieldEnum[]
    having?: future_contracts_studyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Future_contracts_studyCountAggregateInputType | true
    _avg?: Future_contracts_studyAvgAggregateInputType
    _sum?: Future_contracts_studySumAggregateInputType
    _min?: Future_contracts_studyMinAggregateInputType
    _max?: Future_contracts_studyMaxAggregateInputType
  }


  export type Future_contracts_studyGroupByOutputType = {
    record_id: string
    year: string
    month_of_high: number | null
    date_of_high: Date | null
    high: Decimal | null
    month_of_low: number | null
    date_of_low: Date | null
    low: Decimal | null
    price_range_between_high_and_low: Decimal | null
    day_range_between_high_and_low: Decimal | null
    inverse: string | null
    comments: string | null
    _count: Future_contracts_studyCountAggregateOutputType | null
    _avg: Future_contracts_studyAvgAggregateOutputType | null
    _sum: Future_contracts_studySumAggregateOutputType | null
    _min: Future_contracts_studyMinAggregateOutputType | null
    _max: Future_contracts_studyMaxAggregateOutputType | null
  }

  type GetFuture_contracts_studyGroupByPayload<T extends Future_contracts_studyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Future_contracts_studyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Future_contracts_studyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Future_contracts_studyGroupByOutputType[P]>
            : GetScalarType<T[P], Future_contracts_studyGroupByOutputType[P]>
        }
      >
    >


  export type future_contracts_studySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    year?: boolean
    month_of_high?: boolean
    date_of_high?: boolean
    high?: boolean
    month_of_low?: boolean
    date_of_low?: boolean
    low?: boolean
    price_range_between_high_and_low?: boolean
    day_range_between_high_and_low?: boolean
    inverse?: boolean
    comments?: boolean
  }, ExtArgs["result"]["future_contracts_study"]>

  export type future_contracts_studySelectScalar = {
    record_id?: boolean
    year?: boolean
    month_of_high?: boolean
    date_of_high?: boolean
    high?: boolean
    month_of_low?: boolean
    date_of_low?: boolean
    low?: boolean
    price_range_between_high_and_low?: boolean
    day_range_between_high_and_low?: boolean
    inverse?: boolean
    comments?: boolean
  }


  type future_contracts_studyGetPayload<S extends boolean | null | undefined | future_contracts_studyArgs> = $Types.GetResult<future_contracts_studyPayload, S>

  type future_contracts_studyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<future_contracts_studyFindManyArgs, 'select' | 'include'> & {
      select?: Future_contracts_studyCountAggregateInputType | true
    }

  export interface future_contracts_studyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['future_contracts_study'], meta: { name: 'future_contracts_study' } }
    /**
     * Find zero or one Future_contracts_study that matches the filter.
     * @param {future_contracts_studyFindUniqueArgs} args - Arguments to find a Future_contracts_study
     * @example
     * // Get one Future_contracts_study
     * const future_contracts_study = await prisma.future_contracts_study.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends future_contracts_studyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, future_contracts_studyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'future_contracts_study'> extends True ? Prisma__future_contracts_studyClient<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__future_contracts_studyClient<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Future_contracts_study that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {future_contracts_studyFindUniqueOrThrowArgs} args - Arguments to find a Future_contracts_study
     * @example
     * // Get one Future_contracts_study
     * const future_contracts_study = await prisma.future_contracts_study.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends future_contracts_studyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, future_contracts_studyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__future_contracts_studyClient<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Future_contracts_study that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {future_contracts_studyFindFirstArgs} args - Arguments to find a Future_contracts_study
     * @example
     * // Get one Future_contracts_study
     * const future_contracts_study = await prisma.future_contracts_study.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends future_contracts_studyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, future_contracts_studyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'future_contracts_study'> extends True ? Prisma__future_contracts_studyClient<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__future_contracts_studyClient<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Future_contracts_study that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {future_contracts_studyFindFirstOrThrowArgs} args - Arguments to find a Future_contracts_study
     * @example
     * // Get one Future_contracts_study
     * const future_contracts_study = await prisma.future_contracts_study.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends future_contracts_studyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, future_contracts_studyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__future_contracts_studyClient<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Future_contracts_studies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {future_contracts_studyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Future_contracts_studies
     * const future_contracts_studies = await prisma.future_contracts_study.findMany()
     * 
     * // Get first 10 Future_contracts_studies
     * const future_contracts_studies = await prisma.future_contracts_study.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const future_contracts_studyWithRecord_idOnly = await prisma.future_contracts_study.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends future_contracts_studyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, future_contracts_studyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Future_contracts_study.
     * @param {future_contracts_studyCreateArgs} args - Arguments to create a Future_contracts_study.
     * @example
     * // Create one Future_contracts_study
     * const Future_contracts_study = await prisma.future_contracts_study.create({
     *   data: {
     *     // ... data to create a Future_contracts_study
     *   }
     * })
     * 
    **/
    create<T extends future_contracts_studyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, future_contracts_studyCreateArgs<ExtArgs>>
    ): Prisma__future_contracts_studyClient<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Future_contracts_studies.
     *     @param {future_contracts_studyCreateManyArgs} args - Arguments to create many Future_contracts_studies.
     *     @example
     *     // Create many Future_contracts_studies
     *     const future_contracts_study = await prisma.future_contracts_study.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends future_contracts_studyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, future_contracts_studyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Future_contracts_study.
     * @param {future_contracts_studyDeleteArgs} args - Arguments to delete one Future_contracts_study.
     * @example
     * // Delete one Future_contracts_study
     * const Future_contracts_study = await prisma.future_contracts_study.delete({
     *   where: {
     *     // ... filter to delete one Future_contracts_study
     *   }
     * })
     * 
    **/
    delete<T extends future_contracts_studyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, future_contracts_studyDeleteArgs<ExtArgs>>
    ): Prisma__future_contracts_studyClient<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Future_contracts_study.
     * @param {future_contracts_studyUpdateArgs} args - Arguments to update one Future_contracts_study.
     * @example
     * // Update one Future_contracts_study
     * const future_contracts_study = await prisma.future_contracts_study.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends future_contracts_studyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, future_contracts_studyUpdateArgs<ExtArgs>>
    ): Prisma__future_contracts_studyClient<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Future_contracts_studies.
     * @param {future_contracts_studyDeleteManyArgs} args - Arguments to filter Future_contracts_studies to delete.
     * @example
     * // Delete a few Future_contracts_studies
     * const { count } = await prisma.future_contracts_study.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends future_contracts_studyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, future_contracts_studyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Future_contracts_studies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {future_contracts_studyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Future_contracts_studies
     * const future_contracts_study = await prisma.future_contracts_study.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends future_contracts_studyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, future_contracts_studyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Future_contracts_study.
     * @param {future_contracts_studyUpsertArgs} args - Arguments to update or create a Future_contracts_study.
     * @example
     * // Update or create a Future_contracts_study
     * const future_contracts_study = await prisma.future_contracts_study.upsert({
     *   create: {
     *     // ... data to create a Future_contracts_study
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Future_contracts_study we want to update
     *   }
     * })
    **/
    upsert<T extends future_contracts_studyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, future_contracts_studyUpsertArgs<ExtArgs>>
    ): Prisma__future_contracts_studyClient<$Types.GetResult<future_contracts_studyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Future_contracts_studies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {future_contracts_studyCountArgs} args - Arguments to filter Future_contracts_studies to count.
     * @example
     * // Count the number of Future_contracts_studies
     * const count = await prisma.future_contracts_study.count({
     *   where: {
     *     // ... the filter for the Future_contracts_studies we want to count
     *   }
     * })
    **/
    count<T extends future_contracts_studyCountArgs>(
      args?: Subset<T, future_contracts_studyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Future_contracts_studyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Future_contracts_study.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Future_contracts_studyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Future_contracts_studyAggregateArgs>(args: Subset<T, Future_contracts_studyAggregateArgs>): Prisma.PrismaPromise<GetFuture_contracts_studyAggregateType<T>>

    /**
     * Group by Future_contracts_study.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Future_contracts_studyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Future_contracts_studyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Future_contracts_studyGroupByArgs['orderBy'] }
        : { orderBy?: Future_contracts_studyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Future_contracts_studyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFuture_contracts_studyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for future_contracts_study.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__future_contracts_studyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * future_contracts_study base type for findUnique actions
   */
  export type future_contracts_studyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the future_contracts_study
     */
    select?: future_contracts_studySelect<ExtArgs> | null
    /**
     * Filter, which future_contracts_study to fetch.
     */
    where: future_contracts_studyWhereUniqueInput
  }

  /**
   * future_contracts_study findUnique
   */
  export interface future_contracts_studyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends future_contracts_studyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * future_contracts_study findUniqueOrThrow
   */
  export type future_contracts_studyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the future_contracts_study
     */
    select?: future_contracts_studySelect<ExtArgs> | null
    /**
     * Filter, which future_contracts_study to fetch.
     */
    where: future_contracts_studyWhereUniqueInput
  }


  /**
   * future_contracts_study base type for findFirst actions
   */
  export type future_contracts_studyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the future_contracts_study
     */
    select?: future_contracts_studySelect<ExtArgs> | null
    /**
     * Filter, which future_contracts_study to fetch.
     */
    where?: future_contracts_studyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of future_contracts_studies to fetch.
     */
    orderBy?: Enumerable<future_contracts_studyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for future_contracts_studies.
     */
    cursor?: future_contracts_studyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` future_contracts_studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` future_contracts_studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of future_contracts_studies.
     */
    distinct?: Enumerable<Future_contracts_studyScalarFieldEnum>
  }

  /**
   * future_contracts_study findFirst
   */
  export interface future_contracts_studyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends future_contracts_studyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * future_contracts_study findFirstOrThrow
   */
  export type future_contracts_studyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the future_contracts_study
     */
    select?: future_contracts_studySelect<ExtArgs> | null
    /**
     * Filter, which future_contracts_study to fetch.
     */
    where?: future_contracts_studyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of future_contracts_studies to fetch.
     */
    orderBy?: Enumerable<future_contracts_studyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for future_contracts_studies.
     */
    cursor?: future_contracts_studyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` future_contracts_studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` future_contracts_studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of future_contracts_studies.
     */
    distinct?: Enumerable<Future_contracts_studyScalarFieldEnum>
  }


  /**
   * future_contracts_study findMany
   */
  export type future_contracts_studyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the future_contracts_study
     */
    select?: future_contracts_studySelect<ExtArgs> | null
    /**
     * Filter, which future_contracts_studies to fetch.
     */
    where?: future_contracts_studyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of future_contracts_studies to fetch.
     */
    orderBy?: Enumerable<future_contracts_studyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing future_contracts_studies.
     */
    cursor?: future_contracts_studyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` future_contracts_studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` future_contracts_studies.
     */
    skip?: number
    distinct?: Enumerable<Future_contracts_studyScalarFieldEnum>
  }


  /**
   * future_contracts_study create
   */
  export type future_contracts_studyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the future_contracts_study
     */
    select?: future_contracts_studySelect<ExtArgs> | null
    /**
     * The data needed to create a future_contracts_study.
     */
    data: XOR<future_contracts_studyCreateInput, future_contracts_studyUncheckedCreateInput>
  }


  /**
   * future_contracts_study createMany
   */
  export type future_contracts_studyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many future_contracts_studies.
     */
    data: Enumerable<future_contracts_studyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * future_contracts_study update
   */
  export type future_contracts_studyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the future_contracts_study
     */
    select?: future_contracts_studySelect<ExtArgs> | null
    /**
     * The data needed to update a future_contracts_study.
     */
    data: XOR<future_contracts_studyUpdateInput, future_contracts_studyUncheckedUpdateInput>
    /**
     * Choose, which future_contracts_study to update.
     */
    where: future_contracts_studyWhereUniqueInput
  }


  /**
   * future_contracts_study updateMany
   */
  export type future_contracts_studyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update future_contracts_studies.
     */
    data: XOR<future_contracts_studyUpdateManyMutationInput, future_contracts_studyUncheckedUpdateManyInput>
    /**
     * Filter which future_contracts_studies to update
     */
    where?: future_contracts_studyWhereInput
  }


  /**
   * future_contracts_study upsert
   */
  export type future_contracts_studyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the future_contracts_study
     */
    select?: future_contracts_studySelect<ExtArgs> | null
    /**
     * The filter to search for the future_contracts_study to update in case it exists.
     */
    where: future_contracts_studyWhereUniqueInput
    /**
     * In case the future_contracts_study found by the `where` argument doesn't exist, create a new future_contracts_study with this data.
     */
    create: XOR<future_contracts_studyCreateInput, future_contracts_studyUncheckedCreateInput>
    /**
     * In case the future_contracts_study was found with the provided `where` argument, update it with this data.
     */
    update: XOR<future_contracts_studyUpdateInput, future_contracts_studyUncheckedUpdateInput>
  }


  /**
   * future_contracts_study delete
   */
  export type future_contracts_studyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the future_contracts_study
     */
    select?: future_contracts_studySelect<ExtArgs> | null
    /**
     * Filter which future_contracts_study to delete.
     */
    where: future_contracts_studyWhereUniqueInput
  }


  /**
   * future_contracts_study deleteMany
   */
  export type future_contracts_studyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which future_contracts_studies to delete
     */
    where?: future_contracts_studyWhereInput
  }


  /**
   * future_contracts_study without action
   */
  export type future_contracts_studyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the future_contracts_study
     */
    select?: future_contracts_studySelect<ExtArgs> | null
  }



  /**
   * Model cotton_contracts
   */


  export type AggregateCotton_contracts = {
    _count: Cotton_contractsCountAggregateOutputType | null
    _avg: Cotton_contractsAvgAggregateOutputType | null
    _sum: Cotton_contractsSumAggregateOutputType | null
    _min: Cotton_contractsMinAggregateOutputType | null
    _max: Cotton_contractsMaxAggregateOutputType | null
  }

  export type Cotton_contractsAvgAggregateOutputType = {
    high: Decimal | null
    low: Decimal | null
    open: Decimal | null
    close: Decimal | null
    change: Decimal | null
    rolling_average_200_day: Decimal | null
    rolling_average_100_day: Decimal | null
    rolling_average_50_day: Decimal | null
  }

  export type Cotton_contractsSumAggregateOutputType = {
    high: Decimal | null
    low: Decimal | null
    open: Decimal | null
    close: Decimal | null
    change: Decimal | null
    rolling_average_200_day: Decimal | null
    rolling_average_100_day: Decimal | null
    rolling_average_50_day: Decimal | null
  }

  export type Cotton_contractsMinAggregateOutputType = {
    record_id: string | null
    datetime: Date | null
    contract: string | null
    high: Decimal | null
    low: Decimal | null
    open: Decimal | null
    close: Decimal | null
    change: Decimal | null
    rolling_average_200_day: Decimal | null
    rolling_average_100_day: Decimal | null
    rolling_average_50_day: Decimal | null
  }

  export type Cotton_contractsMaxAggregateOutputType = {
    record_id: string | null
    datetime: Date | null
    contract: string | null
    high: Decimal | null
    low: Decimal | null
    open: Decimal | null
    close: Decimal | null
    change: Decimal | null
    rolling_average_200_day: Decimal | null
    rolling_average_100_day: Decimal | null
    rolling_average_50_day: Decimal | null
  }

  export type Cotton_contractsCountAggregateOutputType = {
    record_id: number
    datetime: number
    contract: number
    high: number
    low: number
    open: number
    close: number
    change: number
    rolling_average_200_day: number
    rolling_average_100_day: number
    rolling_average_50_day: number
    _all: number
  }


  export type Cotton_contractsAvgAggregateInputType = {
    high?: true
    low?: true
    open?: true
    close?: true
    change?: true
    rolling_average_200_day?: true
    rolling_average_100_day?: true
    rolling_average_50_day?: true
  }

  export type Cotton_contractsSumAggregateInputType = {
    high?: true
    low?: true
    open?: true
    close?: true
    change?: true
    rolling_average_200_day?: true
    rolling_average_100_day?: true
    rolling_average_50_day?: true
  }

  export type Cotton_contractsMinAggregateInputType = {
    record_id?: true
    datetime?: true
    contract?: true
    high?: true
    low?: true
    open?: true
    close?: true
    change?: true
    rolling_average_200_day?: true
    rolling_average_100_day?: true
    rolling_average_50_day?: true
  }

  export type Cotton_contractsMaxAggregateInputType = {
    record_id?: true
    datetime?: true
    contract?: true
    high?: true
    low?: true
    open?: true
    close?: true
    change?: true
    rolling_average_200_day?: true
    rolling_average_100_day?: true
    rolling_average_50_day?: true
  }

  export type Cotton_contractsCountAggregateInputType = {
    record_id?: true
    datetime?: true
    contract?: true
    high?: true
    low?: true
    open?: true
    close?: true
    change?: true
    rolling_average_200_day?: true
    rolling_average_100_day?: true
    rolling_average_50_day?: true
    _all?: true
  }

  export type Cotton_contractsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which cotton_contracts to aggregate.
     */
    where?: cotton_contractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotton_contracts to fetch.
     */
    orderBy?: Enumerable<cotton_contractsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cotton_contractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotton_contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotton_contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cotton_contracts
    **/
    _count?: true | Cotton_contractsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cotton_contractsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cotton_contractsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cotton_contractsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cotton_contractsMaxAggregateInputType
  }

  export type GetCotton_contractsAggregateType<T extends Cotton_contractsAggregateArgs> = {
        [P in keyof T & keyof AggregateCotton_contracts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCotton_contracts[P]>
      : GetScalarType<T[P], AggregateCotton_contracts[P]>
  }




  export type Cotton_contractsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: cotton_contractsWhereInput
    orderBy?: Enumerable<cotton_contractsOrderByWithAggregationInput>
    by: Cotton_contractsScalarFieldEnum[]
    having?: cotton_contractsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cotton_contractsCountAggregateInputType | true
    _avg?: Cotton_contractsAvgAggregateInputType
    _sum?: Cotton_contractsSumAggregateInputType
    _min?: Cotton_contractsMinAggregateInputType
    _max?: Cotton_contractsMaxAggregateInputType
  }


  export type Cotton_contractsGroupByOutputType = {
    record_id: string
    datetime: Date
    contract: string
    high: Decimal | null
    low: Decimal | null
    open: Decimal | null
    close: Decimal | null
    change: Decimal | null
    rolling_average_200_day: Decimal | null
    rolling_average_100_day: Decimal | null
    rolling_average_50_day: Decimal | null
    _count: Cotton_contractsCountAggregateOutputType | null
    _avg: Cotton_contractsAvgAggregateOutputType | null
    _sum: Cotton_contractsSumAggregateOutputType | null
    _min: Cotton_contractsMinAggregateOutputType | null
    _max: Cotton_contractsMaxAggregateOutputType | null
  }

  type GetCotton_contractsGroupByPayload<T extends Cotton_contractsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Cotton_contractsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cotton_contractsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cotton_contractsGroupByOutputType[P]>
            : GetScalarType<T[P], Cotton_contractsGroupByOutputType[P]>
        }
      >
    >


  export type cotton_contractsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    datetime?: boolean
    contract?: boolean
    high?: boolean
    low?: boolean
    open?: boolean
    close?: boolean
    change?: boolean
    rolling_average_200_day?: boolean
    rolling_average_100_day?: boolean
    rolling_average_50_day?: boolean
  }, ExtArgs["result"]["cotton_contracts"]>

  export type cotton_contractsSelectScalar = {
    record_id?: boolean
    datetime?: boolean
    contract?: boolean
    high?: boolean
    low?: boolean
    open?: boolean
    close?: boolean
    change?: boolean
    rolling_average_200_day?: boolean
    rolling_average_100_day?: boolean
    rolling_average_50_day?: boolean
  }


  type cotton_contractsGetPayload<S extends boolean | null | undefined | cotton_contractsArgs> = $Types.GetResult<cotton_contractsPayload, S>

  type cotton_contractsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<cotton_contractsFindManyArgs, 'select' | 'include'> & {
      select?: Cotton_contractsCountAggregateInputType | true
    }

  export interface cotton_contractsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cotton_contracts'], meta: { name: 'cotton_contracts' } }
    /**
     * Find zero or one Cotton_contracts that matches the filter.
     * @param {cotton_contractsFindUniqueArgs} args - Arguments to find a Cotton_contracts
     * @example
     * // Get one Cotton_contracts
     * const cotton_contracts = await prisma.cotton_contracts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cotton_contractsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cotton_contractsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cotton_contracts'> extends True ? Prisma__cotton_contractsClient<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__cotton_contractsClient<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Cotton_contracts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cotton_contractsFindUniqueOrThrowArgs} args - Arguments to find a Cotton_contracts
     * @example
     * // Get one Cotton_contracts
     * const cotton_contracts = await prisma.cotton_contracts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cotton_contractsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cotton_contractsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__cotton_contractsClient<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Cotton_contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotton_contractsFindFirstArgs} args - Arguments to find a Cotton_contracts
     * @example
     * // Get one Cotton_contracts
     * const cotton_contracts = await prisma.cotton_contracts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cotton_contractsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cotton_contractsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cotton_contracts'> extends True ? Prisma__cotton_contractsClient<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__cotton_contractsClient<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Cotton_contracts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotton_contractsFindFirstOrThrowArgs} args - Arguments to find a Cotton_contracts
     * @example
     * // Get one Cotton_contracts
     * const cotton_contracts = await prisma.cotton_contracts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cotton_contractsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cotton_contractsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__cotton_contractsClient<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Cotton_contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotton_contractsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cotton_contracts
     * const cotton_contracts = await prisma.cotton_contracts.findMany()
     * 
     * // Get first 10 Cotton_contracts
     * const cotton_contracts = await prisma.cotton_contracts.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const cotton_contractsWithRecord_idOnly = await prisma.cotton_contracts.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends cotton_contractsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cotton_contractsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Cotton_contracts.
     * @param {cotton_contractsCreateArgs} args - Arguments to create a Cotton_contracts.
     * @example
     * // Create one Cotton_contracts
     * const Cotton_contracts = await prisma.cotton_contracts.create({
     *   data: {
     *     // ... data to create a Cotton_contracts
     *   }
     * })
     * 
    **/
    create<T extends cotton_contractsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, cotton_contractsCreateArgs<ExtArgs>>
    ): Prisma__cotton_contractsClient<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Cotton_contracts.
     *     @param {cotton_contractsCreateManyArgs} args - Arguments to create many Cotton_contracts.
     *     @example
     *     // Create many Cotton_contracts
     *     const cotton_contracts = await prisma.cotton_contracts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cotton_contractsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cotton_contractsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cotton_contracts.
     * @param {cotton_contractsDeleteArgs} args - Arguments to delete one Cotton_contracts.
     * @example
     * // Delete one Cotton_contracts
     * const Cotton_contracts = await prisma.cotton_contracts.delete({
     *   where: {
     *     // ... filter to delete one Cotton_contracts
     *   }
     * })
     * 
    **/
    delete<T extends cotton_contractsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, cotton_contractsDeleteArgs<ExtArgs>>
    ): Prisma__cotton_contractsClient<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Cotton_contracts.
     * @param {cotton_contractsUpdateArgs} args - Arguments to update one Cotton_contracts.
     * @example
     * // Update one Cotton_contracts
     * const cotton_contracts = await prisma.cotton_contracts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cotton_contractsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, cotton_contractsUpdateArgs<ExtArgs>>
    ): Prisma__cotton_contractsClient<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Cotton_contracts.
     * @param {cotton_contractsDeleteManyArgs} args - Arguments to filter Cotton_contracts to delete.
     * @example
     * // Delete a few Cotton_contracts
     * const { count } = await prisma.cotton_contracts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cotton_contractsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cotton_contractsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cotton_contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotton_contractsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cotton_contracts
     * const cotton_contracts = await prisma.cotton_contracts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cotton_contractsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, cotton_contractsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cotton_contracts.
     * @param {cotton_contractsUpsertArgs} args - Arguments to update or create a Cotton_contracts.
     * @example
     * // Update or create a Cotton_contracts
     * const cotton_contracts = await prisma.cotton_contracts.upsert({
     *   create: {
     *     // ... data to create a Cotton_contracts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cotton_contracts we want to update
     *   }
     * })
    **/
    upsert<T extends cotton_contractsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, cotton_contractsUpsertArgs<ExtArgs>>
    ): Prisma__cotton_contractsClient<$Types.GetResult<cotton_contractsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Cotton_contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cotton_contractsCountArgs} args - Arguments to filter Cotton_contracts to count.
     * @example
     * // Count the number of Cotton_contracts
     * const count = await prisma.cotton_contracts.count({
     *   where: {
     *     // ... the filter for the Cotton_contracts we want to count
     *   }
     * })
    **/
    count<T extends cotton_contractsCountArgs>(
      args?: Subset<T, cotton_contractsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cotton_contractsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cotton_contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cotton_contractsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cotton_contractsAggregateArgs>(args: Subset<T, Cotton_contractsAggregateArgs>): Prisma.PrismaPromise<GetCotton_contractsAggregateType<T>>

    /**
     * Group by Cotton_contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cotton_contractsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Cotton_contractsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Cotton_contractsGroupByArgs['orderBy'] }
        : { orderBy?: Cotton_contractsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Cotton_contractsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCotton_contractsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cotton_contracts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cotton_contractsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cotton_contracts base type for findUnique actions
   */
  export type cotton_contractsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_contracts
     */
    select?: cotton_contractsSelect<ExtArgs> | null
    /**
     * Filter, which cotton_contracts to fetch.
     */
    where: cotton_contractsWhereUniqueInput
  }

  /**
   * cotton_contracts findUnique
   */
  export interface cotton_contractsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends cotton_contractsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cotton_contracts findUniqueOrThrow
   */
  export type cotton_contractsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_contracts
     */
    select?: cotton_contractsSelect<ExtArgs> | null
    /**
     * Filter, which cotton_contracts to fetch.
     */
    where: cotton_contractsWhereUniqueInput
  }


  /**
   * cotton_contracts base type for findFirst actions
   */
  export type cotton_contractsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_contracts
     */
    select?: cotton_contractsSelect<ExtArgs> | null
    /**
     * Filter, which cotton_contracts to fetch.
     */
    where?: cotton_contractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotton_contracts to fetch.
     */
    orderBy?: Enumerable<cotton_contractsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cotton_contracts.
     */
    cursor?: cotton_contractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotton_contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotton_contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cotton_contracts.
     */
    distinct?: Enumerable<Cotton_contractsScalarFieldEnum>
  }

  /**
   * cotton_contracts findFirst
   */
  export interface cotton_contractsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends cotton_contractsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cotton_contracts findFirstOrThrow
   */
  export type cotton_contractsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_contracts
     */
    select?: cotton_contractsSelect<ExtArgs> | null
    /**
     * Filter, which cotton_contracts to fetch.
     */
    where?: cotton_contractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotton_contracts to fetch.
     */
    orderBy?: Enumerable<cotton_contractsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cotton_contracts.
     */
    cursor?: cotton_contractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotton_contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotton_contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cotton_contracts.
     */
    distinct?: Enumerable<Cotton_contractsScalarFieldEnum>
  }


  /**
   * cotton_contracts findMany
   */
  export type cotton_contractsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_contracts
     */
    select?: cotton_contractsSelect<ExtArgs> | null
    /**
     * Filter, which cotton_contracts to fetch.
     */
    where?: cotton_contractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cotton_contracts to fetch.
     */
    orderBy?: Enumerable<cotton_contractsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cotton_contracts.
     */
    cursor?: cotton_contractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cotton_contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cotton_contracts.
     */
    skip?: number
    distinct?: Enumerable<Cotton_contractsScalarFieldEnum>
  }


  /**
   * cotton_contracts create
   */
  export type cotton_contractsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_contracts
     */
    select?: cotton_contractsSelect<ExtArgs> | null
    /**
     * The data needed to create a cotton_contracts.
     */
    data: XOR<cotton_contractsCreateInput, cotton_contractsUncheckedCreateInput>
  }


  /**
   * cotton_contracts createMany
   */
  export type cotton_contractsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cotton_contracts.
     */
    data: Enumerable<cotton_contractsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cotton_contracts update
   */
  export type cotton_contractsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_contracts
     */
    select?: cotton_contractsSelect<ExtArgs> | null
    /**
     * The data needed to update a cotton_contracts.
     */
    data: XOR<cotton_contractsUpdateInput, cotton_contractsUncheckedUpdateInput>
    /**
     * Choose, which cotton_contracts to update.
     */
    where: cotton_contractsWhereUniqueInput
  }


  /**
   * cotton_contracts updateMany
   */
  export type cotton_contractsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cotton_contracts.
     */
    data: XOR<cotton_contractsUpdateManyMutationInput, cotton_contractsUncheckedUpdateManyInput>
    /**
     * Filter which cotton_contracts to update
     */
    where?: cotton_contractsWhereInput
  }


  /**
   * cotton_contracts upsert
   */
  export type cotton_contractsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_contracts
     */
    select?: cotton_contractsSelect<ExtArgs> | null
    /**
     * The filter to search for the cotton_contracts to update in case it exists.
     */
    where: cotton_contractsWhereUniqueInput
    /**
     * In case the cotton_contracts found by the `where` argument doesn't exist, create a new cotton_contracts with this data.
     */
    create: XOR<cotton_contractsCreateInput, cotton_contractsUncheckedCreateInput>
    /**
     * In case the cotton_contracts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cotton_contractsUpdateInput, cotton_contractsUncheckedUpdateInput>
  }


  /**
   * cotton_contracts delete
   */
  export type cotton_contractsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_contracts
     */
    select?: cotton_contractsSelect<ExtArgs> | null
    /**
     * Filter which cotton_contracts to delete.
     */
    where: cotton_contractsWhereUniqueInput
  }


  /**
   * cotton_contracts deleteMany
   */
  export type cotton_contractsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which cotton_contracts to delete
     */
    where?: cotton_contractsWhereInput
  }


  /**
   * cotton_contracts without action
   */
  export type cotton_contractsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cotton_contracts
     */
    select?: cotton_contractsSelect<ExtArgs> | null
  }



  /**
   * Model monthly_index
   */


  export type AggregateMonthly_index = {
    _count: Monthly_indexCountAggregateOutputType | null
    _avg: Monthly_indexAvgAggregateOutputType | null
    _sum: Monthly_indexSumAggregateOutputType | null
    _min: Monthly_indexMinAggregateOutputType | null
    _max: Monthly_indexMaxAggregateOutputType | null
  }

  export type Monthly_indexAvgAggregateOutputType = {
    year: number | null
  }

  export type Monthly_indexSumAggregateOutputType = {
    year: number | null
  }

  export type Monthly_indexMinAggregateOutputType = {
    record_id: string | null
    month: string | null
    year: number | null
    inverse_month: string | null
    probability_rate: string | null
  }

  export type Monthly_indexMaxAggregateOutputType = {
    record_id: string | null
    month: string | null
    year: number | null
    inverse_month: string | null
    probability_rate: string | null
  }

  export type Monthly_indexCountAggregateOutputType = {
    record_id: number
    month: number
    year: number
    inverse_month: number
    probability_rate: number
    _all: number
  }


  export type Monthly_indexAvgAggregateInputType = {
    year?: true
  }

  export type Monthly_indexSumAggregateInputType = {
    year?: true
  }

  export type Monthly_indexMinAggregateInputType = {
    record_id?: true
    month?: true
    year?: true
    inverse_month?: true
    probability_rate?: true
  }

  export type Monthly_indexMaxAggregateInputType = {
    record_id?: true
    month?: true
    year?: true
    inverse_month?: true
    probability_rate?: true
  }

  export type Monthly_indexCountAggregateInputType = {
    record_id?: true
    month?: true
    year?: true
    inverse_month?: true
    probability_rate?: true
    _all?: true
  }

  export type Monthly_indexAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which monthly_index to aggregate.
     */
    where?: monthly_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthly_indices to fetch.
     */
    orderBy?: Enumerable<monthly_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monthly_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthly_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthly_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monthly_indices
    **/
    _count?: true | Monthly_indexCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Monthly_indexAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Monthly_indexSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monthly_indexMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monthly_indexMaxAggregateInputType
  }

  export type GetMonthly_indexAggregateType<T extends Monthly_indexAggregateArgs> = {
        [P in keyof T & keyof AggregateMonthly_index]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonthly_index[P]>
      : GetScalarType<T[P], AggregateMonthly_index[P]>
  }




  export type Monthly_indexGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: monthly_indexWhereInput
    orderBy?: Enumerable<monthly_indexOrderByWithAggregationInput>
    by: Monthly_indexScalarFieldEnum[]
    having?: monthly_indexScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monthly_indexCountAggregateInputType | true
    _avg?: Monthly_indexAvgAggregateInputType
    _sum?: Monthly_indexSumAggregateInputType
    _min?: Monthly_indexMinAggregateInputType
    _max?: Monthly_indexMaxAggregateInputType
  }


  export type Monthly_indexGroupByOutputType = {
    record_id: string
    month: string
    year: number
    inverse_month: string
    probability_rate: string
    _count: Monthly_indexCountAggregateOutputType | null
    _avg: Monthly_indexAvgAggregateOutputType | null
    _sum: Monthly_indexSumAggregateOutputType | null
    _min: Monthly_indexMinAggregateOutputType | null
    _max: Monthly_indexMaxAggregateOutputType | null
  }

  type GetMonthly_indexGroupByPayload<T extends Monthly_indexGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Monthly_indexGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monthly_indexGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monthly_indexGroupByOutputType[P]>
            : GetScalarType<T[P], Monthly_indexGroupByOutputType[P]>
        }
      >
    >


  export type monthly_indexSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    month?: boolean
    year?: boolean
    inverse_month?: boolean
    probability_rate?: boolean
  }, ExtArgs["result"]["monthly_index"]>

  export type monthly_indexSelectScalar = {
    record_id?: boolean
    month?: boolean
    year?: boolean
    inverse_month?: boolean
    probability_rate?: boolean
  }


  type monthly_indexGetPayload<S extends boolean | null | undefined | monthly_indexArgs> = $Types.GetResult<monthly_indexPayload, S>

  type monthly_indexCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<monthly_indexFindManyArgs, 'select' | 'include'> & {
      select?: Monthly_indexCountAggregateInputType | true
    }

  export interface monthly_indexDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monthly_index'], meta: { name: 'monthly_index' } }
    /**
     * Find zero or one Monthly_index that matches the filter.
     * @param {monthly_indexFindUniqueArgs} args - Arguments to find a Monthly_index
     * @example
     * // Get one Monthly_index
     * const monthly_index = await prisma.monthly_index.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends monthly_indexFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, monthly_indexFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'monthly_index'> extends True ? Prisma__monthly_indexClient<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__monthly_indexClient<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Monthly_index that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {monthly_indexFindUniqueOrThrowArgs} args - Arguments to find a Monthly_index
     * @example
     * // Get one Monthly_index
     * const monthly_index = await prisma.monthly_index.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends monthly_indexFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_indexFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__monthly_indexClient<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Monthly_index that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_indexFindFirstArgs} args - Arguments to find a Monthly_index
     * @example
     * // Get one Monthly_index
     * const monthly_index = await prisma.monthly_index.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends monthly_indexFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, monthly_indexFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'monthly_index'> extends True ? Prisma__monthly_indexClient<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__monthly_indexClient<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Monthly_index that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_indexFindFirstOrThrowArgs} args - Arguments to find a Monthly_index
     * @example
     * // Get one Monthly_index
     * const monthly_index = await prisma.monthly_index.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends monthly_indexFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_indexFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__monthly_indexClient<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Monthly_indices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_indexFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monthly_indices
     * const monthly_indices = await prisma.monthly_index.findMany()
     * 
     * // Get first 10 Monthly_indices
     * const monthly_indices = await prisma.monthly_index.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const monthly_indexWithRecord_idOnly = await prisma.monthly_index.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends monthly_indexFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_indexFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Monthly_index.
     * @param {monthly_indexCreateArgs} args - Arguments to create a Monthly_index.
     * @example
     * // Create one Monthly_index
     * const Monthly_index = await prisma.monthly_index.create({
     *   data: {
     *     // ... data to create a Monthly_index
     *   }
     * })
     * 
    **/
    create<T extends monthly_indexCreateArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_indexCreateArgs<ExtArgs>>
    ): Prisma__monthly_indexClient<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Monthly_indices.
     *     @param {monthly_indexCreateManyArgs} args - Arguments to create many Monthly_indices.
     *     @example
     *     // Create many Monthly_indices
     *     const monthly_index = await prisma.monthly_index.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends monthly_indexCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_indexCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monthly_index.
     * @param {monthly_indexDeleteArgs} args - Arguments to delete one Monthly_index.
     * @example
     * // Delete one Monthly_index
     * const Monthly_index = await prisma.monthly_index.delete({
     *   where: {
     *     // ... filter to delete one Monthly_index
     *   }
     * })
     * 
    **/
    delete<T extends monthly_indexDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_indexDeleteArgs<ExtArgs>>
    ): Prisma__monthly_indexClient<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Monthly_index.
     * @param {monthly_indexUpdateArgs} args - Arguments to update one Monthly_index.
     * @example
     * // Update one Monthly_index
     * const monthly_index = await prisma.monthly_index.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends monthly_indexUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_indexUpdateArgs<ExtArgs>>
    ): Prisma__monthly_indexClient<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Monthly_indices.
     * @param {monthly_indexDeleteManyArgs} args - Arguments to filter Monthly_indices to delete.
     * @example
     * // Delete a few Monthly_indices
     * const { count } = await prisma.monthly_index.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends monthly_indexDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, monthly_indexDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monthly_indices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_indexUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monthly_indices
     * const monthly_index = await prisma.monthly_index.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends monthly_indexUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_indexUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monthly_index.
     * @param {monthly_indexUpsertArgs} args - Arguments to update or create a Monthly_index.
     * @example
     * // Update or create a Monthly_index
     * const monthly_index = await prisma.monthly_index.upsert({
     *   create: {
     *     // ... data to create a Monthly_index
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monthly_index we want to update
     *   }
     * })
    **/
    upsert<T extends monthly_indexUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, monthly_indexUpsertArgs<ExtArgs>>
    ): Prisma__monthly_indexClient<$Types.GetResult<monthly_indexPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Monthly_indices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthly_indexCountArgs} args - Arguments to filter Monthly_indices to count.
     * @example
     * // Count the number of Monthly_indices
     * const count = await prisma.monthly_index.count({
     *   where: {
     *     // ... the filter for the Monthly_indices we want to count
     *   }
     * })
    **/
    count<T extends monthly_indexCountArgs>(
      args?: Subset<T, monthly_indexCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monthly_indexCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monthly_index.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monthly_indexAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monthly_indexAggregateArgs>(args: Subset<T, Monthly_indexAggregateArgs>): Prisma.PrismaPromise<GetMonthly_indexAggregateType<T>>

    /**
     * Group by Monthly_index.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monthly_indexGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Monthly_indexGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Monthly_indexGroupByArgs['orderBy'] }
        : { orderBy?: Monthly_indexGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Monthly_indexGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonthly_indexGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for monthly_index.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__monthly_indexClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * monthly_index base type for findUnique actions
   */
  export type monthly_indexFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_index
     */
    select?: monthly_indexSelect<ExtArgs> | null
    /**
     * Filter, which monthly_index to fetch.
     */
    where: monthly_indexWhereUniqueInput
  }

  /**
   * monthly_index findUnique
   */
  export interface monthly_indexFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends monthly_indexFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * monthly_index findUniqueOrThrow
   */
  export type monthly_indexFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_index
     */
    select?: monthly_indexSelect<ExtArgs> | null
    /**
     * Filter, which monthly_index to fetch.
     */
    where: monthly_indexWhereUniqueInput
  }


  /**
   * monthly_index base type for findFirst actions
   */
  export type monthly_indexFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_index
     */
    select?: monthly_indexSelect<ExtArgs> | null
    /**
     * Filter, which monthly_index to fetch.
     */
    where?: monthly_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthly_indices to fetch.
     */
    orderBy?: Enumerable<monthly_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monthly_indices.
     */
    cursor?: monthly_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthly_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthly_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monthly_indices.
     */
    distinct?: Enumerable<Monthly_indexScalarFieldEnum>
  }

  /**
   * monthly_index findFirst
   */
  export interface monthly_indexFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends monthly_indexFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * monthly_index findFirstOrThrow
   */
  export type monthly_indexFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_index
     */
    select?: monthly_indexSelect<ExtArgs> | null
    /**
     * Filter, which monthly_index to fetch.
     */
    where?: monthly_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthly_indices to fetch.
     */
    orderBy?: Enumerable<monthly_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monthly_indices.
     */
    cursor?: monthly_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthly_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthly_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monthly_indices.
     */
    distinct?: Enumerable<Monthly_indexScalarFieldEnum>
  }


  /**
   * monthly_index findMany
   */
  export type monthly_indexFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_index
     */
    select?: monthly_indexSelect<ExtArgs> | null
    /**
     * Filter, which monthly_indices to fetch.
     */
    where?: monthly_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthly_indices to fetch.
     */
    orderBy?: Enumerable<monthly_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monthly_indices.
     */
    cursor?: monthly_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthly_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthly_indices.
     */
    skip?: number
    distinct?: Enumerable<Monthly_indexScalarFieldEnum>
  }


  /**
   * monthly_index create
   */
  export type monthly_indexCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_index
     */
    select?: monthly_indexSelect<ExtArgs> | null
    /**
     * The data needed to create a monthly_index.
     */
    data: XOR<monthly_indexCreateInput, monthly_indexUncheckedCreateInput>
  }


  /**
   * monthly_index createMany
   */
  export type monthly_indexCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monthly_indices.
     */
    data: Enumerable<monthly_indexCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * monthly_index update
   */
  export type monthly_indexUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_index
     */
    select?: monthly_indexSelect<ExtArgs> | null
    /**
     * The data needed to update a monthly_index.
     */
    data: XOR<monthly_indexUpdateInput, monthly_indexUncheckedUpdateInput>
    /**
     * Choose, which monthly_index to update.
     */
    where: monthly_indexWhereUniqueInput
  }


  /**
   * monthly_index updateMany
   */
  export type monthly_indexUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monthly_indices.
     */
    data: XOR<monthly_indexUpdateManyMutationInput, monthly_indexUncheckedUpdateManyInput>
    /**
     * Filter which monthly_indices to update
     */
    where?: monthly_indexWhereInput
  }


  /**
   * monthly_index upsert
   */
  export type monthly_indexUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_index
     */
    select?: monthly_indexSelect<ExtArgs> | null
    /**
     * The filter to search for the monthly_index to update in case it exists.
     */
    where: monthly_indexWhereUniqueInput
    /**
     * In case the monthly_index found by the `where` argument doesn't exist, create a new monthly_index with this data.
     */
    create: XOR<monthly_indexCreateInput, monthly_indexUncheckedCreateInput>
    /**
     * In case the monthly_index was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monthly_indexUpdateInput, monthly_indexUncheckedUpdateInput>
  }


  /**
   * monthly_index delete
   */
  export type monthly_indexDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_index
     */
    select?: monthly_indexSelect<ExtArgs> | null
    /**
     * Filter which monthly_index to delete.
     */
    where: monthly_indexWhereUniqueInput
  }


  /**
   * monthly_index deleteMany
   */
  export type monthly_indexDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which monthly_indices to delete
     */
    where?: monthly_indexWhereInput
  }


  /**
   * monthly_index without action
   */
  export type monthly_indexArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthly_index
     */
    select?: monthly_indexSelect<ExtArgs> | null
  }



  /**
   * Model seasonal_index
   */


  export type AggregateSeasonal_index = {
    _count: Seasonal_indexCountAggregateOutputType | null
    _min: Seasonal_indexMinAggregateOutputType | null
    _max: Seasonal_indexMaxAggregateOutputType | null
  }

  export type Seasonal_indexMinAggregateOutputType = {
    record_id: string | null
    season: string | null
    inverse_year: string | null
    probability_rate: string | null
  }

  export type Seasonal_indexMaxAggregateOutputType = {
    record_id: string | null
    season: string | null
    inverse_year: string | null
    probability_rate: string | null
  }

  export type Seasonal_indexCountAggregateOutputType = {
    record_id: number
    season: number
    inverse_year: number
    probability_rate: number
    _all: number
  }


  export type Seasonal_indexMinAggregateInputType = {
    record_id?: true
    season?: true
    inverse_year?: true
    probability_rate?: true
  }

  export type Seasonal_indexMaxAggregateInputType = {
    record_id?: true
    season?: true
    inverse_year?: true
    probability_rate?: true
  }

  export type Seasonal_indexCountAggregateInputType = {
    record_id?: true
    season?: true
    inverse_year?: true
    probability_rate?: true
    _all?: true
  }

  export type Seasonal_indexAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which seasonal_index to aggregate.
     */
    where?: seasonal_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasonal_indices to fetch.
     */
    orderBy?: Enumerable<seasonal_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seasonal_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasonal_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasonal_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seasonal_indices
    **/
    _count?: true | Seasonal_indexCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Seasonal_indexMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Seasonal_indexMaxAggregateInputType
  }

  export type GetSeasonal_indexAggregateType<T extends Seasonal_indexAggregateArgs> = {
        [P in keyof T & keyof AggregateSeasonal_index]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeasonal_index[P]>
      : GetScalarType<T[P], AggregateSeasonal_index[P]>
  }




  export type Seasonal_indexGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: seasonal_indexWhereInput
    orderBy?: Enumerable<seasonal_indexOrderByWithAggregationInput>
    by: Seasonal_indexScalarFieldEnum[]
    having?: seasonal_indexScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Seasonal_indexCountAggregateInputType | true
    _min?: Seasonal_indexMinAggregateInputType
    _max?: Seasonal_indexMaxAggregateInputType
  }


  export type Seasonal_indexGroupByOutputType = {
    record_id: string
    season: string
    inverse_year: string
    probability_rate: string
    _count: Seasonal_indexCountAggregateOutputType | null
    _min: Seasonal_indexMinAggregateOutputType | null
    _max: Seasonal_indexMaxAggregateOutputType | null
  }

  type GetSeasonal_indexGroupByPayload<T extends Seasonal_indexGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Seasonal_indexGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Seasonal_indexGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Seasonal_indexGroupByOutputType[P]>
            : GetScalarType<T[P], Seasonal_indexGroupByOutputType[P]>
        }
      >
    >


  export type seasonal_indexSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    season?: boolean
    inverse_year?: boolean
    probability_rate?: boolean
  }, ExtArgs["result"]["seasonal_index"]>

  export type seasonal_indexSelectScalar = {
    record_id?: boolean
    season?: boolean
    inverse_year?: boolean
    probability_rate?: boolean
  }


  type seasonal_indexGetPayload<S extends boolean | null | undefined | seasonal_indexArgs> = $Types.GetResult<seasonal_indexPayload, S>

  type seasonal_indexCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<seasonal_indexFindManyArgs, 'select' | 'include'> & {
      select?: Seasonal_indexCountAggregateInputType | true
    }

  export interface seasonal_indexDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['seasonal_index'], meta: { name: 'seasonal_index' } }
    /**
     * Find zero or one Seasonal_index that matches the filter.
     * @param {seasonal_indexFindUniqueArgs} args - Arguments to find a Seasonal_index
     * @example
     * // Get one Seasonal_index
     * const seasonal_index = await prisma.seasonal_index.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends seasonal_indexFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, seasonal_indexFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'seasonal_index'> extends True ? Prisma__seasonal_indexClient<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__seasonal_indexClient<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Seasonal_index that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {seasonal_indexFindUniqueOrThrowArgs} args - Arguments to find a Seasonal_index
     * @example
     * // Get one Seasonal_index
     * const seasonal_index = await prisma.seasonal_index.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends seasonal_indexFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, seasonal_indexFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__seasonal_indexClient<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Seasonal_index that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonal_indexFindFirstArgs} args - Arguments to find a Seasonal_index
     * @example
     * // Get one Seasonal_index
     * const seasonal_index = await prisma.seasonal_index.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends seasonal_indexFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, seasonal_indexFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'seasonal_index'> extends True ? Prisma__seasonal_indexClient<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__seasonal_indexClient<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Seasonal_index that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonal_indexFindFirstOrThrowArgs} args - Arguments to find a Seasonal_index
     * @example
     * // Get one Seasonal_index
     * const seasonal_index = await prisma.seasonal_index.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends seasonal_indexFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, seasonal_indexFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__seasonal_indexClient<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Seasonal_indices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonal_indexFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasonal_indices
     * const seasonal_indices = await prisma.seasonal_index.findMany()
     * 
     * // Get first 10 Seasonal_indices
     * const seasonal_indices = await prisma.seasonal_index.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const seasonal_indexWithRecord_idOnly = await prisma.seasonal_index.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends seasonal_indexFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, seasonal_indexFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Seasonal_index.
     * @param {seasonal_indexCreateArgs} args - Arguments to create a Seasonal_index.
     * @example
     * // Create one Seasonal_index
     * const Seasonal_index = await prisma.seasonal_index.create({
     *   data: {
     *     // ... data to create a Seasonal_index
     *   }
     * })
     * 
    **/
    create<T extends seasonal_indexCreateArgs<ExtArgs>>(
      args: SelectSubset<T, seasonal_indexCreateArgs<ExtArgs>>
    ): Prisma__seasonal_indexClient<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Seasonal_indices.
     *     @param {seasonal_indexCreateManyArgs} args - Arguments to create many Seasonal_indices.
     *     @example
     *     // Create many Seasonal_indices
     *     const seasonal_index = await prisma.seasonal_index.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends seasonal_indexCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, seasonal_indexCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seasonal_index.
     * @param {seasonal_indexDeleteArgs} args - Arguments to delete one Seasonal_index.
     * @example
     * // Delete one Seasonal_index
     * const Seasonal_index = await prisma.seasonal_index.delete({
     *   where: {
     *     // ... filter to delete one Seasonal_index
     *   }
     * })
     * 
    **/
    delete<T extends seasonal_indexDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, seasonal_indexDeleteArgs<ExtArgs>>
    ): Prisma__seasonal_indexClient<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Seasonal_index.
     * @param {seasonal_indexUpdateArgs} args - Arguments to update one Seasonal_index.
     * @example
     * // Update one Seasonal_index
     * const seasonal_index = await prisma.seasonal_index.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends seasonal_indexUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, seasonal_indexUpdateArgs<ExtArgs>>
    ): Prisma__seasonal_indexClient<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Seasonal_indices.
     * @param {seasonal_indexDeleteManyArgs} args - Arguments to filter Seasonal_indices to delete.
     * @example
     * // Delete a few Seasonal_indices
     * const { count } = await prisma.seasonal_index.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends seasonal_indexDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, seasonal_indexDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasonal_indices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonal_indexUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasonal_indices
     * const seasonal_index = await prisma.seasonal_index.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends seasonal_indexUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, seasonal_indexUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seasonal_index.
     * @param {seasonal_indexUpsertArgs} args - Arguments to update or create a Seasonal_index.
     * @example
     * // Update or create a Seasonal_index
     * const seasonal_index = await prisma.seasonal_index.upsert({
     *   create: {
     *     // ... data to create a Seasonal_index
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seasonal_index we want to update
     *   }
     * })
    **/
    upsert<T extends seasonal_indexUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, seasonal_indexUpsertArgs<ExtArgs>>
    ): Prisma__seasonal_indexClient<$Types.GetResult<seasonal_indexPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Seasonal_indices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonal_indexCountArgs} args - Arguments to filter Seasonal_indices to count.
     * @example
     * // Count the number of Seasonal_indices
     * const count = await prisma.seasonal_index.count({
     *   where: {
     *     // ... the filter for the Seasonal_indices we want to count
     *   }
     * })
    **/
    count<T extends seasonal_indexCountArgs>(
      args?: Subset<T, seasonal_indexCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Seasonal_indexCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seasonal_index.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Seasonal_indexAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Seasonal_indexAggregateArgs>(args: Subset<T, Seasonal_indexAggregateArgs>): Prisma.PrismaPromise<GetSeasonal_indexAggregateType<T>>

    /**
     * Group by Seasonal_index.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Seasonal_indexGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Seasonal_indexGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Seasonal_indexGroupByArgs['orderBy'] }
        : { orderBy?: Seasonal_indexGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Seasonal_indexGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonal_indexGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for seasonal_index.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__seasonal_indexClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * seasonal_index base type for findUnique actions
   */
  export type seasonal_indexFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasonal_index
     */
    select?: seasonal_indexSelect<ExtArgs> | null
    /**
     * Filter, which seasonal_index to fetch.
     */
    where: seasonal_indexWhereUniqueInput
  }

  /**
   * seasonal_index findUnique
   */
  export interface seasonal_indexFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends seasonal_indexFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * seasonal_index findUniqueOrThrow
   */
  export type seasonal_indexFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasonal_index
     */
    select?: seasonal_indexSelect<ExtArgs> | null
    /**
     * Filter, which seasonal_index to fetch.
     */
    where: seasonal_indexWhereUniqueInput
  }


  /**
   * seasonal_index base type for findFirst actions
   */
  export type seasonal_indexFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasonal_index
     */
    select?: seasonal_indexSelect<ExtArgs> | null
    /**
     * Filter, which seasonal_index to fetch.
     */
    where?: seasonal_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasonal_indices to fetch.
     */
    orderBy?: Enumerable<seasonal_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seasonal_indices.
     */
    cursor?: seasonal_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasonal_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasonal_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seasonal_indices.
     */
    distinct?: Enumerable<Seasonal_indexScalarFieldEnum>
  }

  /**
   * seasonal_index findFirst
   */
  export interface seasonal_indexFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends seasonal_indexFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * seasonal_index findFirstOrThrow
   */
  export type seasonal_indexFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasonal_index
     */
    select?: seasonal_indexSelect<ExtArgs> | null
    /**
     * Filter, which seasonal_index to fetch.
     */
    where?: seasonal_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasonal_indices to fetch.
     */
    orderBy?: Enumerable<seasonal_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seasonal_indices.
     */
    cursor?: seasonal_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasonal_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasonal_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seasonal_indices.
     */
    distinct?: Enumerable<Seasonal_indexScalarFieldEnum>
  }


  /**
   * seasonal_index findMany
   */
  export type seasonal_indexFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasonal_index
     */
    select?: seasonal_indexSelect<ExtArgs> | null
    /**
     * Filter, which seasonal_indices to fetch.
     */
    where?: seasonal_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasonal_indices to fetch.
     */
    orderBy?: Enumerable<seasonal_indexOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seasonal_indices.
     */
    cursor?: seasonal_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasonal_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasonal_indices.
     */
    skip?: number
    distinct?: Enumerable<Seasonal_indexScalarFieldEnum>
  }


  /**
   * seasonal_index create
   */
  export type seasonal_indexCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasonal_index
     */
    select?: seasonal_indexSelect<ExtArgs> | null
    /**
     * The data needed to create a seasonal_index.
     */
    data: XOR<seasonal_indexCreateInput, seasonal_indexUncheckedCreateInput>
  }


  /**
   * seasonal_index createMany
   */
  export type seasonal_indexCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many seasonal_indices.
     */
    data: Enumerable<seasonal_indexCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * seasonal_index update
   */
  export type seasonal_indexUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasonal_index
     */
    select?: seasonal_indexSelect<ExtArgs> | null
    /**
     * The data needed to update a seasonal_index.
     */
    data: XOR<seasonal_indexUpdateInput, seasonal_indexUncheckedUpdateInput>
    /**
     * Choose, which seasonal_index to update.
     */
    where: seasonal_indexWhereUniqueInput
  }


  /**
   * seasonal_index updateMany
   */
  export type seasonal_indexUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update seasonal_indices.
     */
    data: XOR<seasonal_indexUpdateManyMutationInput, seasonal_indexUncheckedUpdateManyInput>
    /**
     * Filter which seasonal_indices to update
     */
    where?: seasonal_indexWhereInput
  }


  /**
   * seasonal_index upsert
   */
  export type seasonal_indexUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasonal_index
     */
    select?: seasonal_indexSelect<ExtArgs> | null
    /**
     * The filter to search for the seasonal_index to update in case it exists.
     */
    where: seasonal_indexWhereUniqueInput
    /**
     * In case the seasonal_index found by the `where` argument doesn't exist, create a new seasonal_index with this data.
     */
    create: XOR<seasonal_indexCreateInput, seasonal_indexUncheckedCreateInput>
    /**
     * In case the seasonal_index was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seasonal_indexUpdateInput, seasonal_indexUncheckedUpdateInput>
  }


  /**
   * seasonal_index delete
   */
  export type seasonal_indexDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasonal_index
     */
    select?: seasonal_indexSelect<ExtArgs> | null
    /**
     * Filter which seasonal_index to delete.
     */
    where: seasonal_indexWhereUniqueInput
  }


  /**
   * seasonal_index deleteMany
   */
  export type seasonal_indexDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which seasonal_indices to delete
     */
    where?: seasonal_indexWhereInput
  }


  /**
   * seasonal_index without action
   */
  export type seasonal_indexArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasonal_index
     */
    select?: seasonal_indexSelect<ExtArgs> | null
  }



  /**
   * Model comparison_chart
   */


  export type AggregateComparison_chart = {
    _count: Comparison_chartCountAggregateOutputType | null
    _avg: Comparison_chartAvgAggregateOutputType | null
    _sum: Comparison_chartSumAggregateOutputType | null
    _min: Comparison_chartMinAggregateOutputType | null
    _max: Comparison_chartMaxAggregateOutputType | null
  }

  export type Comparison_chartAvgAggregateOutputType = {
    cotton_spot_price: Decimal | null
    dollar_basket_spot_price: Decimal | null
    crude_oil_spot_price: Decimal | null
  }

  export type Comparison_chartSumAggregateOutputType = {
    cotton_spot_price: Decimal | null
    dollar_basket_spot_price: Decimal | null
    crude_oil_spot_price: Decimal | null
  }

  export type Comparison_chartMinAggregateOutputType = {
    record_id: string | null
    date_of_close: Date | null
    cotton_spot_price: Decimal | null
    dollar_basket_spot_price: Decimal | null
    crude_oil_spot_price: Decimal | null
  }

  export type Comparison_chartMaxAggregateOutputType = {
    record_id: string | null
    date_of_close: Date | null
    cotton_spot_price: Decimal | null
    dollar_basket_spot_price: Decimal | null
    crude_oil_spot_price: Decimal | null
  }

  export type Comparison_chartCountAggregateOutputType = {
    record_id: number
    date_of_close: number
    cotton_spot_price: number
    dollar_basket_spot_price: number
    crude_oil_spot_price: number
    _all: number
  }


  export type Comparison_chartAvgAggregateInputType = {
    cotton_spot_price?: true
    dollar_basket_spot_price?: true
    crude_oil_spot_price?: true
  }

  export type Comparison_chartSumAggregateInputType = {
    cotton_spot_price?: true
    dollar_basket_spot_price?: true
    crude_oil_spot_price?: true
  }

  export type Comparison_chartMinAggregateInputType = {
    record_id?: true
    date_of_close?: true
    cotton_spot_price?: true
    dollar_basket_spot_price?: true
    crude_oil_spot_price?: true
  }

  export type Comparison_chartMaxAggregateInputType = {
    record_id?: true
    date_of_close?: true
    cotton_spot_price?: true
    dollar_basket_spot_price?: true
    crude_oil_spot_price?: true
  }

  export type Comparison_chartCountAggregateInputType = {
    record_id?: true
    date_of_close?: true
    cotton_spot_price?: true
    dollar_basket_spot_price?: true
    crude_oil_spot_price?: true
    _all?: true
  }

  export type Comparison_chartAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which comparison_chart to aggregate.
     */
    where?: comparison_chartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comparison_charts to fetch.
     */
    orderBy?: Enumerable<comparison_chartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comparison_chartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comparison_charts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comparison_charts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comparison_charts
    **/
    _count?: true | Comparison_chartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Comparison_chartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Comparison_chartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Comparison_chartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Comparison_chartMaxAggregateInputType
  }

  export type GetComparison_chartAggregateType<T extends Comparison_chartAggregateArgs> = {
        [P in keyof T & keyof AggregateComparison_chart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComparison_chart[P]>
      : GetScalarType<T[P], AggregateComparison_chart[P]>
  }




  export type Comparison_chartGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: comparison_chartWhereInput
    orderBy?: Enumerable<comparison_chartOrderByWithAggregationInput>
    by: Comparison_chartScalarFieldEnum[]
    having?: comparison_chartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Comparison_chartCountAggregateInputType | true
    _avg?: Comparison_chartAvgAggregateInputType
    _sum?: Comparison_chartSumAggregateInputType
    _min?: Comparison_chartMinAggregateInputType
    _max?: Comparison_chartMaxAggregateInputType
  }


  export type Comparison_chartGroupByOutputType = {
    record_id: string
    date_of_close: Date
    cotton_spot_price: Decimal | null
    dollar_basket_spot_price: Decimal | null
    crude_oil_spot_price: Decimal | null
    _count: Comparison_chartCountAggregateOutputType | null
    _avg: Comparison_chartAvgAggregateOutputType | null
    _sum: Comparison_chartSumAggregateOutputType | null
    _min: Comparison_chartMinAggregateOutputType | null
    _max: Comparison_chartMaxAggregateOutputType | null
  }

  type GetComparison_chartGroupByPayload<T extends Comparison_chartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Comparison_chartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Comparison_chartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Comparison_chartGroupByOutputType[P]>
            : GetScalarType<T[P], Comparison_chartGroupByOutputType[P]>
        }
      >
    >


  export type comparison_chartSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    date_of_close?: boolean
    cotton_spot_price?: boolean
    dollar_basket_spot_price?: boolean
    crude_oil_spot_price?: boolean
  }, ExtArgs["result"]["comparison_chart"]>

  export type comparison_chartSelectScalar = {
    record_id?: boolean
    date_of_close?: boolean
    cotton_spot_price?: boolean
    dollar_basket_spot_price?: boolean
    crude_oil_spot_price?: boolean
  }


  type comparison_chartGetPayload<S extends boolean | null | undefined | comparison_chartArgs> = $Types.GetResult<comparison_chartPayload, S>

  type comparison_chartCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<comparison_chartFindManyArgs, 'select' | 'include'> & {
      select?: Comparison_chartCountAggregateInputType | true
    }

  export interface comparison_chartDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comparison_chart'], meta: { name: 'comparison_chart' } }
    /**
     * Find zero or one Comparison_chart that matches the filter.
     * @param {comparison_chartFindUniqueArgs} args - Arguments to find a Comparison_chart
     * @example
     * // Get one Comparison_chart
     * const comparison_chart = await prisma.comparison_chart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends comparison_chartFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, comparison_chartFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'comparison_chart'> extends True ? Prisma__comparison_chartClient<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__comparison_chartClient<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Comparison_chart that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {comparison_chartFindUniqueOrThrowArgs} args - Arguments to find a Comparison_chart
     * @example
     * // Get one Comparison_chart
     * const comparison_chart = await prisma.comparison_chart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends comparison_chartFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comparison_chartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__comparison_chartClient<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Comparison_chart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comparison_chartFindFirstArgs} args - Arguments to find a Comparison_chart
     * @example
     * // Get one Comparison_chart
     * const comparison_chart = await prisma.comparison_chart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends comparison_chartFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, comparison_chartFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'comparison_chart'> extends True ? Prisma__comparison_chartClient<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__comparison_chartClient<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Comparison_chart that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comparison_chartFindFirstOrThrowArgs} args - Arguments to find a Comparison_chart
     * @example
     * // Get one Comparison_chart
     * const comparison_chart = await prisma.comparison_chart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends comparison_chartFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comparison_chartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__comparison_chartClient<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Comparison_charts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comparison_chartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comparison_charts
     * const comparison_charts = await prisma.comparison_chart.findMany()
     * 
     * // Get first 10 Comparison_charts
     * const comparison_charts = await prisma.comparison_chart.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const comparison_chartWithRecord_idOnly = await prisma.comparison_chart.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends comparison_chartFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comparison_chartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Comparison_chart.
     * @param {comparison_chartCreateArgs} args - Arguments to create a Comparison_chart.
     * @example
     * // Create one Comparison_chart
     * const Comparison_chart = await prisma.comparison_chart.create({
     *   data: {
     *     // ... data to create a Comparison_chart
     *   }
     * })
     * 
    **/
    create<T extends comparison_chartCreateArgs<ExtArgs>>(
      args: SelectSubset<T, comparison_chartCreateArgs<ExtArgs>>
    ): Prisma__comparison_chartClient<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Comparison_charts.
     *     @param {comparison_chartCreateManyArgs} args - Arguments to create many Comparison_charts.
     *     @example
     *     // Create many Comparison_charts
     *     const comparison_chart = await prisma.comparison_chart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends comparison_chartCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comparison_chartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comparison_chart.
     * @param {comparison_chartDeleteArgs} args - Arguments to delete one Comparison_chart.
     * @example
     * // Delete one Comparison_chart
     * const Comparison_chart = await prisma.comparison_chart.delete({
     *   where: {
     *     // ... filter to delete one Comparison_chart
     *   }
     * })
     * 
    **/
    delete<T extends comparison_chartDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, comparison_chartDeleteArgs<ExtArgs>>
    ): Prisma__comparison_chartClient<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Comparison_chart.
     * @param {comparison_chartUpdateArgs} args - Arguments to update one Comparison_chart.
     * @example
     * // Update one Comparison_chart
     * const comparison_chart = await prisma.comparison_chart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends comparison_chartUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, comparison_chartUpdateArgs<ExtArgs>>
    ): Prisma__comparison_chartClient<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Comparison_charts.
     * @param {comparison_chartDeleteManyArgs} args - Arguments to filter Comparison_charts to delete.
     * @example
     * // Delete a few Comparison_charts
     * const { count } = await prisma.comparison_chart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends comparison_chartDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comparison_chartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comparison_charts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comparison_chartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comparison_charts
     * const comparison_chart = await prisma.comparison_chart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends comparison_chartUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, comparison_chartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comparison_chart.
     * @param {comparison_chartUpsertArgs} args - Arguments to update or create a Comparison_chart.
     * @example
     * // Update or create a Comparison_chart
     * const comparison_chart = await prisma.comparison_chart.upsert({
     *   create: {
     *     // ... data to create a Comparison_chart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comparison_chart we want to update
     *   }
     * })
    **/
    upsert<T extends comparison_chartUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, comparison_chartUpsertArgs<ExtArgs>>
    ): Prisma__comparison_chartClient<$Types.GetResult<comparison_chartPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Comparison_charts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comparison_chartCountArgs} args - Arguments to filter Comparison_charts to count.
     * @example
     * // Count the number of Comparison_charts
     * const count = await prisma.comparison_chart.count({
     *   where: {
     *     // ... the filter for the Comparison_charts we want to count
     *   }
     * })
    **/
    count<T extends comparison_chartCountArgs>(
      args?: Subset<T, comparison_chartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Comparison_chartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comparison_chart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Comparison_chartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Comparison_chartAggregateArgs>(args: Subset<T, Comparison_chartAggregateArgs>): Prisma.PrismaPromise<GetComparison_chartAggregateType<T>>

    /**
     * Group by Comparison_chart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Comparison_chartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Comparison_chartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Comparison_chartGroupByArgs['orderBy'] }
        : { orderBy?: Comparison_chartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Comparison_chartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComparison_chartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for comparison_chart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__comparison_chartClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * comparison_chart base type for findUnique actions
   */
  export type comparison_chartFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_chart
     */
    select?: comparison_chartSelect<ExtArgs> | null
    /**
     * Filter, which comparison_chart to fetch.
     */
    where: comparison_chartWhereUniqueInput
  }

  /**
   * comparison_chart findUnique
   */
  export interface comparison_chartFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends comparison_chartFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * comparison_chart findUniqueOrThrow
   */
  export type comparison_chartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_chart
     */
    select?: comparison_chartSelect<ExtArgs> | null
    /**
     * Filter, which comparison_chart to fetch.
     */
    where: comparison_chartWhereUniqueInput
  }


  /**
   * comparison_chart base type for findFirst actions
   */
  export type comparison_chartFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_chart
     */
    select?: comparison_chartSelect<ExtArgs> | null
    /**
     * Filter, which comparison_chart to fetch.
     */
    where?: comparison_chartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comparison_charts to fetch.
     */
    orderBy?: Enumerable<comparison_chartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comparison_charts.
     */
    cursor?: comparison_chartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comparison_charts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comparison_charts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comparison_charts.
     */
    distinct?: Enumerable<Comparison_chartScalarFieldEnum>
  }

  /**
   * comparison_chart findFirst
   */
  export interface comparison_chartFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends comparison_chartFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * comparison_chart findFirstOrThrow
   */
  export type comparison_chartFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_chart
     */
    select?: comparison_chartSelect<ExtArgs> | null
    /**
     * Filter, which comparison_chart to fetch.
     */
    where?: comparison_chartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comparison_charts to fetch.
     */
    orderBy?: Enumerable<comparison_chartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comparison_charts.
     */
    cursor?: comparison_chartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comparison_charts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comparison_charts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comparison_charts.
     */
    distinct?: Enumerable<Comparison_chartScalarFieldEnum>
  }


  /**
   * comparison_chart findMany
   */
  export type comparison_chartFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_chart
     */
    select?: comparison_chartSelect<ExtArgs> | null
    /**
     * Filter, which comparison_charts to fetch.
     */
    where?: comparison_chartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comparison_charts to fetch.
     */
    orderBy?: Enumerable<comparison_chartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comparison_charts.
     */
    cursor?: comparison_chartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comparison_charts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comparison_charts.
     */
    skip?: number
    distinct?: Enumerable<Comparison_chartScalarFieldEnum>
  }


  /**
   * comparison_chart create
   */
  export type comparison_chartCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_chart
     */
    select?: comparison_chartSelect<ExtArgs> | null
    /**
     * The data needed to create a comparison_chart.
     */
    data: XOR<comparison_chartCreateInput, comparison_chartUncheckedCreateInput>
  }


  /**
   * comparison_chart createMany
   */
  export type comparison_chartCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comparison_charts.
     */
    data: Enumerable<comparison_chartCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * comparison_chart update
   */
  export type comparison_chartUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_chart
     */
    select?: comparison_chartSelect<ExtArgs> | null
    /**
     * The data needed to update a comparison_chart.
     */
    data: XOR<comparison_chartUpdateInput, comparison_chartUncheckedUpdateInput>
    /**
     * Choose, which comparison_chart to update.
     */
    where: comparison_chartWhereUniqueInput
  }


  /**
   * comparison_chart updateMany
   */
  export type comparison_chartUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comparison_charts.
     */
    data: XOR<comparison_chartUpdateManyMutationInput, comparison_chartUncheckedUpdateManyInput>
    /**
     * Filter which comparison_charts to update
     */
    where?: comparison_chartWhereInput
  }


  /**
   * comparison_chart upsert
   */
  export type comparison_chartUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_chart
     */
    select?: comparison_chartSelect<ExtArgs> | null
    /**
     * The filter to search for the comparison_chart to update in case it exists.
     */
    where: comparison_chartWhereUniqueInput
    /**
     * In case the comparison_chart found by the `where` argument doesn't exist, create a new comparison_chart with this data.
     */
    create: XOR<comparison_chartCreateInput, comparison_chartUncheckedCreateInput>
    /**
     * In case the comparison_chart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comparison_chartUpdateInput, comparison_chartUncheckedUpdateInput>
  }


  /**
   * comparison_chart delete
   */
  export type comparison_chartDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_chart
     */
    select?: comparison_chartSelect<ExtArgs> | null
    /**
     * Filter which comparison_chart to delete.
     */
    where: comparison_chartWhereUniqueInput
  }


  /**
   * comparison_chart deleteMany
   */
  export type comparison_chartDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which comparison_charts to delete
     */
    where?: comparison_chartWhereInput
  }


  /**
   * comparison_chart without action
   */
  export type comparison_chartArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_chart
     */
    select?: comparison_chartSelect<ExtArgs> | null
  }



  /**
   * Model snapshot_strategy
   */


  export type AggregateSnapshot_strategy = {
    _count: Snapshot_strategyCountAggregateOutputType | null
    _min: Snapshot_strategyMinAggregateOutputType | null
    _max: Snapshot_strategyMaxAggregateOutputType | null
  }

  export type Snapshot_strategyMinAggregateOutputType = {
    record_id: string | null
    title_of_snapshot_strategy: string | null
    image_of_snapshot_strategy: string | null
    text_of_snapshot_strategy: string | null
    date_of_snapshot_strategy: Date | null
    valid: boolean | null
    news_type: string | null
    impact: string | null
    added_by: string | null
    verified: boolean | null
  }

  export type Snapshot_strategyMaxAggregateOutputType = {
    record_id: string | null
    title_of_snapshot_strategy: string | null
    image_of_snapshot_strategy: string | null
    text_of_snapshot_strategy: string | null
    date_of_snapshot_strategy: Date | null
    valid: boolean | null
    news_type: string | null
    impact: string | null
    added_by: string | null
    verified: boolean | null
  }

  export type Snapshot_strategyCountAggregateOutputType = {
    record_id: number
    title_of_snapshot_strategy: number
    image_of_snapshot_strategy: number
    text_of_snapshot_strategy: number
    date_of_snapshot_strategy: number
    valid: number
    news_type: number
    impact: number
    added_by: number
    verified: number
    _all: number
  }


  export type Snapshot_strategyMinAggregateInputType = {
    record_id?: true
    title_of_snapshot_strategy?: true
    image_of_snapshot_strategy?: true
    text_of_snapshot_strategy?: true
    date_of_snapshot_strategy?: true
    valid?: true
    news_type?: true
    impact?: true
    added_by?: true
    verified?: true
  }

  export type Snapshot_strategyMaxAggregateInputType = {
    record_id?: true
    title_of_snapshot_strategy?: true
    image_of_snapshot_strategy?: true
    text_of_snapshot_strategy?: true
    date_of_snapshot_strategy?: true
    valid?: true
    news_type?: true
    impact?: true
    added_by?: true
    verified?: true
  }

  export type Snapshot_strategyCountAggregateInputType = {
    record_id?: true
    title_of_snapshot_strategy?: true
    image_of_snapshot_strategy?: true
    text_of_snapshot_strategy?: true
    date_of_snapshot_strategy?: true
    valid?: true
    news_type?: true
    impact?: true
    added_by?: true
    verified?: true
    _all?: true
  }

  export type Snapshot_strategyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which snapshot_strategy to aggregate.
     */
    where?: snapshot_strategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of snapshot_strategies to fetch.
     */
    orderBy?: Enumerable<snapshot_strategyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: snapshot_strategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` snapshot_strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` snapshot_strategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned snapshot_strategies
    **/
    _count?: true | Snapshot_strategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Snapshot_strategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Snapshot_strategyMaxAggregateInputType
  }

  export type GetSnapshot_strategyAggregateType<T extends Snapshot_strategyAggregateArgs> = {
        [P in keyof T & keyof AggregateSnapshot_strategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSnapshot_strategy[P]>
      : GetScalarType<T[P], AggregateSnapshot_strategy[P]>
  }




  export type Snapshot_strategyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: snapshot_strategyWhereInput
    orderBy?: Enumerable<snapshot_strategyOrderByWithAggregationInput>
    by: Snapshot_strategyScalarFieldEnum[]
    having?: snapshot_strategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Snapshot_strategyCountAggregateInputType | true
    _min?: Snapshot_strategyMinAggregateInputType
    _max?: Snapshot_strategyMaxAggregateInputType
  }


  export type Snapshot_strategyGroupByOutputType = {
    record_id: string
    title_of_snapshot_strategy: string
    image_of_snapshot_strategy: string | null
    text_of_snapshot_strategy: string
    date_of_snapshot_strategy: Date
    valid: boolean
    news_type: string
    impact: string | null
    added_by: string
    verified: boolean
    _count: Snapshot_strategyCountAggregateOutputType | null
    _min: Snapshot_strategyMinAggregateOutputType | null
    _max: Snapshot_strategyMaxAggregateOutputType | null
  }

  type GetSnapshot_strategyGroupByPayload<T extends Snapshot_strategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Snapshot_strategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Snapshot_strategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Snapshot_strategyGroupByOutputType[P]>
            : GetScalarType<T[P], Snapshot_strategyGroupByOutputType[P]>
        }
      >
    >


  export type snapshot_strategySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    title_of_snapshot_strategy?: boolean
    image_of_snapshot_strategy?: boolean
    text_of_snapshot_strategy?: boolean
    date_of_snapshot_strategy?: boolean
    valid?: boolean
    news_type?: boolean
    impact?: boolean
    added_by?: boolean
    verified?: boolean
  }, ExtArgs["result"]["snapshot_strategy"]>

  export type snapshot_strategySelectScalar = {
    record_id?: boolean
    title_of_snapshot_strategy?: boolean
    image_of_snapshot_strategy?: boolean
    text_of_snapshot_strategy?: boolean
    date_of_snapshot_strategy?: boolean
    valid?: boolean
    news_type?: boolean
    impact?: boolean
    added_by?: boolean
    verified?: boolean
  }


  type snapshot_strategyGetPayload<S extends boolean | null | undefined | snapshot_strategyArgs> = $Types.GetResult<snapshot_strategyPayload, S>

  type snapshot_strategyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<snapshot_strategyFindManyArgs, 'select' | 'include'> & {
      select?: Snapshot_strategyCountAggregateInputType | true
    }

  export interface snapshot_strategyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['snapshot_strategy'], meta: { name: 'snapshot_strategy' } }
    /**
     * Find zero or one Snapshot_strategy that matches the filter.
     * @param {snapshot_strategyFindUniqueArgs} args - Arguments to find a Snapshot_strategy
     * @example
     * // Get one Snapshot_strategy
     * const snapshot_strategy = await prisma.snapshot_strategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends snapshot_strategyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, snapshot_strategyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'snapshot_strategy'> extends True ? Prisma__snapshot_strategyClient<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__snapshot_strategyClient<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Snapshot_strategy that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {snapshot_strategyFindUniqueOrThrowArgs} args - Arguments to find a Snapshot_strategy
     * @example
     * // Get one Snapshot_strategy
     * const snapshot_strategy = await prisma.snapshot_strategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends snapshot_strategyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, snapshot_strategyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__snapshot_strategyClient<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Snapshot_strategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snapshot_strategyFindFirstArgs} args - Arguments to find a Snapshot_strategy
     * @example
     * // Get one Snapshot_strategy
     * const snapshot_strategy = await prisma.snapshot_strategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends snapshot_strategyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, snapshot_strategyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'snapshot_strategy'> extends True ? Prisma__snapshot_strategyClient<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__snapshot_strategyClient<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Snapshot_strategy that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snapshot_strategyFindFirstOrThrowArgs} args - Arguments to find a Snapshot_strategy
     * @example
     * // Get one Snapshot_strategy
     * const snapshot_strategy = await prisma.snapshot_strategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends snapshot_strategyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, snapshot_strategyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__snapshot_strategyClient<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Snapshot_strategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snapshot_strategyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Snapshot_strategies
     * const snapshot_strategies = await prisma.snapshot_strategy.findMany()
     * 
     * // Get first 10 Snapshot_strategies
     * const snapshot_strategies = await prisma.snapshot_strategy.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const snapshot_strategyWithRecord_idOnly = await prisma.snapshot_strategy.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends snapshot_strategyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, snapshot_strategyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Snapshot_strategy.
     * @param {snapshot_strategyCreateArgs} args - Arguments to create a Snapshot_strategy.
     * @example
     * // Create one Snapshot_strategy
     * const Snapshot_strategy = await prisma.snapshot_strategy.create({
     *   data: {
     *     // ... data to create a Snapshot_strategy
     *   }
     * })
     * 
    **/
    create<T extends snapshot_strategyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, snapshot_strategyCreateArgs<ExtArgs>>
    ): Prisma__snapshot_strategyClient<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Snapshot_strategies.
     *     @param {snapshot_strategyCreateManyArgs} args - Arguments to create many Snapshot_strategies.
     *     @example
     *     // Create many Snapshot_strategies
     *     const snapshot_strategy = await prisma.snapshot_strategy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends snapshot_strategyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, snapshot_strategyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Snapshot_strategy.
     * @param {snapshot_strategyDeleteArgs} args - Arguments to delete one Snapshot_strategy.
     * @example
     * // Delete one Snapshot_strategy
     * const Snapshot_strategy = await prisma.snapshot_strategy.delete({
     *   where: {
     *     // ... filter to delete one Snapshot_strategy
     *   }
     * })
     * 
    **/
    delete<T extends snapshot_strategyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, snapshot_strategyDeleteArgs<ExtArgs>>
    ): Prisma__snapshot_strategyClient<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Snapshot_strategy.
     * @param {snapshot_strategyUpdateArgs} args - Arguments to update one Snapshot_strategy.
     * @example
     * // Update one Snapshot_strategy
     * const snapshot_strategy = await prisma.snapshot_strategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends snapshot_strategyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, snapshot_strategyUpdateArgs<ExtArgs>>
    ): Prisma__snapshot_strategyClient<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Snapshot_strategies.
     * @param {snapshot_strategyDeleteManyArgs} args - Arguments to filter Snapshot_strategies to delete.
     * @example
     * // Delete a few Snapshot_strategies
     * const { count } = await prisma.snapshot_strategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends snapshot_strategyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, snapshot_strategyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Snapshot_strategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snapshot_strategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Snapshot_strategies
     * const snapshot_strategy = await prisma.snapshot_strategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends snapshot_strategyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, snapshot_strategyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Snapshot_strategy.
     * @param {snapshot_strategyUpsertArgs} args - Arguments to update or create a Snapshot_strategy.
     * @example
     * // Update or create a Snapshot_strategy
     * const snapshot_strategy = await prisma.snapshot_strategy.upsert({
     *   create: {
     *     // ... data to create a Snapshot_strategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Snapshot_strategy we want to update
     *   }
     * })
    **/
    upsert<T extends snapshot_strategyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, snapshot_strategyUpsertArgs<ExtArgs>>
    ): Prisma__snapshot_strategyClient<$Types.GetResult<snapshot_strategyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Snapshot_strategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snapshot_strategyCountArgs} args - Arguments to filter Snapshot_strategies to count.
     * @example
     * // Count the number of Snapshot_strategies
     * const count = await prisma.snapshot_strategy.count({
     *   where: {
     *     // ... the filter for the Snapshot_strategies we want to count
     *   }
     * })
    **/
    count<T extends snapshot_strategyCountArgs>(
      args?: Subset<T, snapshot_strategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Snapshot_strategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Snapshot_strategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Snapshot_strategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Snapshot_strategyAggregateArgs>(args: Subset<T, Snapshot_strategyAggregateArgs>): Prisma.PrismaPromise<GetSnapshot_strategyAggregateType<T>>

    /**
     * Group by Snapshot_strategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Snapshot_strategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Snapshot_strategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Snapshot_strategyGroupByArgs['orderBy'] }
        : { orderBy?: Snapshot_strategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Snapshot_strategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSnapshot_strategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for snapshot_strategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__snapshot_strategyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * snapshot_strategy base type for findUnique actions
   */
  export type snapshot_strategyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snapshot_strategy
     */
    select?: snapshot_strategySelect<ExtArgs> | null
    /**
     * Filter, which snapshot_strategy to fetch.
     */
    where: snapshot_strategyWhereUniqueInput
  }

  /**
   * snapshot_strategy findUnique
   */
  export interface snapshot_strategyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends snapshot_strategyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * snapshot_strategy findUniqueOrThrow
   */
  export type snapshot_strategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snapshot_strategy
     */
    select?: snapshot_strategySelect<ExtArgs> | null
    /**
     * Filter, which snapshot_strategy to fetch.
     */
    where: snapshot_strategyWhereUniqueInput
  }


  /**
   * snapshot_strategy base type for findFirst actions
   */
  export type snapshot_strategyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snapshot_strategy
     */
    select?: snapshot_strategySelect<ExtArgs> | null
    /**
     * Filter, which snapshot_strategy to fetch.
     */
    where?: snapshot_strategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of snapshot_strategies to fetch.
     */
    orderBy?: Enumerable<snapshot_strategyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for snapshot_strategies.
     */
    cursor?: snapshot_strategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` snapshot_strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` snapshot_strategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of snapshot_strategies.
     */
    distinct?: Enumerable<Snapshot_strategyScalarFieldEnum>
  }

  /**
   * snapshot_strategy findFirst
   */
  export interface snapshot_strategyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends snapshot_strategyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * snapshot_strategy findFirstOrThrow
   */
  export type snapshot_strategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snapshot_strategy
     */
    select?: snapshot_strategySelect<ExtArgs> | null
    /**
     * Filter, which snapshot_strategy to fetch.
     */
    where?: snapshot_strategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of snapshot_strategies to fetch.
     */
    orderBy?: Enumerable<snapshot_strategyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for snapshot_strategies.
     */
    cursor?: snapshot_strategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` snapshot_strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` snapshot_strategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of snapshot_strategies.
     */
    distinct?: Enumerable<Snapshot_strategyScalarFieldEnum>
  }


  /**
   * snapshot_strategy findMany
   */
  export type snapshot_strategyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snapshot_strategy
     */
    select?: snapshot_strategySelect<ExtArgs> | null
    /**
     * Filter, which snapshot_strategies to fetch.
     */
    where?: snapshot_strategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of snapshot_strategies to fetch.
     */
    orderBy?: Enumerable<snapshot_strategyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing snapshot_strategies.
     */
    cursor?: snapshot_strategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` snapshot_strategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` snapshot_strategies.
     */
    skip?: number
    distinct?: Enumerable<Snapshot_strategyScalarFieldEnum>
  }


  /**
   * snapshot_strategy create
   */
  export type snapshot_strategyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snapshot_strategy
     */
    select?: snapshot_strategySelect<ExtArgs> | null
    /**
     * The data needed to create a snapshot_strategy.
     */
    data: XOR<snapshot_strategyCreateInput, snapshot_strategyUncheckedCreateInput>
  }


  /**
   * snapshot_strategy createMany
   */
  export type snapshot_strategyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many snapshot_strategies.
     */
    data: Enumerable<snapshot_strategyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * snapshot_strategy update
   */
  export type snapshot_strategyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snapshot_strategy
     */
    select?: snapshot_strategySelect<ExtArgs> | null
    /**
     * The data needed to update a snapshot_strategy.
     */
    data: XOR<snapshot_strategyUpdateInput, snapshot_strategyUncheckedUpdateInput>
    /**
     * Choose, which snapshot_strategy to update.
     */
    where: snapshot_strategyWhereUniqueInput
  }


  /**
   * snapshot_strategy updateMany
   */
  export type snapshot_strategyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update snapshot_strategies.
     */
    data: XOR<snapshot_strategyUpdateManyMutationInput, snapshot_strategyUncheckedUpdateManyInput>
    /**
     * Filter which snapshot_strategies to update
     */
    where?: snapshot_strategyWhereInput
  }


  /**
   * snapshot_strategy upsert
   */
  export type snapshot_strategyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snapshot_strategy
     */
    select?: snapshot_strategySelect<ExtArgs> | null
    /**
     * The filter to search for the snapshot_strategy to update in case it exists.
     */
    where: snapshot_strategyWhereUniqueInput
    /**
     * In case the snapshot_strategy found by the `where` argument doesn't exist, create a new snapshot_strategy with this data.
     */
    create: XOR<snapshot_strategyCreateInput, snapshot_strategyUncheckedCreateInput>
    /**
     * In case the snapshot_strategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<snapshot_strategyUpdateInput, snapshot_strategyUncheckedUpdateInput>
  }


  /**
   * snapshot_strategy delete
   */
  export type snapshot_strategyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snapshot_strategy
     */
    select?: snapshot_strategySelect<ExtArgs> | null
    /**
     * Filter which snapshot_strategy to delete.
     */
    where: snapshot_strategyWhereUniqueInput
  }


  /**
   * snapshot_strategy deleteMany
   */
  export type snapshot_strategyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which snapshot_strategies to delete
     */
    where?: snapshot_strategyWhereInput
  }


  /**
   * snapshot_strategy without action
   */
  export type snapshot_strategyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snapshot_strategy
     */
    select?: snapshot_strategySelect<ExtArgs> | null
  }



  /**
   * Model basis_comparison
   */


  export type AggregateBasis_comparison = {
    _count: Basis_comparisonCountAggregateOutputType | null
    _avg: Basis_comparisonAvgAggregateOutputType | null
    _sum: Basis_comparisonSumAggregateOutputType | null
    _min: Basis_comparisonMinAggregateOutputType | null
    _max: Basis_comparisonMaxAggregateOutputType | null
  }

  export type Basis_comparisonAvgAggregateOutputType = {
    contract_december_2023: number | null
    contract_december_2024: number | null
  }

  export type Basis_comparisonSumAggregateOutputType = {
    contract_december_2023: number | null
    contract_december_2024: number | null
  }

  export type Basis_comparisonMinAggregateOutputType = {
    record_id: string | null
    date_of_basis_report: Date | null
    country: string | null
    cost_type: string | null
    contract_december_2023: number | null
    contract_december_2024: number | null
    added_by: string | null
  }

  export type Basis_comparisonMaxAggregateOutputType = {
    record_id: string | null
    date_of_basis_report: Date | null
    country: string | null
    cost_type: string | null
    contract_december_2023: number | null
    contract_december_2024: number | null
    added_by: string | null
  }

  export type Basis_comparisonCountAggregateOutputType = {
    record_id: number
    date_of_basis_report: number
    country: number
    cost_type: number
    contract_december_2023: number
    contract_december_2024: number
    added_by: number
    _all: number
  }


  export type Basis_comparisonAvgAggregateInputType = {
    contract_december_2023?: true
    contract_december_2024?: true
  }

  export type Basis_comparisonSumAggregateInputType = {
    contract_december_2023?: true
    contract_december_2024?: true
  }

  export type Basis_comparisonMinAggregateInputType = {
    record_id?: true
    date_of_basis_report?: true
    country?: true
    cost_type?: true
    contract_december_2023?: true
    contract_december_2024?: true
    added_by?: true
  }

  export type Basis_comparisonMaxAggregateInputType = {
    record_id?: true
    date_of_basis_report?: true
    country?: true
    cost_type?: true
    contract_december_2023?: true
    contract_december_2024?: true
    added_by?: true
  }

  export type Basis_comparisonCountAggregateInputType = {
    record_id?: true
    date_of_basis_report?: true
    country?: true
    cost_type?: true
    contract_december_2023?: true
    contract_december_2024?: true
    added_by?: true
    _all?: true
  }

  export type Basis_comparisonAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which basis_comparison to aggregate.
     */
    where?: basis_comparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basis_comparisons to fetch.
     */
    orderBy?: Enumerable<basis_comparisonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: basis_comparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basis_comparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basis_comparisons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned basis_comparisons
    **/
    _count?: true | Basis_comparisonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Basis_comparisonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Basis_comparisonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Basis_comparisonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Basis_comparisonMaxAggregateInputType
  }

  export type GetBasis_comparisonAggregateType<T extends Basis_comparisonAggregateArgs> = {
        [P in keyof T & keyof AggregateBasis_comparison]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBasis_comparison[P]>
      : GetScalarType<T[P], AggregateBasis_comparison[P]>
  }




  export type Basis_comparisonGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: basis_comparisonWhereInput
    orderBy?: Enumerable<basis_comparisonOrderByWithAggregationInput>
    by: Basis_comparisonScalarFieldEnum[]
    having?: basis_comparisonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Basis_comparisonCountAggregateInputType | true
    _avg?: Basis_comparisonAvgAggregateInputType
    _sum?: Basis_comparisonSumAggregateInputType
    _min?: Basis_comparisonMinAggregateInputType
    _max?: Basis_comparisonMaxAggregateInputType
  }


  export type Basis_comparisonGroupByOutputType = {
    record_id: string
    date_of_basis_report: Date
    country: string
    cost_type: string
    contract_december_2023: number
    contract_december_2024: number
    added_by: string
    _count: Basis_comparisonCountAggregateOutputType | null
    _avg: Basis_comparisonAvgAggregateOutputType | null
    _sum: Basis_comparisonSumAggregateOutputType | null
    _min: Basis_comparisonMinAggregateOutputType | null
    _max: Basis_comparisonMaxAggregateOutputType | null
  }

  type GetBasis_comparisonGroupByPayload<T extends Basis_comparisonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Basis_comparisonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Basis_comparisonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Basis_comparisonGroupByOutputType[P]>
            : GetScalarType<T[P], Basis_comparisonGroupByOutputType[P]>
        }
      >
    >


  export type basis_comparisonSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    date_of_basis_report?: boolean
    country?: boolean
    cost_type?: boolean
    contract_december_2023?: boolean
    contract_december_2024?: boolean
    added_by?: boolean
  }, ExtArgs["result"]["basis_comparison"]>

  export type basis_comparisonSelectScalar = {
    record_id?: boolean
    date_of_basis_report?: boolean
    country?: boolean
    cost_type?: boolean
    contract_december_2023?: boolean
    contract_december_2024?: boolean
    added_by?: boolean
  }


  type basis_comparisonGetPayload<S extends boolean | null | undefined | basis_comparisonArgs> = $Types.GetResult<basis_comparisonPayload, S>

  type basis_comparisonCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<basis_comparisonFindManyArgs, 'select' | 'include'> & {
      select?: Basis_comparisonCountAggregateInputType | true
    }

  export interface basis_comparisonDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['basis_comparison'], meta: { name: 'basis_comparison' } }
    /**
     * Find zero or one Basis_comparison that matches the filter.
     * @param {basis_comparisonFindUniqueArgs} args - Arguments to find a Basis_comparison
     * @example
     * // Get one Basis_comparison
     * const basis_comparison = await prisma.basis_comparison.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends basis_comparisonFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, basis_comparisonFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'basis_comparison'> extends True ? Prisma__basis_comparisonClient<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__basis_comparisonClient<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Basis_comparison that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {basis_comparisonFindUniqueOrThrowArgs} args - Arguments to find a Basis_comparison
     * @example
     * // Get one Basis_comparison
     * const basis_comparison = await prisma.basis_comparison.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends basis_comparisonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, basis_comparisonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__basis_comparisonClient<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Basis_comparison that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basis_comparisonFindFirstArgs} args - Arguments to find a Basis_comparison
     * @example
     * // Get one Basis_comparison
     * const basis_comparison = await prisma.basis_comparison.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends basis_comparisonFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, basis_comparisonFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'basis_comparison'> extends True ? Prisma__basis_comparisonClient<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__basis_comparisonClient<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Basis_comparison that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basis_comparisonFindFirstOrThrowArgs} args - Arguments to find a Basis_comparison
     * @example
     * // Get one Basis_comparison
     * const basis_comparison = await prisma.basis_comparison.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends basis_comparisonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, basis_comparisonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__basis_comparisonClient<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Basis_comparisons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basis_comparisonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Basis_comparisons
     * const basis_comparisons = await prisma.basis_comparison.findMany()
     * 
     * // Get first 10 Basis_comparisons
     * const basis_comparisons = await prisma.basis_comparison.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const basis_comparisonWithRecord_idOnly = await prisma.basis_comparison.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends basis_comparisonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, basis_comparisonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Basis_comparison.
     * @param {basis_comparisonCreateArgs} args - Arguments to create a Basis_comparison.
     * @example
     * // Create one Basis_comparison
     * const Basis_comparison = await prisma.basis_comparison.create({
     *   data: {
     *     // ... data to create a Basis_comparison
     *   }
     * })
     * 
    **/
    create<T extends basis_comparisonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, basis_comparisonCreateArgs<ExtArgs>>
    ): Prisma__basis_comparisonClient<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Basis_comparisons.
     *     @param {basis_comparisonCreateManyArgs} args - Arguments to create many Basis_comparisons.
     *     @example
     *     // Create many Basis_comparisons
     *     const basis_comparison = await prisma.basis_comparison.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends basis_comparisonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, basis_comparisonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Basis_comparison.
     * @param {basis_comparisonDeleteArgs} args - Arguments to delete one Basis_comparison.
     * @example
     * // Delete one Basis_comparison
     * const Basis_comparison = await prisma.basis_comparison.delete({
     *   where: {
     *     // ... filter to delete one Basis_comparison
     *   }
     * })
     * 
    **/
    delete<T extends basis_comparisonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, basis_comparisonDeleteArgs<ExtArgs>>
    ): Prisma__basis_comparisonClient<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Basis_comparison.
     * @param {basis_comparisonUpdateArgs} args - Arguments to update one Basis_comparison.
     * @example
     * // Update one Basis_comparison
     * const basis_comparison = await prisma.basis_comparison.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends basis_comparisonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, basis_comparisonUpdateArgs<ExtArgs>>
    ): Prisma__basis_comparisonClient<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Basis_comparisons.
     * @param {basis_comparisonDeleteManyArgs} args - Arguments to filter Basis_comparisons to delete.
     * @example
     * // Delete a few Basis_comparisons
     * const { count } = await prisma.basis_comparison.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends basis_comparisonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, basis_comparisonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Basis_comparisons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basis_comparisonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Basis_comparisons
     * const basis_comparison = await prisma.basis_comparison.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends basis_comparisonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, basis_comparisonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Basis_comparison.
     * @param {basis_comparisonUpsertArgs} args - Arguments to update or create a Basis_comparison.
     * @example
     * // Update or create a Basis_comparison
     * const basis_comparison = await prisma.basis_comparison.upsert({
     *   create: {
     *     // ... data to create a Basis_comparison
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Basis_comparison we want to update
     *   }
     * })
    **/
    upsert<T extends basis_comparisonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, basis_comparisonUpsertArgs<ExtArgs>>
    ): Prisma__basis_comparisonClient<$Types.GetResult<basis_comparisonPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Basis_comparisons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basis_comparisonCountArgs} args - Arguments to filter Basis_comparisons to count.
     * @example
     * // Count the number of Basis_comparisons
     * const count = await prisma.basis_comparison.count({
     *   where: {
     *     // ... the filter for the Basis_comparisons we want to count
     *   }
     * })
    **/
    count<T extends basis_comparisonCountArgs>(
      args?: Subset<T, basis_comparisonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Basis_comparisonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Basis_comparison.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Basis_comparisonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Basis_comparisonAggregateArgs>(args: Subset<T, Basis_comparisonAggregateArgs>): Prisma.PrismaPromise<GetBasis_comparisonAggregateType<T>>

    /**
     * Group by Basis_comparison.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Basis_comparisonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Basis_comparisonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Basis_comparisonGroupByArgs['orderBy'] }
        : { orderBy?: Basis_comparisonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Basis_comparisonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBasis_comparisonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for basis_comparison.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__basis_comparisonClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * basis_comparison base type for findUnique actions
   */
  export type basis_comparisonFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basis_comparison
     */
    select?: basis_comparisonSelect<ExtArgs> | null
    /**
     * Filter, which basis_comparison to fetch.
     */
    where: basis_comparisonWhereUniqueInput
  }

  /**
   * basis_comparison findUnique
   */
  export interface basis_comparisonFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends basis_comparisonFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * basis_comparison findUniqueOrThrow
   */
  export type basis_comparisonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basis_comparison
     */
    select?: basis_comparisonSelect<ExtArgs> | null
    /**
     * Filter, which basis_comparison to fetch.
     */
    where: basis_comparisonWhereUniqueInput
  }


  /**
   * basis_comparison base type for findFirst actions
   */
  export type basis_comparisonFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basis_comparison
     */
    select?: basis_comparisonSelect<ExtArgs> | null
    /**
     * Filter, which basis_comparison to fetch.
     */
    where?: basis_comparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basis_comparisons to fetch.
     */
    orderBy?: Enumerable<basis_comparisonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for basis_comparisons.
     */
    cursor?: basis_comparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basis_comparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basis_comparisons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of basis_comparisons.
     */
    distinct?: Enumerable<Basis_comparisonScalarFieldEnum>
  }

  /**
   * basis_comparison findFirst
   */
  export interface basis_comparisonFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends basis_comparisonFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * basis_comparison findFirstOrThrow
   */
  export type basis_comparisonFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basis_comparison
     */
    select?: basis_comparisonSelect<ExtArgs> | null
    /**
     * Filter, which basis_comparison to fetch.
     */
    where?: basis_comparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basis_comparisons to fetch.
     */
    orderBy?: Enumerable<basis_comparisonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for basis_comparisons.
     */
    cursor?: basis_comparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basis_comparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basis_comparisons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of basis_comparisons.
     */
    distinct?: Enumerable<Basis_comparisonScalarFieldEnum>
  }


  /**
   * basis_comparison findMany
   */
  export type basis_comparisonFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basis_comparison
     */
    select?: basis_comparisonSelect<ExtArgs> | null
    /**
     * Filter, which basis_comparisons to fetch.
     */
    where?: basis_comparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basis_comparisons to fetch.
     */
    orderBy?: Enumerable<basis_comparisonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing basis_comparisons.
     */
    cursor?: basis_comparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basis_comparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basis_comparisons.
     */
    skip?: number
    distinct?: Enumerable<Basis_comparisonScalarFieldEnum>
  }


  /**
   * basis_comparison create
   */
  export type basis_comparisonCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basis_comparison
     */
    select?: basis_comparisonSelect<ExtArgs> | null
    /**
     * The data needed to create a basis_comparison.
     */
    data: XOR<basis_comparisonCreateInput, basis_comparisonUncheckedCreateInput>
  }


  /**
   * basis_comparison createMany
   */
  export type basis_comparisonCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many basis_comparisons.
     */
    data: Enumerable<basis_comparisonCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * basis_comparison update
   */
  export type basis_comparisonUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basis_comparison
     */
    select?: basis_comparisonSelect<ExtArgs> | null
    /**
     * The data needed to update a basis_comparison.
     */
    data: XOR<basis_comparisonUpdateInput, basis_comparisonUncheckedUpdateInput>
    /**
     * Choose, which basis_comparison to update.
     */
    where: basis_comparisonWhereUniqueInput
  }


  /**
   * basis_comparison updateMany
   */
  export type basis_comparisonUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update basis_comparisons.
     */
    data: XOR<basis_comparisonUpdateManyMutationInput, basis_comparisonUncheckedUpdateManyInput>
    /**
     * Filter which basis_comparisons to update
     */
    where?: basis_comparisonWhereInput
  }


  /**
   * basis_comparison upsert
   */
  export type basis_comparisonUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basis_comparison
     */
    select?: basis_comparisonSelect<ExtArgs> | null
    /**
     * The filter to search for the basis_comparison to update in case it exists.
     */
    where: basis_comparisonWhereUniqueInput
    /**
     * In case the basis_comparison found by the `where` argument doesn't exist, create a new basis_comparison with this data.
     */
    create: XOR<basis_comparisonCreateInput, basis_comparisonUncheckedCreateInput>
    /**
     * In case the basis_comparison was found with the provided `where` argument, update it with this data.
     */
    update: XOR<basis_comparisonUpdateInput, basis_comparisonUncheckedUpdateInput>
  }


  /**
   * basis_comparison delete
   */
  export type basis_comparisonDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basis_comparison
     */
    select?: basis_comparisonSelect<ExtArgs> | null
    /**
     * Filter which basis_comparison to delete.
     */
    where: basis_comparisonWhereUniqueInput
  }


  /**
   * basis_comparison deleteMany
   */
  export type basis_comparisonDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which basis_comparisons to delete
     */
    where?: basis_comparisonWhereInput
  }


  /**
   * basis_comparison without action
   */
  export type basis_comparisonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basis_comparison
     */
    select?: basis_comparisonSelect<ExtArgs> | null
  }



  /**
   * Model in_country_news
   */


  export type AggregateIn_country_news = {
    _count: In_country_newsCountAggregateOutputType | null
    _min: In_country_newsMinAggregateOutputType | null
    _max: In_country_newsMaxAggregateOutputType | null
  }

  export type In_country_newsMinAggregateOutputType = {
    record_id: string | null
    country: string | null
    image_of_in_country_news: string | null
    title_of_in_country_news: string | null
    text_of_in_country_news: string | null
    date_of_in_country_news: Date | null
    impact: string | null
    added_by: string | null
    verified: boolean | null
  }

  export type In_country_newsMaxAggregateOutputType = {
    record_id: string | null
    country: string | null
    image_of_in_country_news: string | null
    title_of_in_country_news: string | null
    text_of_in_country_news: string | null
    date_of_in_country_news: Date | null
    impact: string | null
    added_by: string | null
    verified: boolean | null
  }

  export type In_country_newsCountAggregateOutputType = {
    record_id: number
    country: number
    image_of_in_country_news: number
    title_of_in_country_news: number
    text_of_in_country_news: number
    date_of_in_country_news: number
    impact: number
    added_by: number
    verified: number
    _all: number
  }


  export type In_country_newsMinAggregateInputType = {
    record_id?: true
    country?: true
    image_of_in_country_news?: true
    title_of_in_country_news?: true
    text_of_in_country_news?: true
    date_of_in_country_news?: true
    impact?: true
    added_by?: true
    verified?: true
  }

  export type In_country_newsMaxAggregateInputType = {
    record_id?: true
    country?: true
    image_of_in_country_news?: true
    title_of_in_country_news?: true
    text_of_in_country_news?: true
    date_of_in_country_news?: true
    impact?: true
    added_by?: true
    verified?: true
  }

  export type In_country_newsCountAggregateInputType = {
    record_id?: true
    country?: true
    image_of_in_country_news?: true
    title_of_in_country_news?: true
    text_of_in_country_news?: true
    date_of_in_country_news?: true
    impact?: true
    added_by?: true
    verified?: true
    _all?: true
  }

  export type In_country_newsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which in_country_news to aggregate.
     */
    where?: in_country_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of in_country_news to fetch.
     */
    orderBy?: Enumerable<in_country_newsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: in_country_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` in_country_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` in_country_news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned in_country_news
    **/
    _count?: true | In_country_newsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: In_country_newsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: In_country_newsMaxAggregateInputType
  }

  export type GetIn_country_newsAggregateType<T extends In_country_newsAggregateArgs> = {
        [P in keyof T & keyof AggregateIn_country_news]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIn_country_news[P]>
      : GetScalarType<T[P], AggregateIn_country_news[P]>
  }




  export type In_country_newsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: in_country_newsWhereInput
    orderBy?: Enumerable<in_country_newsOrderByWithAggregationInput>
    by: In_country_newsScalarFieldEnum[]
    having?: in_country_newsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: In_country_newsCountAggregateInputType | true
    _min?: In_country_newsMinAggregateInputType
    _max?: In_country_newsMaxAggregateInputType
  }


  export type In_country_newsGroupByOutputType = {
    record_id: string
    country: string | null
    image_of_in_country_news: string | null
    title_of_in_country_news: string
    text_of_in_country_news: string
    date_of_in_country_news: Date
    impact: string | null
    added_by: string
    verified: boolean
    _count: In_country_newsCountAggregateOutputType | null
    _min: In_country_newsMinAggregateOutputType | null
    _max: In_country_newsMaxAggregateOutputType | null
  }

  type GetIn_country_newsGroupByPayload<T extends In_country_newsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<In_country_newsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof In_country_newsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], In_country_newsGroupByOutputType[P]>
            : GetScalarType<T[P], In_country_newsGroupByOutputType[P]>
        }
      >
    >


  export type in_country_newsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    country?: boolean
    image_of_in_country_news?: boolean
    title_of_in_country_news?: boolean
    text_of_in_country_news?: boolean
    date_of_in_country_news?: boolean
    impact?: boolean
    added_by?: boolean
    verified?: boolean
  }, ExtArgs["result"]["in_country_news"]>

  export type in_country_newsSelectScalar = {
    record_id?: boolean
    country?: boolean
    image_of_in_country_news?: boolean
    title_of_in_country_news?: boolean
    text_of_in_country_news?: boolean
    date_of_in_country_news?: boolean
    impact?: boolean
    added_by?: boolean
    verified?: boolean
  }


  type in_country_newsGetPayload<S extends boolean | null | undefined | in_country_newsArgs> = $Types.GetResult<in_country_newsPayload, S>

  type in_country_newsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<in_country_newsFindManyArgs, 'select' | 'include'> & {
      select?: In_country_newsCountAggregateInputType | true
    }

  export interface in_country_newsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['in_country_news'], meta: { name: 'in_country_news' } }
    /**
     * Find zero or one In_country_news that matches the filter.
     * @param {in_country_newsFindUniqueArgs} args - Arguments to find a In_country_news
     * @example
     * // Get one In_country_news
     * const in_country_news = await prisma.in_country_news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends in_country_newsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, in_country_newsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'in_country_news'> extends True ? Prisma__in_country_newsClient<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__in_country_newsClient<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one In_country_news that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {in_country_newsFindUniqueOrThrowArgs} args - Arguments to find a In_country_news
     * @example
     * // Get one In_country_news
     * const in_country_news = await prisma.in_country_news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends in_country_newsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, in_country_newsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__in_country_newsClient<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first In_country_news that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_country_newsFindFirstArgs} args - Arguments to find a In_country_news
     * @example
     * // Get one In_country_news
     * const in_country_news = await prisma.in_country_news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends in_country_newsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, in_country_newsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'in_country_news'> extends True ? Prisma__in_country_newsClient<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__in_country_newsClient<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first In_country_news that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_country_newsFindFirstOrThrowArgs} args - Arguments to find a In_country_news
     * @example
     * // Get one In_country_news
     * const in_country_news = await prisma.in_country_news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends in_country_newsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, in_country_newsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__in_country_newsClient<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more In_country_news that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_country_newsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all In_country_news
     * const in_country_news = await prisma.in_country_news.findMany()
     * 
     * // Get first 10 In_country_news
     * const in_country_news = await prisma.in_country_news.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const in_country_newsWithRecord_idOnly = await prisma.in_country_news.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends in_country_newsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, in_country_newsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a In_country_news.
     * @param {in_country_newsCreateArgs} args - Arguments to create a In_country_news.
     * @example
     * // Create one In_country_news
     * const In_country_news = await prisma.in_country_news.create({
     *   data: {
     *     // ... data to create a In_country_news
     *   }
     * })
     * 
    **/
    create<T extends in_country_newsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, in_country_newsCreateArgs<ExtArgs>>
    ): Prisma__in_country_newsClient<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many In_country_news.
     *     @param {in_country_newsCreateManyArgs} args - Arguments to create many In_country_news.
     *     @example
     *     // Create many In_country_news
     *     const in_country_news = await prisma.in_country_news.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends in_country_newsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, in_country_newsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a In_country_news.
     * @param {in_country_newsDeleteArgs} args - Arguments to delete one In_country_news.
     * @example
     * // Delete one In_country_news
     * const In_country_news = await prisma.in_country_news.delete({
     *   where: {
     *     // ... filter to delete one In_country_news
     *   }
     * })
     * 
    **/
    delete<T extends in_country_newsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, in_country_newsDeleteArgs<ExtArgs>>
    ): Prisma__in_country_newsClient<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one In_country_news.
     * @param {in_country_newsUpdateArgs} args - Arguments to update one In_country_news.
     * @example
     * // Update one In_country_news
     * const in_country_news = await prisma.in_country_news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends in_country_newsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, in_country_newsUpdateArgs<ExtArgs>>
    ): Prisma__in_country_newsClient<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more In_country_news.
     * @param {in_country_newsDeleteManyArgs} args - Arguments to filter In_country_news to delete.
     * @example
     * // Delete a few In_country_news
     * const { count } = await prisma.in_country_news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends in_country_newsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, in_country_newsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more In_country_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_country_newsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many In_country_news
     * const in_country_news = await prisma.in_country_news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends in_country_newsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, in_country_newsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one In_country_news.
     * @param {in_country_newsUpsertArgs} args - Arguments to update or create a In_country_news.
     * @example
     * // Update or create a In_country_news
     * const in_country_news = await prisma.in_country_news.upsert({
     *   create: {
     *     // ... data to create a In_country_news
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the In_country_news we want to update
     *   }
     * })
    **/
    upsert<T extends in_country_newsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, in_country_newsUpsertArgs<ExtArgs>>
    ): Prisma__in_country_newsClient<$Types.GetResult<in_country_newsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of In_country_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in_country_newsCountArgs} args - Arguments to filter In_country_news to count.
     * @example
     * // Count the number of In_country_news
     * const count = await prisma.in_country_news.count({
     *   where: {
     *     // ... the filter for the In_country_news we want to count
     *   }
     * })
    **/
    count<T extends in_country_newsCountArgs>(
      args?: Subset<T, in_country_newsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], In_country_newsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a In_country_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {In_country_newsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends In_country_newsAggregateArgs>(args: Subset<T, In_country_newsAggregateArgs>): Prisma.PrismaPromise<GetIn_country_newsAggregateType<T>>

    /**
     * Group by In_country_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {In_country_newsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends In_country_newsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: In_country_newsGroupByArgs['orderBy'] }
        : { orderBy?: In_country_newsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, In_country_newsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIn_country_newsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for in_country_news.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__in_country_newsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * in_country_news base type for findUnique actions
   */
  export type in_country_newsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in_country_news
     */
    select?: in_country_newsSelect<ExtArgs> | null
    /**
     * Filter, which in_country_news to fetch.
     */
    where: in_country_newsWhereUniqueInput
  }

  /**
   * in_country_news findUnique
   */
  export interface in_country_newsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends in_country_newsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * in_country_news findUniqueOrThrow
   */
  export type in_country_newsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in_country_news
     */
    select?: in_country_newsSelect<ExtArgs> | null
    /**
     * Filter, which in_country_news to fetch.
     */
    where: in_country_newsWhereUniqueInput
  }


  /**
   * in_country_news base type for findFirst actions
   */
  export type in_country_newsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in_country_news
     */
    select?: in_country_newsSelect<ExtArgs> | null
    /**
     * Filter, which in_country_news to fetch.
     */
    where?: in_country_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of in_country_news to fetch.
     */
    orderBy?: Enumerable<in_country_newsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for in_country_news.
     */
    cursor?: in_country_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` in_country_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` in_country_news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of in_country_news.
     */
    distinct?: Enumerable<In_country_newsScalarFieldEnum>
  }

  /**
   * in_country_news findFirst
   */
  export interface in_country_newsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends in_country_newsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * in_country_news findFirstOrThrow
   */
  export type in_country_newsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in_country_news
     */
    select?: in_country_newsSelect<ExtArgs> | null
    /**
     * Filter, which in_country_news to fetch.
     */
    where?: in_country_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of in_country_news to fetch.
     */
    orderBy?: Enumerable<in_country_newsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for in_country_news.
     */
    cursor?: in_country_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` in_country_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` in_country_news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of in_country_news.
     */
    distinct?: Enumerable<In_country_newsScalarFieldEnum>
  }


  /**
   * in_country_news findMany
   */
  export type in_country_newsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in_country_news
     */
    select?: in_country_newsSelect<ExtArgs> | null
    /**
     * Filter, which in_country_news to fetch.
     */
    where?: in_country_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of in_country_news to fetch.
     */
    orderBy?: Enumerable<in_country_newsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing in_country_news.
     */
    cursor?: in_country_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` in_country_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` in_country_news.
     */
    skip?: number
    distinct?: Enumerable<In_country_newsScalarFieldEnum>
  }


  /**
   * in_country_news create
   */
  export type in_country_newsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in_country_news
     */
    select?: in_country_newsSelect<ExtArgs> | null
    /**
     * The data needed to create a in_country_news.
     */
    data: XOR<in_country_newsCreateInput, in_country_newsUncheckedCreateInput>
  }


  /**
   * in_country_news createMany
   */
  export type in_country_newsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many in_country_news.
     */
    data: Enumerable<in_country_newsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * in_country_news update
   */
  export type in_country_newsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in_country_news
     */
    select?: in_country_newsSelect<ExtArgs> | null
    /**
     * The data needed to update a in_country_news.
     */
    data: XOR<in_country_newsUpdateInput, in_country_newsUncheckedUpdateInput>
    /**
     * Choose, which in_country_news to update.
     */
    where: in_country_newsWhereUniqueInput
  }


  /**
   * in_country_news updateMany
   */
  export type in_country_newsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update in_country_news.
     */
    data: XOR<in_country_newsUpdateManyMutationInput, in_country_newsUncheckedUpdateManyInput>
    /**
     * Filter which in_country_news to update
     */
    where?: in_country_newsWhereInput
  }


  /**
   * in_country_news upsert
   */
  export type in_country_newsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in_country_news
     */
    select?: in_country_newsSelect<ExtArgs> | null
    /**
     * The filter to search for the in_country_news to update in case it exists.
     */
    where: in_country_newsWhereUniqueInput
    /**
     * In case the in_country_news found by the `where` argument doesn't exist, create a new in_country_news with this data.
     */
    create: XOR<in_country_newsCreateInput, in_country_newsUncheckedCreateInput>
    /**
     * In case the in_country_news was found with the provided `where` argument, update it with this data.
     */
    update: XOR<in_country_newsUpdateInput, in_country_newsUncheckedUpdateInput>
  }


  /**
   * in_country_news delete
   */
  export type in_country_newsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in_country_news
     */
    select?: in_country_newsSelect<ExtArgs> | null
    /**
     * Filter which in_country_news to delete.
     */
    where: in_country_newsWhereUniqueInput
  }


  /**
   * in_country_news deleteMany
   */
  export type in_country_newsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which in_country_news to delete
     */
    where?: in_country_newsWhereInput
  }


  /**
   * in_country_news without action
   */
  export type in_country_newsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in_country_news
     */
    select?: in_country_newsSelect<ExtArgs> | null
  }



  /**
   * Model sentiment_survey
   */


  export type AggregateSentiment_survey = {
    _count: Sentiment_surveyCountAggregateOutputType | null
    _avg: Sentiment_surveyAvgAggregateOutputType | null
    _sum: Sentiment_surveySumAggregateOutputType | null
    _min: Sentiment_surveyMinAggregateOutputType | null
    _max: Sentiment_surveyMaxAggregateOutputType | null
  }

  export type Sentiment_surveyAvgAggregateOutputType = {
    bullish_or_bearish_value: Decimal | null
    high: Decimal | null
    low: Decimal | null
    intraday_average_points: Decimal | null
    open_interest: Decimal | null
  }

  export type Sentiment_surveySumAggregateOutputType = {
    bullish_or_bearish_value: Decimal | null
    high: Decimal | null
    low: Decimal | null
    intraday_average_points: Decimal | null
    open_interest: Decimal | null
  }

  export type Sentiment_surveyMinAggregateOutputType = {
    record_id: string | null
    bullish_or_bearish: string | null
    bullish_or_bearish_value: Decimal | null
    high: Decimal | null
    low: Decimal | null
    intraday_average_points: Decimal | null
    open_interest: Decimal | null
    date_of_survey: Date | null
    added_by: string | null
  }

  export type Sentiment_surveyMaxAggregateOutputType = {
    record_id: string | null
    bullish_or_bearish: string | null
    bullish_or_bearish_value: Decimal | null
    high: Decimal | null
    low: Decimal | null
    intraday_average_points: Decimal | null
    open_interest: Decimal | null
    date_of_survey: Date | null
    added_by: string | null
  }

  export type Sentiment_surveyCountAggregateOutputType = {
    record_id: number
    bullish_or_bearish: number
    bullish_or_bearish_value: number
    high: number
    low: number
    intraday_average_points: number
    open_interest: number
    date_of_survey: number
    added_by: number
    _all: number
  }


  export type Sentiment_surveyAvgAggregateInputType = {
    bullish_or_bearish_value?: true
    high?: true
    low?: true
    intraday_average_points?: true
    open_interest?: true
  }

  export type Sentiment_surveySumAggregateInputType = {
    bullish_or_bearish_value?: true
    high?: true
    low?: true
    intraday_average_points?: true
    open_interest?: true
  }

  export type Sentiment_surveyMinAggregateInputType = {
    record_id?: true
    bullish_or_bearish?: true
    bullish_or_bearish_value?: true
    high?: true
    low?: true
    intraday_average_points?: true
    open_interest?: true
    date_of_survey?: true
    added_by?: true
  }

  export type Sentiment_surveyMaxAggregateInputType = {
    record_id?: true
    bullish_or_bearish?: true
    bullish_or_bearish_value?: true
    high?: true
    low?: true
    intraday_average_points?: true
    open_interest?: true
    date_of_survey?: true
    added_by?: true
  }

  export type Sentiment_surveyCountAggregateInputType = {
    record_id?: true
    bullish_or_bearish?: true
    bullish_or_bearish_value?: true
    high?: true
    low?: true
    intraday_average_points?: true
    open_interest?: true
    date_of_survey?: true
    added_by?: true
    _all?: true
  }

  export type Sentiment_surveyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sentiment_survey to aggregate.
     */
    where?: sentiment_surveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sentiment_surveys to fetch.
     */
    orderBy?: Enumerable<sentiment_surveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sentiment_surveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sentiment_surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sentiment_surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sentiment_surveys
    **/
    _count?: true | Sentiment_surveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sentiment_surveyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sentiment_surveySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sentiment_surveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sentiment_surveyMaxAggregateInputType
  }

  export type GetSentiment_surveyAggregateType<T extends Sentiment_surveyAggregateArgs> = {
        [P in keyof T & keyof AggregateSentiment_survey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSentiment_survey[P]>
      : GetScalarType<T[P], AggregateSentiment_survey[P]>
  }




  export type Sentiment_surveyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: sentiment_surveyWhereInput
    orderBy?: Enumerable<sentiment_surveyOrderByWithAggregationInput>
    by: Sentiment_surveyScalarFieldEnum[]
    having?: sentiment_surveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sentiment_surveyCountAggregateInputType | true
    _avg?: Sentiment_surveyAvgAggregateInputType
    _sum?: Sentiment_surveySumAggregateInputType
    _min?: Sentiment_surveyMinAggregateInputType
    _max?: Sentiment_surveyMaxAggregateInputType
  }


  export type Sentiment_surveyGroupByOutputType = {
    record_id: string
    bullish_or_bearish: string
    bullish_or_bearish_value: Decimal | null
    high: Decimal | null
    low: Decimal | null
    intraday_average_points: Decimal | null
    open_interest: Decimal | null
    date_of_survey: Date | null
    added_by: string
    _count: Sentiment_surveyCountAggregateOutputType | null
    _avg: Sentiment_surveyAvgAggregateOutputType | null
    _sum: Sentiment_surveySumAggregateOutputType | null
    _min: Sentiment_surveyMinAggregateOutputType | null
    _max: Sentiment_surveyMaxAggregateOutputType | null
  }

  type GetSentiment_surveyGroupByPayload<T extends Sentiment_surveyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Sentiment_surveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sentiment_surveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sentiment_surveyGroupByOutputType[P]>
            : GetScalarType<T[P], Sentiment_surveyGroupByOutputType[P]>
        }
      >
    >


  export type sentiment_surveySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    bullish_or_bearish?: boolean
    bullish_or_bearish_value?: boolean
    high?: boolean
    low?: boolean
    intraday_average_points?: boolean
    open_interest?: boolean
    date_of_survey?: boolean
    added_by?: boolean
  }, ExtArgs["result"]["sentiment_survey"]>

  export type sentiment_surveySelectScalar = {
    record_id?: boolean
    bullish_or_bearish?: boolean
    bullish_or_bearish_value?: boolean
    high?: boolean
    low?: boolean
    intraday_average_points?: boolean
    open_interest?: boolean
    date_of_survey?: boolean
    added_by?: boolean
  }


  type sentiment_surveyGetPayload<S extends boolean | null | undefined | sentiment_surveyArgs> = $Types.GetResult<sentiment_surveyPayload, S>

  type sentiment_surveyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<sentiment_surveyFindManyArgs, 'select' | 'include'> & {
      select?: Sentiment_surveyCountAggregateInputType | true
    }

  export interface sentiment_surveyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sentiment_survey'], meta: { name: 'sentiment_survey' } }
    /**
     * Find zero or one Sentiment_survey that matches the filter.
     * @param {sentiment_surveyFindUniqueArgs} args - Arguments to find a Sentiment_survey
     * @example
     * // Get one Sentiment_survey
     * const sentiment_survey = await prisma.sentiment_survey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sentiment_surveyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sentiment_surveyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sentiment_survey'> extends True ? Prisma__sentiment_surveyClient<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__sentiment_surveyClient<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Sentiment_survey that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sentiment_surveyFindUniqueOrThrowArgs} args - Arguments to find a Sentiment_survey
     * @example
     * // Get one Sentiment_survey
     * const sentiment_survey = await prisma.sentiment_survey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sentiment_surveyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sentiment_surveyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sentiment_surveyClient<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Sentiment_survey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sentiment_surveyFindFirstArgs} args - Arguments to find a Sentiment_survey
     * @example
     * // Get one Sentiment_survey
     * const sentiment_survey = await prisma.sentiment_survey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sentiment_surveyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sentiment_surveyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sentiment_survey'> extends True ? Prisma__sentiment_surveyClient<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__sentiment_surveyClient<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Sentiment_survey that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sentiment_surveyFindFirstOrThrowArgs} args - Arguments to find a Sentiment_survey
     * @example
     * // Get one Sentiment_survey
     * const sentiment_survey = await prisma.sentiment_survey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sentiment_surveyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sentiment_surveyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sentiment_surveyClient<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Sentiment_surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sentiment_surveyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sentiment_surveys
     * const sentiment_surveys = await prisma.sentiment_survey.findMany()
     * 
     * // Get first 10 Sentiment_surveys
     * const sentiment_surveys = await prisma.sentiment_survey.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const sentiment_surveyWithRecord_idOnly = await prisma.sentiment_survey.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends sentiment_surveyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sentiment_surveyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Sentiment_survey.
     * @param {sentiment_surveyCreateArgs} args - Arguments to create a Sentiment_survey.
     * @example
     * // Create one Sentiment_survey
     * const Sentiment_survey = await prisma.sentiment_survey.create({
     *   data: {
     *     // ... data to create a Sentiment_survey
     *   }
     * })
     * 
    **/
    create<T extends sentiment_surveyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sentiment_surveyCreateArgs<ExtArgs>>
    ): Prisma__sentiment_surveyClient<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Sentiment_surveys.
     *     @param {sentiment_surveyCreateManyArgs} args - Arguments to create many Sentiment_surveys.
     *     @example
     *     // Create many Sentiment_surveys
     *     const sentiment_survey = await prisma.sentiment_survey.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sentiment_surveyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sentiment_surveyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sentiment_survey.
     * @param {sentiment_surveyDeleteArgs} args - Arguments to delete one Sentiment_survey.
     * @example
     * // Delete one Sentiment_survey
     * const Sentiment_survey = await prisma.sentiment_survey.delete({
     *   where: {
     *     // ... filter to delete one Sentiment_survey
     *   }
     * })
     * 
    **/
    delete<T extends sentiment_surveyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sentiment_surveyDeleteArgs<ExtArgs>>
    ): Prisma__sentiment_surveyClient<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Sentiment_survey.
     * @param {sentiment_surveyUpdateArgs} args - Arguments to update one Sentiment_survey.
     * @example
     * // Update one Sentiment_survey
     * const sentiment_survey = await prisma.sentiment_survey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sentiment_surveyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sentiment_surveyUpdateArgs<ExtArgs>>
    ): Prisma__sentiment_surveyClient<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Sentiment_surveys.
     * @param {sentiment_surveyDeleteManyArgs} args - Arguments to filter Sentiment_surveys to delete.
     * @example
     * // Delete a few Sentiment_surveys
     * const { count } = await prisma.sentiment_survey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sentiment_surveyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sentiment_surveyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sentiment_surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sentiment_surveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sentiment_surveys
     * const sentiment_survey = await prisma.sentiment_survey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sentiment_surveyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sentiment_surveyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sentiment_survey.
     * @param {sentiment_surveyUpsertArgs} args - Arguments to update or create a Sentiment_survey.
     * @example
     * // Update or create a Sentiment_survey
     * const sentiment_survey = await prisma.sentiment_survey.upsert({
     *   create: {
     *     // ... data to create a Sentiment_survey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sentiment_survey we want to update
     *   }
     * })
    **/
    upsert<T extends sentiment_surveyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sentiment_surveyUpsertArgs<ExtArgs>>
    ): Prisma__sentiment_surveyClient<$Types.GetResult<sentiment_surveyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Sentiment_surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sentiment_surveyCountArgs} args - Arguments to filter Sentiment_surveys to count.
     * @example
     * // Count the number of Sentiment_surveys
     * const count = await prisma.sentiment_survey.count({
     *   where: {
     *     // ... the filter for the Sentiment_surveys we want to count
     *   }
     * })
    **/
    count<T extends sentiment_surveyCountArgs>(
      args?: Subset<T, sentiment_surveyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sentiment_surveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sentiment_survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sentiment_surveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sentiment_surveyAggregateArgs>(args: Subset<T, Sentiment_surveyAggregateArgs>): Prisma.PrismaPromise<GetSentiment_surveyAggregateType<T>>

    /**
     * Group by Sentiment_survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sentiment_surveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Sentiment_surveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Sentiment_surveyGroupByArgs['orderBy'] }
        : { orderBy?: Sentiment_surveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Sentiment_surveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSentiment_surveyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sentiment_survey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sentiment_surveyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sentiment_survey base type for findUnique actions
   */
  export type sentiment_surveyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sentiment_survey
     */
    select?: sentiment_surveySelect<ExtArgs> | null
    /**
     * Filter, which sentiment_survey to fetch.
     */
    where: sentiment_surveyWhereUniqueInput
  }

  /**
   * sentiment_survey findUnique
   */
  export interface sentiment_surveyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends sentiment_surveyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sentiment_survey findUniqueOrThrow
   */
  export type sentiment_surveyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sentiment_survey
     */
    select?: sentiment_surveySelect<ExtArgs> | null
    /**
     * Filter, which sentiment_survey to fetch.
     */
    where: sentiment_surveyWhereUniqueInput
  }


  /**
   * sentiment_survey base type for findFirst actions
   */
  export type sentiment_surveyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sentiment_survey
     */
    select?: sentiment_surveySelect<ExtArgs> | null
    /**
     * Filter, which sentiment_survey to fetch.
     */
    where?: sentiment_surveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sentiment_surveys to fetch.
     */
    orderBy?: Enumerable<sentiment_surveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sentiment_surveys.
     */
    cursor?: sentiment_surveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sentiment_surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sentiment_surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sentiment_surveys.
     */
    distinct?: Enumerable<Sentiment_surveyScalarFieldEnum>
  }

  /**
   * sentiment_survey findFirst
   */
  export interface sentiment_surveyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends sentiment_surveyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sentiment_survey findFirstOrThrow
   */
  export type sentiment_surveyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sentiment_survey
     */
    select?: sentiment_surveySelect<ExtArgs> | null
    /**
     * Filter, which sentiment_survey to fetch.
     */
    where?: sentiment_surveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sentiment_surveys to fetch.
     */
    orderBy?: Enumerable<sentiment_surveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sentiment_surveys.
     */
    cursor?: sentiment_surveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sentiment_surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sentiment_surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sentiment_surveys.
     */
    distinct?: Enumerable<Sentiment_surveyScalarFieldEnum>
  }


  /**
   * sentiment_survey findMany
   */
  export type sentiment_surveyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sentiment_survey
     */
    select?: sentiment_surveySelect<ExtArgs> | null
    /**
     * Filter, which sentiment_surveys to fetch.
     */
    where?: sentiment_surveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sentiment_surveys to fetch.
     */
    orderBy?: Enumerable<sentiment_surveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sentiment_surveys.
     */
    cursor?: sentiment_surveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sentiment_surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sentiment_surveys.
     */
    skip?: number
    distinct?: Enumerable<Sentiment_surveyScalarFieldEnum>
  }


  /**
   * sentiment_survey create
   */
  export type sentiment_surveyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sentiment_survey
     */
    select?: sentiment_surveySelect<ExtArgs> | null
    /**
     * The data needed to create a sentiment_survey.
     */
    data: XOR<sentiment_surveyCreateInput, sentiment_surveyUncheckedCreateInput>
  }


  /**
   * sentiment_survey createMany
   */
  export type sentiment_surveyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sentiment_surveys.
     */
    data: Enumerable<sentiment_surveyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sentiment_survey update
   */
  export type sentiment_surveyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sentiment_survey
     */
    select?: sentiment_surveySelect<ExtArgs> | null
    /**
     * The data needed to update a sentiment_survey.
     */
    data: XOR<sentiment_surveyUpdateInput, sentiment_surveyUncheckedUpdateInput>
    /**
     * Choose, which sentiment_survey to update.
     */
    where: sentiment_surveyWhereUniqueInput
  }


  /**
   * sentiment_survey updateMany
   */
  export type sentiment_surveyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sentiment_surveys.
     */
    data: XOR<sentiment_surveyUpdateManyMutationInput, sentiment_surveyUncheckedUpdateManyInput>
    /**
     * Filter which sentiment_surveys to update
     */
    where?: sentiment_surveyWhereInput
  }


  /**
   * sentiment_survey upsert
   */
  export type sentiment_surveyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sentiment_survey
     */
    select?: sentiment_surveySelect<ExtArgs> | null
    /**
     * The filter to search for the sentiment_survey to update in case it exists.
     */
    where: sentiment_surveyWhereUniqueInput
    /**
     * In case the sentiment_survey found by the `where` argument doesn't exist, create a new sentiment_survey with this data.
     */
    create: XOR<sentiment_surveyCreateInput, sentiment_surveyUncheckedCreateInput>
    /**
     * In case the sentiment_survey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sentiment_surveyUpdateInput, sentiment_surveyUncheckedUpdateInput>
  }


  /**
   * sentiment_survey delete
   */
  export type sentiment_surveyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sentiment_survey
     */
    select?: sentiment_surveySelect<ExtArgs> | null
    /**
     * Filter which sentiment_survey to delete.
     */
    where: sentiment_surveyWhereUniqueInput
  }


  /**
   * sentiment_survey deleteMany
   */
  export type sentiment_surveyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sentiment_surveys to delete
     */
    where?: sentiment_surveyWhereInput
  }


  /**
   * sentiment_survey without action
   */
  export type sentiment_surveyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sentiment_survey
     */
    select?: sentiment_surveySelect<ExtArgs> | null
  }



  /**
   * Model comparison_charts_with_17_months_year
   */


  export type AggregateComparison_charts_with_17_months_year = {
    _count: Comparison_charts_with_17_months_yearCountAggregateOutputType | null
    _avg: Comparison_charts_with_17_months_yearAvgAggregateOutputType | null
    _sum: Comparison_charts_with_17_months_yearSumAggregateOutputType | null
    _min: Comparison_charts_with_17_months_yearMinAggregateOutputType | null
    _max: Comparison_charts_with_17_months_yearMaxAggregateOutputType | null
  }

  export type Comparison_charts_with_17_months_yearAvgAggregateOutputType = {
    low_price: Decimal | null
    month_of_low: number | null
    calendar_week_of_low: number | null
    high_price: Decimal | null
    month_of_high: number | null
    calendar_week_of_high: number | null
    range_between_high_low: Decimal | null
    rank_of_price_range: number | null
    percentage_rate_to_low: Decimal | null
    day_range_between_high_low: number | null
    rank_between_high_low: number | null
    us_seasonal_inflation: Decimal | null
    us_inflation_cumm: Decimal | null
    us_interest_rate_mov: Decimal | null
    us_interest_cumm: Decimal | null
    world_population_cumm: number | null
    world_population_mov: number | null
    world_acreage: number | null
    world_acreage_movement: number | null
  }

  export type Comparison_charts_with_17_months_yearSumAggregateOutputType = {
    low_price: Decimal | null
    month_of_low: number | null
    calendar_week_of_low: number | null
    high_price: Decimal | null
    month_of_high: number | null
    calendar_week_of_high: number | null
    range_between_high_low: Decimal | null
    rank_of_price_range: number | null
    percentage_rate_to_low: Decimal | null
    day_range_between_high_low: number | null
    rank_between_high_low: number | null
    us_seasonal_inflation: Decimal | null
    us_inflation_cumm: Decimal | null
    us_interest_rate_mov: Decimal | null
    us_interest_cumm: Decimal | null
    world_population_cumm: number | null
    world_population_mov: number | null
    world_acreage: number | null
    world_acreage_movement: number | null
  }

  export type Comparison_charts_with_17_months_yearMinAggregateOutputType = {
    record_id: string | null
    season: string | null
    low_price: Decimal | null
    date_of_low: Date | null
    month_of_low: number | null
    calendar_week_of_low: number | null
    high_price: Decimal | null
    date_of_high: Date | null
    month_of_high: number | null
    calendar_week_of_high: number | null
    range_between_high_low: Decimal | null
    rank_of_price_range: number | null
    percentage_rate_to_low: Decimal | null
    day_range_between_high_low: number | null
    rank_between_high_low: number | null
    inverse_season: string | null
    us_seasonal_inflation: Decimal | null
    us_inflation_cumm: Decimal | null
    us_interest_rate_mov: Decimal | null
    us_interest_cumm: Decimal | null
    world_population_cumm: number | null
    world_population_mov: number | null
    world_acreage: number | null
    world_acreage_movement: number | null
  }

  export type Comparison_charts_with_17_months_yearMaxAggregateOutputType = {
    record_id: string | null
    season: string | null
    low_price: Decimal | null
    date_of_low: Date | null
    month_of_low: number | null
    calendar_week_of_low: number | null
    high_price: Decimal | null
    date_of_high: Date | null
    month_of_high: number | null
    calendar_week_of_high: number | null
    range_between_high_low: Decimal | null
    rank_of_price_range: number | null
    percentage_rate_to_low: Decimal | null
    day_range_between_high_low: number | null
    rank_between_high_low: number | null
    inverse_season: string | null
    us_seasonal_inflation: Decimal | null
    us_inflation_cumm: Decimal | null
    us_interest_rate_mov: Decimal | null
    us_interest_cumm: Decimal | null
    world_population_cumm: number | null
    world_population_mov: number | null
    world_acreage: number | null
    world_acreage_movement: number | null
  }

  export type Comparison_charts_with_17_months_yearCountAggregateOutputType = {
    record_id: number
    season: number
    low_price: number
    date_of_low: number
    month_of_low: number
    calendar_week_of_low: number
    high_price: number
    date_of_high: number
    month_of_high: number
    calendar_week_of_high: number
    range_between_high_low: number
    rank_of_price_range: number
    percentage_rate_to_low: number
    day_range_between_high_low: number
    rank_between_high_low: number
    inverse_season: number
    us_seasonal_inflation: number
    us_inflation_cumm: number
    us_interest_rate_mov: number
    us_interest_cumm: number
    world_population_cumm: number
    world_population_mov: number
    world_acreage: number
    world_acreage_movement: number
    _all: number
  }


  export type Comparison_charts_with_17_months_yearAvgAggregateInputType = {
    low_price?: true
    month_of_low?: true
    calendar_week_of_low?: true
    high_price?: true
    month_of_high?: true
    calendar_week_of_high?: true
    range_between_high_low?: true
    rank_of_price_range?: true
    percentage_rate_to_low?: true
    day_range_between_high_low?: true
    rank_between_high_low?: true
    us_seasonal_inflation?: true
    us_inflation_cumm?: true
    us_interest_rate_mov?: true
    us_interest_cumm?: true
    world_population_cumm?: true
    world_population_mov?: true
    world_acreage?: true
    world_acreage_movement?: true
  }

  export type Comparison_charts_with_17_months_yearSumAggregateInputType = {
    low_price?: true
    month_of_low?: true
    calendar_week_of_low?: true
    high_price?: true
    month_of_high?: true
    calendar_week_of_high?: true
    range_between_high_low?: true
    rank_of_price_range?: true
    percentage_rate_to_low?: true
    day_range_between_high_low?: true
    rank_between_high_low?: true
    us_seasonal_inflation?: true
    us_inflation_cumm?: true
    us_interest_rate_mov?: true
    us_interest_cumm?: true
    world_population_cumm?: true
    world_population_mov?: true
    world_acreage?: true
    world_acreage_movement?: true
  }

  export type Comparison_charts_with_17_months_yearMinAggregateInputType = {
    record_id?: true
    season?: true
    low_price?: true
    date_of_low?: true
    month_of_low?: true
    calendar_week_of_low?: true
    high_price?: true
    date_of_high?: true
    month_of_high?: true
    calendar_week_of_high?: true
    range_between_high_low?: true
    rank_of_price_range?: true
    percentage_rate_to_low?: true
    day_range_between_high_low?: true
    rank_between_high_low?: true
    inverse_season?: true
    us_seasonal_inflation?: true
    us_inflation_cumm?: true
    us_interest_rate_mov?: true
    us_interest_cumm?: true
    world_population_cumm?: true
    world_population_mov?: true
    world_acreage?: true
    world_acreage_movement?: true
  }

  export type Comparison_charts_with_17_months_yearMaxAggregateInputType = {
    record_id?: true
    season?: true
    low_price?: true
    date_of_low?: true
    month_of_low?: true
    calendar_week_of_low?: true
    high_price?: true
    date_of_high?: true
    month_of_high?: true
    calendar_week_of_high?: true
    range_between_high_low?: true
    rank_of_price_range?: true
    percentage_rate_to_low?: true
    day_range_between_high_low?: true
    rank_between_high_low?: true
    inverse_season?: true
    us_seasonal_inflation?: true
    us_inflation_cumm?: true
    us_interest_rate_mov?: true
    us_interest_cumm?: true
    world_population_cumm?: true
    world_population_mov?: true
    world_acreage?: true
    world_acreage_movement?: true
  }

  export type Comparison_charts_with_17_months_yearCountAggregateInputType = {
    record_id?: true
    season?: true
    low_price?: true
    date_of_low?: true
    month_of_low?: true
    calendar_week_of_low?: true
    high_price?: true
    date_of_high?: true
    month_of_high?: true
    calendar_week_of_high?: true
    range_between_high_low?: true
    rank_of_price_range?: true
    percentage_rate_to_low?: true
    day_range_between_high_low?: true
    rank_between_high_low?: true
    inverse_season?: true
    us_seasonal_inflation?: true
    us_inflation_cumm?: true
    us_interest_rate_mov?: true
    us_interest_cumm?: true
    world_population_cumm?: true
    world_population_mov?: true
    world_acreage?: true
    world_acreage_movement?: true
    _all?: true
  }

  export type Comparison_charts_with_17_months_yearAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which comparison_charts_with_17_months_year to aggregate.
     */
    where?: comparison_charts_with_17_months_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comparison_charts_with_17_months_years to fetch.
     */
    orderBy?: Enumerable<comparison_charts_with_17_months_yearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comparison_charts_with_17_months_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comparison_charts_with_17_months_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comparison_charts_with_17_months_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comparison_charts_with_17_months_years
    **/
    _count?: true | Comparison_charts_with_17_months_yearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Comparison_charts_with_17_months_yearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Comparison_charts_with_17_months_yearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Comparison_charts_with_17_months_yearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Comparison_charts_with_17_months_yearMaxAggregateInputType
  }

  export type GetComparison_charts_with_17_months_yearAggregateType<T extends Comparison_charts_with_17_months_yearAggregateArgs> = {
        [P in keyof T & keyof AggregateComparison_charts_with_17_months_year]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComparison_charts_with_17_months_year[P]>
      : GetScalarType<T[P], AggregateComparison_charts_with_17_months_year[P]>
  }




  export type Comparison_charts_with_17_months_yearGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: comparison_charts_with_17_months_yearWhereInput
    orderBy?: Enumerable<comparison_charts_with_17_months_yearOrderByWithAggregationInput>
    by: Comparison_charts_with_17_months_yearScalarFieldEnum[]
    having?: comparison_charts_with_17_months_yearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Comparison_charts_with_17_months_yearCountAggregateInputType | true
    _avg?: Comparison_charts_with_17_months_yearAvgAggregateInputType
    _sum?: Comparison_charts_with_17_months_yearSumAggregateInputType
    _min?: Comparison_charts_with_17_months_yearMinAggregateInputType
    _max?: Comparison_charts_with_17_months_yearMaxAggregateInputType
  }


  export type Comparison_charts_with_17_months_yearGroupByOutputType = {
    record_id: string
    season: string
    low_price: Decimal | null
    date_of_low: Date
    month_of_low: number
    calendar_week_of_low: number
    high_price: Decimal | null
    date_of_high: Date
    month_of_high: number
    calendar_week_of_high: number
    range_between_high_low: Decimal | null
    rank_of_price_range: number
    percentage_rate_to_low: Decimal | null
    day_range_between_high_low: number
    rank_between_high_low: number
    inverse_season: string
    us_seasonal_inflation: Decimal | null
    us_inflation_cumm: Decimal | null
    us_interest_rate_mov: Decimal | null
    us_interest_cumm: Decimal | null
    world_population_cumm: number
    world_population_mov: number
    world_acreage: number
    world_acreage_movement: number
    _count: Comparison_charts_with_17_months_yearCountAggregateOutputType | null
    _avg: Comparison_charts_with_17_months_yearAvgAggregateOutputType | null
    _sum: Comparison_charts_with_17_months_yearSumAggregateOutputType | null
    _min: Comparison_charts_with_17_months_yearMinAggregateOutputType | null
    _max: Comparison_charts_with_17_months_yearMaxAggregateOutputType | null
  }

  type GetComparison_charts_with_17_months_yearGroupByPayload<T extends Comparison_charts_with_17_months_yearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Comparison_charts_with_17_months_yearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Comparison_charts_with_17_months_yearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Comparison_charts_with_17_months_yearGroupByOutputType[P]>
            : GetScalarType<T[P], Comparison_charts_with_17_months_yearGroupByOutputType[P]>
        }
      >
    >


  export type comparison_charts_with_17_months_yearSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    season?: boolean
    low_price?: boolean
    date_of_low?: boolean
    month_of_low?: boolean
    calendar_week_of_low?: boolean
    high_price?: boolean
    date_of_high?: boolean
    month_of_high?: boolean
    calendar_week_of_high?: boolean
    range_between_high_low?: boolean
    rank_of_price_range?: boolean
    percentage_rate_to_low?: boolean
    day_range_between_high_low?: boolean
    rank_between_high_low?: boolean
    inverse_season?: boolean
    us_seasonal_inflation?: boolean
    us_inflation_cumm?: boolean
    us_interest_rate_mov?: boolean
    us_interest_cumm?: boolean
    world_population_cumm?: boolean
    world_population_mov?: boolean
    world_acreage?: boolean
    world_acreage_movement?: boolean
  }, ExtArgs["result"]["comparison_charts_with_17_months_year"]>

  export type comparison_charts_with_17_months_yearSelectScalar = {
    record_id?: boolean
    season?: boolean
    low_price?: boolean
    date_of_low?: boolean
    month_of_low?: boolean
    calendar_week_of_low?: boolean
    high_price?: boolean
    date_of_high?: boolean
    month_of_high?: boolean
    calendar_week_of_high?: boolean
    range_between_high_low?: boolean
    rank_of_price_range?: boolean
    percentage_rate_to_low?: boolean
    day_range_between_high_low?: boolean
    rank_between_high_low?: boolean
    inverse_season?: boolean
    us_seasonal_inflation?: boolean
    us_inflation_cumm?: boolean
    us_interest_rate_mov?: boolean
    us_interest_cumm?: boolean
    world_population_cumm?: boolean
    world_population_mov?: boolean
    world_acreage?: boolean
    world_acreage_movement?: boolean
  }


  type comparison_charts_with_17_months_yearGetPayload<S extends boolean | null | undefined | comparison_charts_with_17_months_yearArgs> = $Types.GetResult<comparison_charts_with_17_months_yearPayload, S>

  type comparison_charts_with_17_months_yearCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<comparison_charts_with_17_months_yearFindManyArgs, 'select' | 'include'> & {
      select?: Comparison_charts_with_17_months_yearCountAggregateInputType | true
    }

  export interface comparison_charts_with_17_months_yearDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comparison_charts_with_17_months_year'], meta: { name: 'comparison_charts_with_17_months_year' } }
    /**
     * Find zero or one Comparison_charts_with_17_months_year that matches the filter.
     * @param {comparison_charts_with_17_months_yearFindUniqueArgs} args - Arguments to find a Comparison_charts_with_17_months_year
     * @example
     * // Get one Comparison_charts_with_17_months_year
     * const comparison_charts_with_17_months_year = await prisma.comparison_charts_with_17_months_year.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends comparison_charts_with_17_months_yearFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, comparison_charts_with_17_months_yearFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'comparison_charts_with_17_months_year'> extends True ? Prisma__comparison_charts_with_17_months_yearClient<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__comparison_charts_with_17_months_yearClient<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Comparison_charts_with_17_months_year that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {comparison_charts_with_17_months_yearFindUniqueOrThrowArgs} args - Arguments to find a Comparison_charts_with_17_months_year
     * @example
     * // Get one Comparison_charts_with_17_months_year
     * const comparison_charts_with_17_months_year = await prisma.comparison_charts_with_17_months_year.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends comparison_charts_with_17_months_yearFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comparison_charts_with_17_months_yearFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__comparison_charts_with_17_months_yearClient<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Comparison_charts_with_17_months_year that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comparison_charts_with_17_months_yearFindFirstArgs} args - Arguments to find a Comparison_charts_with_17_months_year
     * @example
     * // Get one Comparison_charts_with_17_months_year
     * const comparison_charts_with_17_months_year = await prisma.comparison_charts_with_17_months_year.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends comparison_charts_with_17_months_yearFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, comparison_charts_with_17_months_yearFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'comparison_charts_with_17_months_year'> extends True ? Prisma__comparison_charts_with_17_months_yearClient<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__comparison_charts_with_17_months_yearClient<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Comparison_charts_with_17_months_year that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comparison_charts_with_17_months_yearFindFirstOrThrowArgs} args - Arguments to find a Comparison_charts_with_17_months_year
     * @example
     * // Get one Comparison_charts_with_17_months_year
     * const comparison_charts_with_17_months_year = await prisma.comparison_charts_with_17_months_year.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends comparison_charts_with_17_months_yearFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comparison_charts_with_17_months_yearFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__comparison_charts_with_17_months_yearClient<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Comparison_charts_with_17_months_years that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comparison_charts_with_17_months_yearFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comparison_charts_with_17_months_years
     * const comparison_charts_with_17_months_years = await prisma.comparison_charts_with_17_months_year.findMany()
     * 
     * // Get first 10 Comparison_charts_with_17_months_years
     * const comparison_charts_with_17_months_years = await prisma.comparison_charts_with_17_months_year.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const comparison_charts_with_17_months_yearWithRecord_idOnly = await prisma.comparison_charts_with_17_months_year.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends comparison_charts_with_17_months_yearFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comparison_charts_with_17_months_yearFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Comparison_charts_with_17_months_year.
     * @param {comparison_charts_with_17_months_yearCreateArgs} args - Arguments to create a Comparison_charts_with_17_months_year.
     * @example
     * // Create one Comparison_charts_with_17_months_year
     * const Comparison_charts_with_17_months_year = await prisma.comparison_charts_with_17_months_year.create({
     *   data: {
     *     // ... data to create a Comparison_charts_with_17_months_year
     *   }
     * })
     * 
    **/
    create<T extends comparison_charts_with_17_months_yearCreateArgs<ExtArgs>>(
      args: SelectSubset<T, comparison_charts_with_17_months_yearCreateArgs<ExtArgs>>
    ): Prisma__comparison_charts_with_17_months_yearClient<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Comparison_charts_with_17_months_years.
     *     @param {comparison_charts_with_17_months_yearCreateManyArgs} args - Arguments to create many Comparison_charts_with_17_months_years.
     *     @example
     *     // Create many Comparison_charts_with_17_months_years
     *     const comparison_charts_with_17_months_year = await prisma.comparison_charts_with_17_months_year.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends comparison_charts_with_17_months_yearCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comparison_charts_with_17_months_yearCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comparison_charts_with_17_months_year.
     * @param {comparison_charts_with_17_months_yearDeleteArgs} args - Arguments to delete one Comparison_charts_with_17_months_year.
     * @example
     * // Delete one Comparison_charts_with_17_months_year
     * const Comparison_charts_with_17_months_year = await prisma.comparison_charts_with_17_months_year.delete({
     *   where: {
     *     // ... filter to delete one Comparison_charts_with_17_months_year
     *   }
     * })
     * 
    **/
    delete<T extends comparison_charts_with_17_months_yearDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, comparison_charts_with_17_months_yearDeleteArgs<ExtArgs>>
    ): Prisma__comparison_charts_with_17_months_yearClient<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Comparison_charts_with_17_months_year.
     * @param {comparison_charts_with_17_months_yearUpdateArgs} args - Arguments to update one Comparison_charts_with_17_months_year.
     * @example
     * // Update one Comparison_charts_with_17_months_year
     * const comparison_charts_with_17_months_year = await prisma.comparison_charts_with_17_months_year.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends comparison_charts_with_17_months_yearUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, comparison_charts_with_17_months_yearUpdateArgs<ExtArgs>>
    ): Prisma__comparison_charts_with_17_months_yearClient<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Comparison_charts_with_17_months_years.
     * @param {comparison_charts_with_17_months_yearDeleteManyArgs} args - Arguments to filter Comparison_charts_with_17_months_years to delete.
     * @example
     * // Delete a few Comparison_charts_with_17_months_years
     * const { count } = await prisma.comparison_charts_with_17_months_year.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends comparison_charts_with_17_months_yearDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comparison_charts_with_17_months_yearDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comparison_charts_with_17_months_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comparison_charts_with_17_months_yearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comparison_charts_with_17_months_years
     * const comparison_charts_with_17_months_year = await prisma.comparison_charts_with_17_months_year.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends comparison_charts_with_17_months_yearUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, comparison_charts_with_17_months_yearUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comparison_charts_with_17_months_year.
     * @param {comparison_charts_with_17_months_yearUpsertArgs} args - Arguments to update or create a Comparison_charts_with_17_months_year.
     * @example
     * // Update or create a Comparison_charts_with_17_months_year
     * const comparison_charts_with_17_months_year = await prisma.comparison_charts_with_17_months_year.upsert({
     *   create: {
     *     // ... data to create a Comparison_charts_with_17_months_year
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comparison_charts_with_17_months_year we want to update
     *   }
     * })
    **/
    upsert<T extends comparison_charts_with_17_months_yearUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, comparison_charts_with_17_months_yearUpsertArgs<ExtArgs>>
    ): Prisma__comparison_charts_with_17_months_yearClient<$Types.GetResult<comparison_charts_with_17_months_yearPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Comparison_charts_with_17_months_years.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comparison_charts_with_17_months_yearCountArgs} args - Arguments to filter Comparison_charts_with_17_months_years to count.
     * @example
     * // Count the number of Comparison_charts_with_17_months_years
     * const count = await prisma.comparison_charts_with_17_months_year.count({
     *   where: {
     *     // ... the filter for the Comparison_charts_with_17_months_years we want to count
     *   }
     * })
    **/
    count<T extends comparison_charts_with_17_months_yearCountArgs>(
      args?: Subset<T, comparison_charts_with_17_months_yearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Comparison_charts_with_17_months_yearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comparison_charts_with_17_months_year.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Comparison_charts_with_17_months_yearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Comparison_charts_with_17_months_yearAggregateArgs>(args: Subset<T, Comparison_charts_with_17_months_yearAggregateArgs>): Prisma.PrismaPromise<GetComparison_charts_with_17_months_yearAggregateType<T>>

    /**
     * Group by Comparison_charts_with_17_months_year.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Comparison_charts_with_17_months_yearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Comparison_charts_with_17_months_yearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Comparison_charts_with_17_months_yearGroupByArgs['orderBy'] }
        : { orderBy?: Comparison_charts_with_17_months_yearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Comparison_charts_with_17_months_yearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComparison_charts_with_17_months_yearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for comparison_charts_with_17_months_year.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__comparison_charts_with_17_months_yearClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * comparison_charts_with_17_months_year base type for findUnique actions
   */
  export type comparison_charts_with_17_months_yearFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_charts_with_17_months_year
     */
    select?: comparison_charts_with_17_months_yearSelect<ExtArgs> | null
    /**
     * Filter, which comparison_charts_with_17_months_year to fetch.
     */
    where: comparison_charts_with_17_months_yearWhereUniqueInput
  }

  /**
   * comparison_charts_with_17_months_year findUnique
   */
  export interface comparison_charts_with_17_months_yearFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends comparison_charts_with_17_months_yearFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * comparison_charts_with_17_months_year findUniqueOrThrow
   */
  export type comparison_charts_with_17_months_yearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_charts_with_17_months_year
     */
    select?: comparison_charts_with_17_months_yearSelect<ExtArgs> | null
    /**
     * Filter, which comparison_charts_with_17_months_year to fetch.
     */
    where: comparison_charts_with_17_months_yearWhereUniqueInput
  }


  /**
   * comparison_charts_with_17_months_year base type for findFirst actions
   */
  export type comparison_charts_with_17_months_yearFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_charts_with_17_months_year
     */
    select?: comparison_charts_with_17_months_yearSelect<ExtArgs> | null
    /**
     * Filter, which comparison_charts_with_17_months_year to fetch.
     */
    where?: comparison_charts_with_17_months_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comparison_charts_with_17_months_years to fetch.
     */
    orderBy?: Enumerable<comparison_charts_with_17_months_yearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comparison_charts_with_17_months_years.
     */
    cursor?: comparison_charts_with_17_months_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comparison_charts_with_17_months_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comparison_charts_with_17_months_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comparison_charts_with_17_months_years.
     */
    distinct?: Enumerable<Comparison_charts_with_17_months_yearScalarFieldEnum>
  }

  /**
   * comparison_charts_with_17_months_year findFirst
   */
  export interface comparison_charts_with_17_months_yearFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends comparison_charts_with_17_months_yearFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * comparison_charts_with_17_months_year findFirstOrThrow
   */
  export type comparison_charts_with_17_months_yearFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_charts_with_17_months_year
     */
    select?: comparison_charts_with_17_months_yearSelect<ExtArgs> | null
    /**
     * Filter, which comparison_charts_with_17_months_year to fetch.
     */
    where?: comparison_charts_with_17_months_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comparison_charts_with_17_months_years to fetch.
     */
    orderBy?: Enumerable<comparison_charts_with_17_months_yearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comparison_charts_with_17_months_years.
     */
    cursor?: comparison_charts_with_17_months_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comparison_charts_with_17_months_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comparison_charts_with_17_months_years.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comparison_charts_with_17_months_years.
     */
    distinct?: Enumerable<Comparison_charts_with_17_months_yearScalarFieldEnum>
  }


  /**
   * comparison_charts_with_17_months_year findMany
   */
  export type comparison_charts_with_17_months_yearFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_charts_with_17_months_year
     */
    select?: comparison_charts_with_17_months_yearSelect<ExtArgs> | null
    /**
     * Filter, which comparison_charts_with_17_months_years to fetch.
     */
    where?: comparison_charts_with_17_months_yearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comparison_charts_with_17_months_years to fetch.
     */
    orderBy?: Enumerable<comparison_charts_with_17_months_yearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comparison_charts_with_17_months_years.
     */
    cursor?: comparison_charts_with_17_months_yearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comparison_charts_with_17_months_years from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comparison_charts_with_17_months_years.
     */
    skip?: number
    distinct?: Enumerable<Comparison_charts_with_17_months_yearScalarFieldEnum>
  }


  /**
   * comparison_charts_with_17_months_year create
   */
  export type comparison_charts_with_17_months_yearCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_charts_with_17_months_year
     */
    select?: comparison_charts_with_17_months_yearSelect<ExtArgs> | null
    /**
     * The data needed to create a comparison_charts_with_17_months_year.
     */
    data: XOR<comparison_charts_with_17_months_yearCreateInput, comparison_charts_with_17_months_yearUncheckedCreateInput>
  }


  /**
   * comparison_charts_with_17_months_year createMany
   */
  export type comparison_charts_with_17_months_yearCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comparison_charts_with_17_months_years.
     */
    data: Enumerable<comparison_charts_with_17_months_yearCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * comparison_charts_with_17_months_year update
   */
  export type comparison_charts_with_17_months_yearUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_charts_with_17_months_year
     */
    select?: comparison_charts_with_17_months_yearSelect<ExtArgs> | null
    /**
     * The data needed to update a comparison_charts_with_17_months_year.
     */
    data: XOR<comparison_charts_with_17_months_yearUpdateInput, comparison_charts_with_17_months_yearUncheckedUpdateInput>
    /**
     * Choose, which comparison_charts_with_17_months_year to update.
     */
    where: comparison_charts_with_17_months_yearWhereUniqueInput
  }


  /**
   * comparison_charts_with_17_months_year updateMany
   */
  export type comparison_charts_with_17_months_yearUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comparison_charts_with_17_months_years.
     */
    data: XOR<comparison_charts_with_17_months_yearUpdateManyMutationInput, comparison_charts_with_17_months_yearUncheckedUpdateManyInput>
    /**
     * Filter which comparison_charts_with_17_months_years to update
     */
    where?: comparison_charts_with_17_months_yearWhereInput
  }


  /**
   * comparison_charts_with_17_months_year upsert
   */
  export type comparison_charts_with_17_months_yearUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_charts_with_17_months_year
     */
    select?: comparison_charts_with_17_months_yearSelect<ExtArgs> | null
    /**
     * The filter to search for the comparison_charts_with_17_months_year to update in case it exists.
     */
    where: comparison_charts_with_17_months_yearWhereUniqueInput
    /**
     * In case the comparison_charts_with_17_months_year found by the `where` argument doesn't exist, create a new comparison_charts_with_17_months_year with this data.
     */
    create: XOR<comparison_charts_with_17_months_yearCreateInput, comparison_charts_with_17_months_yearUncheckedCreateInput>
    /**
     * In case the comparison_charts_with_17_months_year was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comparison_charts_with_17_months_yearUpdateInput, comparison_charts_with_17_months_yearUncheckedUpdateInput>
  }


  /**
   * comparison_charts_with_17_months_year delete
   */
  export type comparison_charts_with_17_months_yearDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_charts_with_17_months_year
     */
    select?: comparison_charts_with_17_months_yearSelect<ExtArgs> | null
    /**
     * Filter which comparison_charts_with_17_months_year to delete.
     */
    where: comparison_charts_with_17_months_yearWhereUniqueInput
  }


  /**
   * comparison_charts_with_17_months_year deleteMany
   */
  export type comparison_charts_with_17_months_yearDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which comparison_charts_with_17_months_years to delete
     */
    where?: comparison_charts_with_17_months_yearWhereInput
  }


  /**
   * comparison_charts_with_17_months_year without action
   */
  export type comparison_charts_with_17_months_yearArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comparison_charts_with_17_months_year
     */
    select?: comparison_charts_with_17_months_yearSelect<ExtArgs> | null
  }



  /**
   * Model Temporary_Storage
   */


  export type AggregateTemporary_Storage = {
    _count: Temporary_StorageCountAggregateOutputType | null
    _min: Temporary_StorageMinAggregateOutputType | null
    _max: Temporary_StorageMaxAggregateOutputType | null
  }

  export type Temporary_StorageMinAggregateOutputType = {
    record_id: string | null
    data: string | null
    created_at: Date | null
  }

  export type Temporary_StorageMaxAggregateOutputType = {
    record_id: string | null
    data: string | null
    created_at: Date | null
  }

  export type Temporary_StorageCountAggregateOutputType = {
    record_id: number
    data: number
    created_at: number
    _all: number
  }


  export type Temporary_StorageMinAggregateInputType = {
    record_id?: true
    data?: true
    created_at?: true
  }

  export type Temporary_StorageMaxAggregateInputType = {
    record_id?: true
    data?: true
    created_at?: true
  }

  export type Temporary_StorageCountAggregateInputType = {
    record_id?: true
    data?: true
    created_at?: true
    _all?: true
  }

  export type Temporary_StorageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Temporary_Storage to aggregate.
     */
    where?: Temporary_StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temporary_Storages to fetch.
     */
    orderBy?: Enumerable<Temporary_StorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Temporary_StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temporary_Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temporary_Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Temporary_Storages
    **/
    _count?: true | Temporary_StorageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Temporary_StorageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Temporary_StorageMaxAggregateInputType
  }

  export type GetTemporary_StorageAggregateType<T extends Temporary_StorageAggregateArgs> = {
        [P in keyof T & keyof AggregateTemporary_Storage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemporary_Storage[P]>
      : GetScalarType<T[P], AggregateTemporary_Storage[P]>
  }




  export type Temporary_StorageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Temporary_StorageWhereInput
    orderBy?: Enumerable<Temporary_StorageOrderByWithAggregationInput>
    by: Temporary_StorageScalarFieldEnum[]
    having?: Temporary_StorageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Temporary_StorageCountAggregateInputType | true
    _min?: Temporary_StorageMinAggregateInputType
    _max?: Temporary_StorageMaxAggregateInputType
  }


  export type Temporary_StorageGroupByOutputType = {
    record_id: string
    data: string
    created_at: Date
    _count: Temporary_StorageCountAggregateOutputType | null
    _min: Temporary_StorageMinAggregateOutputType | null
    _max: Temporary_StorageMaxAggregateOutputType | null
  }

  type GetTemporary_StorageGroupByPayload<T extends Temporary_StorageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Temporary_StorageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Temporary_StorageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Temporary_StorageGroupByOutputType[P]>
            : GetScalarType<T[P], Temporary_StorageGroupByOutputType[P]>
        }
      >
    >


  export type Temporary_StorageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    data?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["temporary_Storage"]>

  export type Temporary_StorageSelectScalar = {
    record_id?: boolean
    data?: boolean
    created_at?: boolean
  }


  type Temporary_StorageGetPayload<S extends boolean | null | undefined | Temporary_StorageArgs> = $Types.GetResult<Temporary_StoragePayload, S>

  type Temporary_StorageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<Temporary_StorageFindManyArgs, 'select' | 'include'> & {
      select?: Temporary_StorageCountAggregateInputType | true
    }

  export interface Temporary_StorageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Temporary_Storage'], meta: { name: 'Temporary_Storage' } }
    /**
     * Find zero or one Temporary_Storage that matches the filter.
     * @param {Temporary_StorageFindUniqueArgs} args - Arguments to find a Temporary_Storage
     * @example
     * // Get one Temporary_Storage
     * const temporary_Storage = await prisma.temporary_Storage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Temporary_StorageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Temporary_StorageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Temporary_Storage'> extends True ? Prisma__Temporary_StorageClient<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__Temporary_StorageClient<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Temporary_Storage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Temporary_StorageFindUniqueOrThrowArgs} args - Arguments to find a Temporary_Storage
     * @example
     * // Get one Temporary_Storage
     * const temporary_Storage = await prisma.temporary_Storage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Temporary_StorageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Temporary_StorageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Temporary_StorageClient<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Temporary_Storage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Temporary_StorageFindFirstArgs} args - Arguments to find a Temporary_Storage
     * @example
     * // Get one Temporary_Storage
     * const temporary_Storage = await prisma.temporary_Storage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Temporary_StorageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Temporary_StorageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Temporary_Storage'> extends True ? Prisma__Temporary_StorageClient<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__Temporary_StorageClient<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Temporary_Storage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Temporary_StorageFindFirstOrThrowArgs} args - Arguments to find a Temporary_Storage
     * @example
     * // Get one Temporary_Storage
     * const temporary_Storage = await prisma.temporary_Storage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Temporary_StorageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Temporary_StorageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Temporary_StorageClient<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Temporary_Storages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Temporary_StorageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Temporary_Storages
     * const temporary_Storages = await prisma.temporary_Storage.findMany()
     * 
     * // Get first 10 Temporary_Storages
     * const temporary_Storages = await prisma.temporary_Storage.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const temporary_StorageWithRecord_idOnly = await prisma.temporary_Storage.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends Temporary_StorageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Temporary_StorageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Temporary_Storage.
     * @param {Temporary_StorageCreateArgs} args - Arguments to create a Temporary_Storage.
     * @example
     * // Create one Temporary_Storage
     * const Temporary_Storage = await prisma.temporary_Storage.create({
     *   data: {
     *     // ... data to create a Temporary_Storage
     *   }
     * })
     * 
    **/
    create<T extends Temporary_StorageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Temporary_StorageCreateArgs<ExtArgs>>
    ): Prisma__Temporary_StorageClient<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Temporary_Storages.
     *     @param {Temporary_StorageCreateManyArgs} args - Arguments to create many Temporary_Storages.
     *     @example
     *     // Create many Temporary_Storages
     *     const temporary_Storage = await prisma.temporary_Storage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Temporary_StorageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Temporary_StorageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Temporary_Storage.
     * @param {Temporary_StorageDeleteArgs} args - Arguments to delete one Temporary_Storage.
     * @example
     * // Delete one Temporary_Storage
     * const Temporary_Storage = await prisma.temporary_Storage.delete({
     *   where: {
     *     // ... filter to delete one Temporary_Storage
     *   }
     * })
     * 
    **/
    delete<T extends Temporary_StorageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Temporary_StorageDeleteArgs<ExtArgs>>
    ): Prisma__Temporary_StorageClient<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Temporary_Storage.
     * @param {Temporary_StorageUpdateArgs} args - Arguments to update one Temporary_Storage.
     * @example
     * // Update one Temporary_Storage
     * const temporary_Storage = await prisma.temporary_Storage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Temporary_StorageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Temporary_StorageUpdateArgs<ExtArgs>>
    ): Prisma__Temporary_StorageClient<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Temporary_Storages.
     * @param {Temporary_StorageDeleteManyArgs} args - Arguments to filter Temporary_Storages to delete.
     * @example
     * // Delete a few Temporary_Storages
     * const { count } = await prisma.temporary_Storage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Temporary_StorageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Temporary_StorageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Temporary_Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Temporary_StorageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Temporary_Storages
     * const temporary_Storage = await prisma.temporary_Storage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Temporary_StorageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Temporary_StorageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Temporary_Storage.
     * @param {Temporary_StorageUpsertArgs} args - Arguments to update or create a Temporary_Storage.
     * @example
     * // Update or create a Temporary_Storage
     * const temporary_Storage = await prisma.temporary_Storage.upsert({
     *   create: {
     *     // ... data to create a Temporary_Storage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Temporary_Storage we want to update
     *   }
     * })
    **/
    upsert<T extends Temporary_StorageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Temporary_StorageUpsertArgs<ExtArgs>>
    ): Prisma__Temporary_StorageClient<$Types.GetResult<Temporary_StoragePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Temporary_Storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Temporary_StorageCountArgs} args - Arguments to filter Temporary_Storages to count.
     * @example
     * // Count the number of Temporary_Storages
     * const count = await prisma.temporary_Storage.count({
     *   where: {
     *     // ... the filter for the Temporary_Storages we want to count
     *   }
     * })
    **/
    count<T extends Temporary_StorageCountArgs>(
      args?: Subset<T, Temporary_StorageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Temporary_StorageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Temporary_Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Temporary_StorageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Temporary_StorageAggregateArgs>(args: Subset<T, Temporary_StorageAggregateArgs>): Prisma.PrismaPromise<GetTemporary_StorageAggregateType<T>>

    /**
     * Group by Temporary_Storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Temporary_StorageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Temporary_StorageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Temporary_StorageGroupByArgs['orderBy'] }
        : { orderBy?: Temporary_StorageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Temporary_StorageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemporary_StorageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Temporary_Storage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Temporary_StorageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Temporary_Storage base type for findUnique actions
   */
  export type Temporary_StorageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temporary_Storage
     */
    select?: Temporary_StorageSelect<ExtArgs> | null
    /**
     * Filter, which Temporary_Storage to fetch.
     */
    where: Temporary_StorageWhereUniqueInput
  }

  /**
   * Temporary_Storage findUnique
   */
  export interface Temporary_StorageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Temporary_StorageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Temporary_Storage findUniqueOrThrow
   */
  export type Temporary_StorageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temporary_Storage
     */
    select?: Temporary_StorageSelect<ExtArgs> | null
    /**
     * Filter, which Temporary_Storage to fetch.
     */
    where: Temporary_StorageWhereUniqueInput
  }


  /**
   * Temporary_Storage base type for findFirst actions
   */
  export type Temporary_StorageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temporary_Storage
     */
    select?: Temporary_StorageSelect<ExtArgs> | null
    /**
     * Filter, which Temporary_Storage to fetch.
     */
    where?: Temporary_StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temporary_Storages to fetch.
     */
    orderBy?: Enumerable<Temporary_StorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Temporary_Storages.
     */
    cursor?: Temporary_StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temporary_Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temporary_Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Temporary_Storages.
     */
    distinct?: Enumerable<Temporary_StorageScalarFieldEnum>
  }

  /**
   * Temporary_Storage findFirst
   */
  export interface Temporary_StorageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Temporary_StorageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Temporary_Storage findFirstOrThrow
   */
  export type Temporary_StorageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temporary_Storage
     */
    select?: Temporary_StorageSelect<ExtArgs> | null
    /**
     * Filter, which Temporary_Storage to fetch.
     */
    where?: Temporary_StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temporary_Storages to fetch.
     */
    orderBy?: Enumerable<Temporary_StorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Temporary_Storages.
     */
    cursor?: Temporary_StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temporary_Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temporary_Storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Temporary_Storages.
     */
    distinct?: Enumerable<Temporary_StorageScalarFieldEnum>
  }


  /**
   * Temporary_Storage findMany
   */
  export type Temporary_StorageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temporary_Storage
     */
    select?: Temporary_StorageSelect<ExtArgs> | null
    /**
     * Filter, which Temporary_Storages to fetch.
     */
    where?: Temporary_StorageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temporary_Storages to fetch.
     */
    orderBy?: Enumerable<Temporary_StorageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Temporary_Storages.
     */
    cursor?: Temporary_StorageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temporary_Storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temporary_Storages.
     */
    skip?: number
    distinct?: Enumerable<Temporary_StorageScalarFieldEnum>
  }


  /**
   * Temporary_Storage create
   */
  export type Temporary_StorageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temporary_Storage
     */
    select?: Temporary_StorageSelect<ExtArgs> | null
    /**
     * The data needed to create a Temporary_Storage.
     */
    data: XOR<Temporary_StorageCreateInput, Temporary_StorageUncheckedCreateInput>
  }


  /**
   * Temporary_Storage createMany
   */
  export type Temporary_StorageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Temporary_Storages.
     */
    data: Enumerable<Temporary_StorageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Temporary_Storage update
   */
  export type Temporary_StorageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temporary_Storage
     */
    select?: Temporary_StorageSelect<ExtArgs> | null
    /**
     * The data needed to update a Temporary_Storage.
     */
    data: XOR<Temporary_StorageUpdateInput, Temporary_StorageUncheckedUpdateInput>
    /**
     * Choose, which Temporary_Storage to update.
     */
    where: Temporary_StorageWhereUniqueInput
  }


  /**
   * Temporary_Storage updateMany
   */
  export type Temporary_StorageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Temporary_Storages.
     */
    data: XOR<Temporary_StorageUpdateManyMutationInput, Temporary_StorageUncheckedUpdateManyInput>
    /**
     * Filter which Temporary_Storages to update
     */
    where?: Temporary_StorageWhereInput
  }


  /**
   * Temporary_Storage upsert
   */
  export type Temporary_StorageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temporary_Storage
     */
    select?: Temporary_StorageSelect<ExtArgs> | null
    /**
     * The filter to search for the Temporary_Storage to update in case it exists.
     */
    where: Temporary_StorageWhereUniqueInput
    /**
     * In case the Temporary_Storage found by the `where` argument doesn't exist, create a new Temporary_Storage with this data.
     */
    create: XOR<Temporary_StorageCreateInput, Temporary_StorageUncheckedCreateInput>
    /**
     * In case the Temporary_Storage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Temporary_StorageUpdateInput, Temporary_StorageUncheckedUpdateInput>
  }


  /**
   * Temporary_Storage delete
   */
  export type Temporary_StorageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temporary_Storage
     */
    select?: Temporary_StorageSelect<ExtArgs> | null
    /**
     * Filter which Temporary_Storage to delete.
     */
    where: Temporary_StorageWhereUniqueInput
  }


  /**
   * Temporary_Storage deleteMany
   */
  export type Temporary_StorageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Temporary_Storages to delete
     */
    where?: Temporary_StorageWhereInput
  }


  /**
   * Temporary_Storage without action
   */
  export type Temporary_StorageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temporary_Storage
     */
    select?: Temporary_StorageSelect<ExtArgs> | null
  }



  /**
   * Model Report_Templates
   */


  export type AggregateReport_Templates = {
    _count: Report_TemplatesCountAggregateOutputType | null
    _min: Report_TemplatesMinAggregateOutputType | null
    _max: Report_TemplatesMaxAggregateOutputType | null
  }

  export type Report_TemplatesMinAggregateOutputType = {
    record_id: string | null
    name: string | null
    data: string | null
    company: string | null
    created_at: Date | null
  }

  export type Report_TemplatesMaxAggregateOutputType = {
    record_id: string | null
    name: string | null
    data: string | null
    company: string | null
    created_at: Date | null
  }

  export type Report_TemplatesCountAggregateOutputType = {
    record_id: number
    name: number
    data: number
    company: number
    created_at: number
    _all: number
  }


  export type Report_TemplatesMinAggregateInputType = {
    record_id?: true
    name?: true
    data?: true
    company?: true
    created_at?: true
  }

  export type Report_TemplatesMaxAggregateInputType = {
    record_id?: true
    name?: true
    data?: true
    company?: true
    created_at?: true
  }

  export type Report_TemplatesCountAggregateInputType = {
    record_id?: true
    name?: true
    data?: true
    company?: true
    created_at?: true
    _all?: true
  }

  export type Report_TemplatesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report_Templates to aggregate.
     */
    where?: Report_TemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Report_Templates to fetch.
     */
    orderBy?: Enumerable<Report_TemplatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Report_TemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Report_Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Report_Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Report_Templates
    **/
    _count?: true | Report_TemplatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Report_TemplatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Report_TemplatesMaxAggregateInputType
  }

  export type GetReport_TemplatesAggregateType<T extends Report_TemplatesAggregateArgs> = {
        [P in keyof T & keyof AggregateReport_Templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport_Templates[P]>
      : GetScalarType<T[P], AggregateReport_Templates[P]>
  }




  export type Report_TemplatesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Report_TemplatesWhereInput
    orderBy?: Enumerable<Report_TemplatesOrderByWithAggregationInput>
    by: Report_TemplatesScalarFieldEnum[]
    having?: Report_TemplatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Report_TemplatesCountAggregateInputType | true
    _min?: Report_TemplatesMinAggregateInputType
    _max?: Report_TemplatesMaxAggregateInputType
  }


  export type Report_TemplatesGroupByOutputType = {
    record_id: string
    name: string
    data: string
    company: string
    created_at: Date
    _count: Report_TemplatesCountAggregateOutputType | null
    _min: Report_TemplatesMinAggregateOutputType | null
    _max: Report_TemplatesMaxAggregateOutputType | null
  }

  type GetReport_TemplatesGroupByPayload<T extends Report_TemplatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Report_TemplatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Report_TemplatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Report_TemplatesGroupByOutputType[P]>
            : GetScalarType<T[P], Report_TemplatesGroupByOutputType[P]>
        }
      >
    >


  export type Report_TemplatesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    name?: boolean
    data?: boolean
    company?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["report_Templates"]>

  export type Report_TemplatesSelectScalar = {
    record_id?: boolean
    name?: boolean
    data?: boolean
    company?: boolean
    created_at?: boolean
  }


  type Report_TemplatesGetPayload<S extends boolean | null | undefined | Report_TemplatesArgs> = $Types.GetResult<Report_TemplatesPayload, S>

  type Report_TemplatesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<Report_TemplatesFindManyArgs, 'select' | 'include'> & {
      select?: Report_TemplatesCountAggregateInputType | true
    }

  export interface Report_TemplatesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report_Templates'], meta: { name: 'Report_Templates' } }
    /**
     * Find zero or one Report_Templates that matches the filter.
     * @param {Report_TemplatesFindUniqueArgs} args - Arguments to find a Report_Templates
     * @example
     * // Get one Report_Templates
     * const report_Templates = await prisma.report_Templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Report_TemplatesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Report_TemplatesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Report_Templates'> extends True ? Prisma__Report_TemplatesClient<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__Report_TemplatesClient<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Report_Templates that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Report_TemplatesFindUniqueOrThrowArgs} args - Arguments to find a Report_Templates
     * @example
     * // Get one Report_Templates
     * const report_Templates = await prisma.report_Templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Report_TemplatesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Report_TemplatesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Report_TemplatesClient<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Report_Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_TemplatesFindFirstArgs} args - Arguments to find a Report_Templates
     * @example
     * // Get one Report_Templates
     * const report_Templates = await prisma.report_Templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Report_TemplatesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Report_TemplatesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Report_Templates'> extends True ? Prisma__Report_TemplatesClient<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__Report_TemplatesClient<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Report_Templates that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_TemplatesFindFirstOrThrowArgs} args - Arguments to find a Report_Templates
     * @example
     * // Get one Report_Templates
     * const report_Templates = await prisma.report_Templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Report_TemplatesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Report_TemplatesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Report_TemplatesClient<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Report_Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_TemplatesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Report_Templates
     * const report_Templates = await prisma.report_Templates.findMany()
     * 
     * // Get first 10 Report_Templates
     * const report_Templates = await prisma.report_Templates.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const report_TemplatesWithRecord_idOnly = await prisma.report_Templates.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends Report_TemplatesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Report_TemplatesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Report_Templates.
     * @param {Report_TemplatesCreateArgs} args - Arguments to create a Report_Templates.
     * @example
     * // Create one Report_Templates
     * const Report_Templates = await prisma.report_Templates.create({
     *   data: {
     *     // ... data to create a Report_Templates
     *   }
     * })
     * 
    **/
    create<T extends Report_TemplatesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Report_TemplatesCreateArgs<ExtArgs>>
    ): Prisma__Report_TemplatesClient<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Report_Templates.
     *     @param {Report_TemplatesCreateManyArgs} args - Arguments to create many Report_Templates.
     *     @example
     *     // Create many Report_Templates
     *     const report_Templates = await prisma.report_Templates.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Report_TemplatesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Report_TemplatesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report_Templates.
     * @param {Report_TemplatesDeleteArgs} args - Arguments to delete one Report_Templates.
     * @example
     * // Delete one Report_Templates
     * const Report_Templates = await prisma.report_Templates.delete({
     *   where: {
     *     // ... filter to delete one Report_Templates
     *   }
     * })
     * 
    **/
    delete<T extends Report_TemplatesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Report_TemplatesDeleteArgs<ExtArgs>>
    ): Prisma__Report_TemplatesClient<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Report_Templates.
     * @param {Report_TemplatesUpdateArgs} args - Arguments to update one Report_Templates.
     * @example
     * // Update one Report_Templates
     * const report_Templates = await prisma.report_Templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Report_TemplatesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Report_TemplatesUpdateArgs<ExtArgs>>
    ): Prisma__Report_TemplatesClient<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Report_Templates.
     * @param {Report_TemplatesDeleteManyArgs} args - Arguments to filter Report_Templates to delete.
     * @example
     * // Delete a few Report_Templates
     * const { count } = await prisma.report_Templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Report_TemplatesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Report_TemplatesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Report_Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_TemplatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Report_Templates
     * const report_Templates = await prisma.report_Templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Report_TemplatesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Report_TemplatesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report_Templates.
     * @param {Report_TemplatesUpsertArgs} args - Arguments to update or create a Report_Templates.
     * @example
     * // Update or create a Report_Templates
     * const report_Templates = await prisma.report_Templates.upsert({
     *   create: {
     *     // ... data to create a Report_Templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report_Templates we want to update
     *   }
     * })
    **/
    upsert<T extends Report_TemplatesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Report_TemplatesUpsertArgs<ExtArgs>>
    ): Prisma__Report_TemplatesClient<$Types.GetResult<Report_TemplatesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Report_Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_TemplatesCountArgs} args - Arguments to filter Report_Templates to count.
     * @example
     * // Count the number of Report_Templates
     * const count = await prisma.report_Templates.count({
     *   where: {
     *     // ... the filter for the Report_Templates we want to count
     *   }
     * })
    **/
    count<T extends Report_TemplatesCountArgs>(
      args?: Subset<T, Report_TemplatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Report_TemplatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report_Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_TemplatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Report_TemplatesAggregateArgs>(args: Subset<T, Report_TemplatesAggregateArgs>): Prisma.PrismaPromise<GetReport_TemplatesAggregateType<T>>

    /**
     * Group by Report_Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_TemplatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Report_TemplatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Report_TemplatesGroupByArgs['orderBy'] }
        : { orderBy?: Report_TemplatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Report_TemplatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReport_TemplatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Report_Templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Report_TemplatesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Report_Templates base type for findUnique actions
   */
  export type Report_TemplatesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report_Templates
     */
    select?: Report_TemplatesSelect<ExtArgs> | null
    /**
     * Filter, which Report_Templates to fetch.
     */
    where: Report_TemplatesWhereUniqueInput
  }

  /**
   * Report_Templates findUnique
   */
  export interface Report_TemplatesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Report_TemplatesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Report_Templates findUniqueOrThrow
   */
  export type Report_TemplatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report_Templates
     */
    select?: Report_TemplatesSelect<ExtArgs> | null
    /**
     * Filter, which Report_Templates to fetch.
     */
    where: Report_TemplatesWhereUniqueInput
  }


  /**
   * Report_Templates base type for findFirst actions
   */
  export type Report_TemplatesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report_Templates
     */
    select?: Report_TemplatesSelect<ExtArgs> | null
    /**
     * Filter, which Report_Templates to fetch.
     */
    where?: Report_TemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Report_Templates to fetch.
     */
    orderBy?: Enumerable<Report_TemplatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Report_Templates.
     */
    cursor?: Report_TemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Report_Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Report_Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Report_Templates.
     */
    distinct?: Enumerable<Report_TemplatesScalarFieldEnum>
  }

  /**
   * Report_Templates findFirst
   */
  export interface Report_TemplatesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Report_TemplatesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Report_Templates findFirstOrThrow
   */
  export type Report_TemplatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report_Templates
     */
    select?: Report_TemplatesSelect<ExtArgs> | null
    /**
     * Filter, which Report_Templates to fetch.
     */
    where?: Report_TemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Report_Templates to fetch.
     */
    orderBy?: Enumerable<Report_TemplatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Report_Templates.
     */
    cursor?: Report_TemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Report_Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Report_Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Report_Templates.
     */
    distinct?: Enumerable<Report_TemplatesScalarFieldEnum>
  }


  /**
   * Report_Templates findMany
   */
  export type Report_TemplatesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report_Templates
     */
    select?: Report_TemplatesSelect<ExtArgs> | null
    /**
     * Filter, which Report_Templates to fetch.
     */
    where?: Report_TemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Report_Templates to fetch.
     */
    orderBy?: Enumerable<Report_TemplatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Report_Templates.
     */
    cursor?: Report_TemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Report_Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Report_Templates.
     */
    skip?: number
    distinct?: Enumerable<Report_TemplatesScalarFieldEnum>
  }


  /**
   * Report_Templates create
   */
  export type Report_TemplatesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report_Templates
     */
    select?: Report_TemplatesSelect<ExtArgs> | null
    /**
     * The data needed to create a Report_Templates.
     */
    data: XOR<Report_TemplatesCreateInput, Report_TemplatesUncheckedCreateInput>
  }


  /**
   * Report_Templates createMany
   */
  export type Report_TemplatesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Report_Templates.
     */
    data: Enumerable<Report_TemplatesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Report_Templates update
   */
  export type Report_TemplatesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report_Templates
     */
    select?: Report_TemplatesSelect<ExtArgs> | null
    /**
     * The data needed to update a Report_Templates.
     */
    data: XOR<Report_TemplatesUpdateInput, Report_TemplatesUncheckedUpdateInput>
    /**
     * Choose, which Report_Templates to update.
     */
    where: Report_TemplatesWhereUniqueInput
  }


  /**
   * Report_Templates updateMany
   */
  export type Report_TemplatesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Report_Templates.
     */
    data: XOR<Report_TemplatesUpdateManyMutationInput, Report_TemplatesUncheckedUpdateManyInput>
    /**
     * Filter which Report_Templates to update
     */
    where?: Report_TemplatesWhereInput
  }


  /**
   * Report_Templates upsert
   */
  export type Report_TemplatesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report_Templates
     */
    select?: Report_TemplatesSelect<ExtArgs> | null
    /**
     * The filter to search for the Report_Templates to update in case it exists.
     */
    where: Report_TemplatesWhereUniqueInput
    /**
     * In case the Report_Templates found by the `where` argument doesn't exist, create a new Report_Templates with this data.
     */
    create: XOR<Report_TemplatesCreateInput, Report_TemplatesUncheckedCreateInput>
    /**
     * In case the Report_Templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Report_TemplatesUpdateInput, Report_TemplatesUncheckedUpdateInput>
  }


  /**
   * Report_Templates delete
   */
  export type Report_TemplatesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report_Templates
     */
    select?: Report_TemplatesSelect<ExtArgs> | null
    /**
     * Filter which Report_Templates to delete.
     */
    where: Report_TemplatesWhereUniqueInput
  }


  /**
   * Report_Templates deleteMany
   */
  export type Report_TemplatesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report_Templates to delete
     */
    where?: Report_TemplatesWhereInput
  }


  /**
   * Report_Templates without action
   */
  export type Report_TemplatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report_Templates
     */
    select?: Report_TemplatesSelect<ExtArgs> | null
  }



  /**
   * Model Dashboard_Templates
   */


  export type AggregateDashboard_Templates = {
    _count: Dashboard_TemplatesCountAggregateOutputType | null
    _min: Dashboard_TemplatesMinAggregateOutputType | null
    _max: Dashboard_TemplatesMaxAggregateOutputType | null
  }

  export type Dashboard_TemplatesMinAggregateOutputType = {
    record_id: string | null
    data: string | null
    company: string | null
    created_at: Date | null
  }

  export type Dashboard_TemplatesMaxAggregateOutputType = {
    record_id: string | null
    data: string | null
    company: string | null
    created_at: Date | null
  }

  export type Dashboard_TemplatesCountAggregateOutputType = {
    record_id: number
    data: number
    company: number
    created_at: number
    _all: number
  }


  export type Dashboard_TemplatesMinAggregateInputType = {
    record_id?: true
    data?: true
    company?: true
    created_at?: true
  }

  export type Dashboard_TemplatesMaxAggregateInputType = {
    record_id?: true
    data?: true
    company?: true
    created_at?: true
  }

  export type Dashboard_TemplatesCountAggregateInputType = {
    record_id?: true
    data?: true
    company?: true
    created_at?: true
    _all?: true
  }

  export type Dashboard_TemplatesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dashboard_Templates to aggregate.
     */
    where?: Dashboard_TemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboard_Templates to fetch.
     */
    orderBy?: Enumerable<Dashboard_TemplatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Dashboard_TemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboard_Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboard_Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dashboard_Templates
    **/
    _count?: true | Dashboard_TemplatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dashboard_TemplatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dashboard_TemplatesMaxAggregateInputType
  }

  export type GetDashboard_TemplatesAggregateType<T extends Dashboard_TemplatesAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboard_Templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboard_Templates[P]>
      : GetScalarType<T[P], AggregateDashboard_Templates[P]>
  }




  export type Dashboard_TemplatesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Dashboard_TemplatesWhereInput
    orderBy?: Enumerable<Dashboard_TemplatesOrderByWithAggregationInput>
    by: Dashboard_TemplatesScalarFieldEnum[]
    having?: Dashboard_TemplatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dashboard_TemplatesCountAggregateInputType | true
    _min?: Dashboard_TemplatesMinAggregateInputType
    _max?: Dashboard_TemplatesMaxAggregateInputType
  }


  export type Dashboard_TemplatesGroupByOutputType = {
    record_id: string
    data: string
    company: string
    created_at: Date
    _count: Dashboard_TemplatesCountAggregateOutputType | null
    _min: Dashboard_TemplatesMinAggregateOutputType | null
    _max: Dashboard_TemplatesMaxAggregateOutputType | null
  }

  type GetDashboard_TemplatesGroupByPayload<T extends Dashboard_TemplatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Dashboard_TemplatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dashboard_TemplatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dashboard_TemplatesGroupByOutputType[P]>
            : GetScalarType<T[P], Dashboard_TemplatesGroupByOutputType[P]>
        }
      >
    >


  export type Dashboard_TemplatesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    record_id?: boolean
    data?: boolean
    company?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["dashboard_Templates"]>

  export type Dashboard_TemplatesSelectScalar = {
    record_id?: boolean
    data?: boolean
    company?: boolean
    created_at?: boolean
  }


  type Dashboard_TemplatesGetPayload<S extends boolean | null | undefined | Dashboard_TemplatesArgs> = $Types.GetResult<Dashboard_TemplatesPayload, S>

  type Dashboard_TemplatesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<Dashboard_TemplatesFindManyArgs, 'select' | 'include'> & {
      select?: Dashboard_TemplatesCountAggregateInputType | true
    }

  export interface Dashboard_TemplatesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dashboard_Templates'], meta: { name: 'Dashboard_Templates' } }
    /**
     * Find zero or one Dashboard_Templates that matches the filter.
     * @param {Dashboard_TemplatesFindUniqueArgs} args - Arguments to find a Dashboard_Templates
     * @example
     * // Get one Dashboard_Templates
     * const dashboard_Templates = await prisma.dashboard_Templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Dashboard_TemplatesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Dashboard_TemplatesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Dashboard_Templates'> extends True ? Prisma__Dashboard_TemplatesClient<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__Dashboard_TemplatesClient<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Dashboard_Templates that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Dashboard_TemplatesFindUniqueOrThrowArgs} args - Arguments to find a Dashboard_Templates
     * @example
     * // Get one Dashboard_Templates
     * const dashboard_Templates = await prisma.dashboard_Templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Dashboard_TemplatesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Dashboard_TemplatesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Dashboard_TemplatesClient<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Dashboard_Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dashboard_TemplatesFindFirstArgs} args - Arguments to find a Dashboard_Templates
     * @example
     * // Get one Dashboard_Templates
     * const dashboard_Templates = await prisma.dashboard_Templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Dashboard_TemplatesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Dashboard_TemplatesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Dashboard_Templates'> extends True ? Prisma__Dashboard_TemplatesClient<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__Dashboard_TemplatesClient<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Dashboard_Templates that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dashboard_TemplatesFindFirstOrThrowArgs} args - Arguments to find a Dashboard_Templates
     * @example
     * // Get one Dashboard_Templates
     * const dashboard_Templates = await prisma.dashboard_Templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Dashboard_TemplatesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Dashboard_TemplatesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Dashboard_TemplatesClient<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Dashboard_Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dashboard_TemplatesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dashboard_Templates
     * const dashboard_Templates = await prisma.dashboard_Templates.findMany()
     * 
     * // Get first 10 Dashboard_Templates
     * const dashboard_Templates = await prisma.dashboard_Templates.findMany({ take: 10 })
     * 
     * // Only select the `record_id`
     * const dashboard_TemplatesWithRecord_idOnly = await prisma.dashboard_Templates.findMany({ select: { record_id: true } })
     * 
    **/
    findMany<T extends Dashboard_TemplatesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Dashboard_TemplatesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Dashboard_Templates.
     * @param {Dashboard_TemplatesCreateArgs} args - Arguments to create a Dashboard_Templates.
     * @example
     * // Create one Dashboard_Templates
     * const Dashboard_Templates = await prisma.dashboard_Templates.create({
     *   data: {
     *     // ... data to create a Dashboard_Templates
     *   }
     * })
     * 
    **/
    create<T extends Dashboard_TemplatesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Dashboard_TemplatesCreateArgs<ExtArgs>>
    ): Prisma__Dashboard_TemplatesClient<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Dashboard_Templates.
     *     @param {Dashboard_TemplatesCreateManyArgs} args - Arguments to create many Dashboard_Templates.
     *     @example
     *     // Create many Dashboard_Templates
     *     const dashboard_Templates = await prisma.dashboard_Templates.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Dashboard_TemplatesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Dashboard_TemplatesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dashboard_Templates.
     * @param {Dashboard_TemplatesDeleteArgs} args - Arguments to delete one Dashboard_Templates.
     * @example
     * // Delete one Dashboard_Templates
     * const Dashboard_Templates = await prisma.dashboard_Templates.delete({
     *   where: {
     *     // ... filter to delete one Dashboard_Templates
     *   }
     * })
     * 
    **/
    delete<T extends Dashboard_TemplatesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Dashboard_TemplatesDeleteArgs<ExtArgs>>
    ): Prisma__Dashboard_TemplatesClient<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Dashboard_Templates.
     * @param {Dashboard_TemplatesUpdateArgs} args - Arguments to update one Dashboard_Templates.
     * @example
     * // Update one Dashboard_Templates
     * const dashboard_Templates = await prisma.dashboard_Templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Dashboard_TemplatesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Dashboard_TemplatesUpdateArgs<ExtArgs>>
    ): Prisma__Dashboard_TemplatesClient<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Dashboard_Templates.
     * @param {Dashboard_TemplatesDeleteManyArgs} args - Arguments to filter Dashboard_Templates to delete.
     * @example
     * // Delete a few Dashboard_Templates
     * const { count } = await prisma.dashboard_Templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Dashboard_TemplatesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Dashboard_TemplatesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dashboard_Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dashboard_TemplatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dashboard_Templates
     * const dashboard_Templates = await prisma.dashboard_Templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Dashboard_TemplatesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Dashboard_TemplatesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dashboard_Templates.
     * @param {Dashboard_TemplatesUpsertArgs} args - Arguments to update or create a Dashboard_Templates.
     * @example
     * // Update or create a Dashboard_Templates
     * const dashboard_Templates = await prisma.dashboard_Templates.upsert({
     *   create: {
     *     // ... data to create a Dashboard_Templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dashboard_Templates we want to update
     *   }
     * })
    **/
    upsert<T extends Dashboard_TemplatesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Dashboard_TemplatesUpsertArgs<ExtArgs>>
    ): Prisma__Dashboard_TemplatesClient<$Types.GetResult<Dashboard_TemplatesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Dashboard_Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dashboard_TemplatesCountArgs} args - Arguments to filter Dashboard_Templates to count.
     * @example
     * // Count the number of Dashboard_Templates
     * const count = await prisma.dashboard_Templates.count({
     *   where: {
     *     // ... the filter for the Dashboard_Templates we want to count
     *   }
     * })
    **/
    count<T extends Dashboard_TemplatesCountArgs>(
      args?: Subset<T, Dashboard_TemplatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dashboard_TemplatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dashboard_Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dashboard_TemplatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dashboard_TemplatesAggregateArgs>(args: Subset<T, Dashboard_TemplatesAggregateArgs>): Prisma.PrismaPromise<GetDashboard_TemplatesAggregateType<T>>

    /**
     * Group by Dashboard_Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dashboard_TemplatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Dashboard_TemplatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Dashboard_TemplatesGroupByArgs['orderBy'] }
        : { orderBy?: Dashboard_TemplatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Dashboard_TemplatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboard_TemplatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Dashboard_Templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Dashboard_TemplatesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Dashboard_Templates base type for findUnique actions
   */
  export type Dashboard_TemplatesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard_Templates
     */
    select?: Dashboard_TemplatesSelect<ExtArgs> | null
    /**
     * Filter, which Dashboard_Templates to fetch.
     */
    where: Dashboard_TemplatesWhereUniqueInput
  }

  /**
   * Dashboard_Templates findUnique
   */
  export interface Dashboard_TemplatesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Dashboard_TemplatesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dashboard_Templates findUniqueOrThrow
   */
  export type Dashboard_TemplatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard_Templates
     */
    select?: Dashboard_TemplatesSelect<ExtArgs> | null
    /**
     * Filter, which Dashboard_Templates to fetch.
     */
    where: Dashboard_TemplatesWhereUniqueInput
  }


  /**
   * Dashboard_Templates base type for findFirst actions
   */
  export type Dashboard_TemplatesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard_Templates
     */
    select?: Dashboard_TemplatesSelect<ExtArgs> | null
    /**
     * Filter, which Dashboard_Templates to fetch.
     */
    where?: Dashboard_TemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboard_Templates to fetch.
     */
    orderBy?: Enumerable<Dashboard_TemplatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboard_Templates.
     */
    cursor?: Dashboard_TemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboard_Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboard_Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboard_Templates.
     */
    distinct?: Enumerable<Dashboard_TemplatesScalarFieldEnum>
  }

  /**
   * Dashboard_Templates findFirst
   */
  export interface Dashboard_TemplatesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Dashboard_TemplatesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dashboard_Templates findFirstOrThrow
   */
  export type Dashboard_TemplatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard_Templates
     */
    select?: Dashboard_TemplatesSelect<ExtArgs> | null
    /**
     * Filter, which Dashboard_Templates to fetch.
     */
    where?: Dashboard_TemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboard_Templates to fetch.
     */
    orderBy?: Enumerable<Dashboard_TemplatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboard_Templates.
     */
    cursor?: Dashboard_TemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboard_Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboard_Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboard_Templates.
     */
    distinct?: Enumerable<Dashboard_TemplatesScalarFieldEnum>
  }


  /**
   * Dashboard_Templates findMany
   */
  export type Dashboard_TemplatesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard_Templates
     */
    select?: Dashboard_TemplatesSelect<ExtArgs> | null
    /**
     * Filter, which Dashboard_Templates to fetch.
     */
    where?: Dashboard_TemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboard_Templates to fetch.
     */
    orderBy?: Enumerable<Dashboard_TemplatesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dashboard_Templates.
     */
    cursor?: Dashboard_TemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboard_Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboard_Templates.
     */
    skip?: number
    distinct?: Enumerable<Dashboard_TemplatesScalarFieldEnum>
  }


  /**
   * Dashboard_Templates create
   */
  export type Dashboard_TemplatesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard_Templates
     */
    select?: Dashboard_TemplatesSelect<ExtArgs> | null
    /**
     * The data needed to create a Dashboard_Templates.
     */
    data: XOR<Dashboard_TemplatesCreateInput, Dashboard_TemplatesUncheckedCreateInput>
  }


  /**
   * Dashboard_Templates createMany
   */
  export type Dashboard_TemplatesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dashboard_Templates.
     */
    data: Enumerable<Dashboard_TemplatesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Dashboard_Templates update
   */
  export type Dashboard_TemplatesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard_Templates
     */
    select?: Dashboard_TemplatesSelect<ExtArgs> | null
    /**
     * The data needed to update a Dashboard_Templates.
     */
    data: XOR<Dashboard_TemplatesUpdateInput, Dashboard_TemplatesUncheckedUpdateInput>
    /**
     * Choose, which Dashboard_Templates to update.
     */
    where: Dashboard_TemplatesWhereUniqueInput
  }


  /**
   * Dashboard_Templates updateMany
   */
  export type Dashboard_TemplatesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dashboard_Templates.
     */
    data: XOR<Dashboard_TemplatesUpdateManyMutationInput, Dashboard_TemplatesUncheckedUpdateManyInput>
    /**
     * Filter which Dashboard_Templates to update
     */
    where?: Dashboard_TemplatesWhereInput
  }


  /**
   * Dashboard_Templates upsert
   */
  export type Dashboard_TemplatesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard_Templates
     */
    select?: Dashboard_TemplatesSelect<ExtArgs> | null
    /**
     * The filter to search for the Dashboard_Templates to update in case it exists.
     */
    where: Dashboard_TemplatesWhereUniqueInput
    /**
     * In case the Dashboard_Templates found by the `where` argument doesn't exist, create a new Dashboard_Templates with this data.
     */
    create: XOR<Dashboard_TemplatesCreateInput, Dashboard_TemplatesUncheckedCreateInput>
    /**
     * In case the Dashboard_Templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Dashboard_TemplatesUpdateInput, Dashboard_TemplatesUncheckedUpdateInput>
  }


  /**
   * Dashboard_Templates delete
   */
  export type Dashboard_TemplatesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard_Templates
     */
    select?: Dashboard_TemplatesSelect<ExtArgs> | null
    /**
     * Filter which Dashboard_Templates to delete.
     */
    where: Dashboard_TemplatesWhereUniqueInput
  }


  /**
   * Dashboard_Templates deleteMany
   */
  export type Dashboard_TemplatesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dashboard_Templates to delete
     */
    where?: Dashboard_TemplatesWhereInput
  }


  /**
   * Dashboard_Templates without action
   */
  export type Dashboard_TemplatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard_Templates
     */
    select?: Dashboard_TemplatesSelect<ExtArgs> | null
  }



  /**
   * Model Document
   */


  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    company: string | null
    user_id: string | null
    filetype: string | null
    linkedType: string | null
    fileName: string | null
    createdAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    company: string | null
    user_id: string | null
    filetype: string | null
    linkedType: string | null
    fileName: string | null
    createdAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    company: number
    user_id: number
    filetype: number
    linkedType: number
    fileName: number
    createdAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    company?: true
    user_id?: true
    filetype?: true
    linkedType?: true
    fileName?: true
    createdAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    company?: true
    user_id?: true
    filetype?: true
    linkedType?: true
    fileName?: true
    createdAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    company?: true
    user_id?: true
    filetype?: true
    linkedType?: true
    fileName?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithAggregationInput>
    by: DocumentScalarFieldEnum[]
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }


  export type DocumentGroupByOutputType = {
    id: string
    company: string
    user_id: string | null
    filetype: string
    linkedType: string
    fileName: string | null
    createdAt: Date | null
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    user_id?: boolean
    filetype?: boolean
    linkedType?: boolean
    fileName?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    company?: boolean
    user_id?: boolean
    filetype?: boolean
    linkedType?: boolean
    fileName?: boolean
    createdAt?: boolean
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentArgs> = $Types.GetResult<DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Document base type for findUnique actions
   */
  export type DocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUnique
   */
  export interface DocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document base type for findFirst actions
   */
  export type DocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }

  /**
   * Document findFirst
   */
  export interface DocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: Enumerable<DocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ExampleScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExampleScalarFieldEnum = (typeof ExampleScalarFieldEnum)[keyof typeof ExampleScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    record_id: 'record_id',
    name: 'name',
    type: 'type',
    tier: 'tier',
    access_to_marketplace: 'access_to_marketplace',
    created_at: 'created_at',
    company_manager_id: 'company_manager_id',
    macrovesta_manager_id: 'macrovesta_manager_id'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    role: 'role',
    company_id: 'company_id',
    selected_company_id: 'selected_company_id',
    submittedSurvey: 'submittedSurvey',
    image: 'image'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    record_id: 'record_id',
    title: 'title',
    description: 'description',
    is_read: 'is_read',
    user_id: 'user_id',
    date_created: 'date_created'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const MarketplaceScalarFieldEnum: {
    record_id: 'record_id',
    product: 'product',
    category: 'category',
    quantity: 'quantity',
    quality: 'quality',
    description: 'description',
    image_url: 'image_url',
    price_usd: 'price_usd',
    added_by: 'added_by',
    hvi_file: 'hvi_file',
    shipment: 'shipment',
    payment_terms: 'payment_terms',
    date_created: 'date_created',
    expiry_date: 'expiry_date',
    reserved_by: 'reserved_by'
  };

  export type MarketplaceScalarFieldEnum = (typeof MarketplaceScalarFieldEnum)[keyof typeof MarketplaceScalarFieldEnum]


  export const MarketplaceAgentScalarFieldEnum: {
    record_id: 'record_id',
    marketplace_id: 'marketplace_id',
    agent_id: 'agent_id',
    date_created: 'date_created'
  };

  export type MarketplaceAgentScalarFieldEnum = (typeof MarketplaceAgentScalarFieldEnum)[keyof typeof MarketplaceAgentScalarFieldEnum]


  export const MarketplaceBuyerScalarFieldEnum: {
    record_id: 'record_id',
    marketplace_id: 'marketplace_id',
    buyer_id: 'buyer_id',
    date_created: 'date_created'
  };

  export type MarketplaceBuyerScalarFieldEnum = (typeof MarketplaceBuyerScalarFieldEnum)[keyof typeof MarketplaceBuyerScalarFieldEnum]


  export const A_indexScalarFieldEnum: {
    record_id: 'record_id',
    date: 'date',
    a_index: 'a_index',
    ice_highest_open_interest_17_months: 'ice_highest_open_interest_17_months',
    cc_index: 'cc_index',
    mcx: 'mcx',
    cepea: 'cepea'
  };

  export type A_indexScalarFieldEnum = (typeof A_indexScalarFieldEnum)[keyof typeof A_indexScalarFieldEnum]


  export const Fixed_cottonScalarFieldEnum: {
    company_id: 'company_id',
    record_id: 'record_id',
    contract_number: 'contract_number',
    futures_month: 'futures_month',
    basis: 'basis',
    fixed_price_without_basis: 'fixed_price_without_basis',
    amount_fixed: 'amount_fixed',
    added_by: 'added_by',
    date_created: 'date_created'
  };

  export type Fixed_cottonScalarFieldEnum = (typeof Fixed_cottonScalarFieldEnum)[keyof typeof Fixed_cottonScalarFieldEnum]


  export const Unfixed_cottonScalarFieldEnum: {
    record_id: 'record_id',
    company_id: 'company_id',
    contract_number: 'contract_number',
    futures_month: 'futures_month',
    basis: 'basis',
    fix_by: 'fix_by',
    total_amount: 'total_amount',
    amount_remaining: 'amount_remaining',
    added_by: 'added_by',
    date_created: 'date_created'
  };

  export type Unfixed_cottonScalarFieldEnum = (typeof Unfixed_cottonScalarFieldEnum)[keyof typeof Unfixed_cottonScalarFieldEnum]


  export const Strategy_logScalarFieldEnum: {
    record_id: 'record_id',
    company_id: 'company_id',
    title: 'title',
    text: 'text',
    added_by: 'added_by',
    date_created: 'date_created'
  };

  export type Strategy_logScalarFieldEnum = (typeof Strategy_logScalarFieldEnum)[keyof typeof Strategy_logScalarFieldEnum]


  export const Producer_production_estimatesScalarFieldEnum: {
    record_id: 'record_id',
    company_id: 'company_id',
    season: 'season',
    production_estimate: 'production_estimate',
    yield_estimate: 'yield_estimate',
    added_by: 'added_by',
    date_created: 'date_created'
  };

  export type Producer_production_estimatesScalarFieldEnum = (typeof Producer_production_estimatesScalarFieldEnum)[keyof typeof Producer_production_estimatesScalarFieldEnum]


  export const Producer_cost_estimatesScalarFieldEnum: {
    record_id: 'record_id',
    company_id: 'company_id',
    season: 'season',
    cost_estimate_dollar_per_hectare: 'cost_estimate_dollar_per_hectare',
    cost_estimate_cent_per_pound: 'cost_estimate_cent_per_pound',
    added_by: 'added_by',
    date_created: 'date_created'
  };

  export type Producer_cost_estimatesScalarFieldEnum = (typeof Producer_cost_estimatesScalarFieldEnum)[keyof typeof Producer_cost_estimatesScalarFieldEnum]


  export const Producer_commercialisation_estimatesScalarFieldEnum: {
    record_id: 'record_id',
    company_id: 'company_id',
    season: 'season',
    percentage_sold: 'percentage_sold',
    added_by: 'added_by',
    date_created: 'date_created'
  };

  export type Producer_commercialisation_estimatesScalarFieldEnum = (typeof Producer_commercialisation_estimatesScalarFieldEnum)[keyof typeof Producer_commercialisation_estimatesScalarFieldEnum]


  export const Bug_reportScalarFieldEnum: {
    record_id: 'record_id',
    type: 'type',
    title: 'title',
    text: 'text',
    added_by: 'added_by',
    date_created: 'date_created'
  };

  export type Bug_reportScalarFieldEnum = (typeof Bug_reportScalarFieldEnum)[keyof typeof Bug_reportScalarFieldEnum]


  export const SuggestionsScalarFieldEnum: {
    record_id: 'record_id',
    type: 'type',
    text: 'text',
    added_by: 'added_by',
    date_created: 'date_created'
  };

  export type SuggestionsScalarFieldEnum = (typeof SuggestionsScalarFieldEnum)[keyof typeof SuggestionsScalarFieldEnum]


  export const Upcoming_changesScalarFieldEnum: {
    record_id: 'record_id',
    type: 'type',
    title: 'title',
    text: 'text',
    image: 'image',
    planned_released_date: 'planned_released_date'
  };

  export type Upcoming_changesScalarFieldEnum = (typeof Upcoming_changesScalarFieldEnum)[keyof typeof Upcoming_changesScalarFieldEnum]


  export const ConclusionScalarFieldEnum: {
    record_id: 'record_id',
    text: 'text',
    date_created: 'date_created'
  };

  export type ConclusionScalarFieldEnum = (typeof ConclusionScalarFieldEnum)[keyof typeof ConclusionScalarFieldEnum]


  export const Demo_RequestsScalarFieldEnum: {
    record_id: 'record_id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    company_name: 'company_name',
    company_type: 'company_type',
    preferred_date: 'preferred_date',
    preferred_time: 'preferred_time',
    date_created: 'date_created'
  };

  export type Demo_RequestsScalarFieldEnum = (typeof Demo_RequestsScalarFieldEnum)[keyof typeof Demo_RequestsScalarFieldEnum]


  export const General_InquiriesScalarFieldEnum: {
    record_id: 'record_id',
    name: 'name',
    email: 'email',
    company: 'company',
    message: 'message',
    date_created: 'date_created'
  };

  export type General_InquiriesScalarFieldEnum = (typeof General_InquiriesScalarFieldEnum)[keyof typeof General_InquiriesScalarFieldEnum]


  export const Things_to_reviewScalarFieldEnum: {
    record_id: 'record_id',
    added_by: 'added_by',
    table: 'table',
    type: 'type',
    thing_id: 'thing_id',
    information: 'information',
    date_created: 'date_created'
  };

  export type Things_to_reviewScalarFieldEnum = (typeof Things_to_reviewScalarFieldEnum)[keyof typeof Things_to_reviewScalarFieldEnum]


  export const External_LinksScalarFieldEnum: {
    record_id: 'record_id',
    type: 'type',
    url: 'url',
    language: 'language',
    date_created: 'date_created'
  };

  export type External_LinksScalarFieldEnum = (typeof External_LinksScalarFieldEnum)[keyof typeof External_LinksScalarFieldEnum]


  export const Supply_and_demandScalarFieldEnum: {
    record_id: 'record_id',
    date: 'date',
    season: 'season',
    country: 'country',
    beginning_stocks_usda: 'beginning_stocks_usda',
    beginning_stocks_eap: 'beginning_stocks_eap',
    production_usda: 'production_usda',
    production_eap: 'production_eap',
    imports_usda: 'imports_usda',
    imports_eap: 'imports_eap',
    domestic_use_usda: 'domestic_use_usda',
    domestic_use_eap: 'domestic_use_eap',
    exports_usda: 'exports_usda',
    exports_eap: 'exports_eap',
    ending_stocks_usda: 'ending_stocks_usda',
    ending_stocks_eap: 'ending_stocks_eap',
    projected: 'projected'
  };

  export type Supply_and_demandScalarFieldEnum = (typeof Supply_and_demandScalarFieldEnum)[keyof typeof Supply_and_demandScalarFieldEnum]


  export const Us_export_salesScalarFieldEnum: {
    record_id: 'record_id',
    week_ending: 'week_ending',
    weekly_exports: 'weekly_exports',
    accumulated_exports: 'accumulated_exports',
    net_sales: 'net_sales',
    outstanding_sales: 'outstanding_sales',
    next_marketing_year_net_sales: 'next_marketing_year_net_sales',
    next_marketing_year_outstanding_sales: 'next_marketing_year_outstanding_sales'
  };

  export type Us_export_salesScalarFieldEnum = (typeof Us_export_salesScalarFieldEnum)[keyof typeof Us_export_salesScalarFieldEnum]


  export const Commitment_of_tradersScalarFieldEnum: {
    record_id: 'record_id',
    calendar_year: 'calendar_year',
    crop_year: 'crop_year',
    month: 'month',
    week: 'week',
    report_date_as_dd_mm_yyyy: 'report_date_as_dd_mm_yyyy',
    open_interest_all: 'open_interest_all',
    producer_merchant_net: 'producer_merchant_net',
    swap_position_net: 'swap_position_net',
    managed_money_long: 'managed_money_long',
    managed_money_short: 'managed_money_short',
    managed_money_net: 'managed_money_net',
    other_reportables_net: 'other_reportables_net',
    total_reportables_net: 'total_reportables_net',
    non_reportables_net: 'non_reportables_net',
    specs_net: 'specs_net'
  };

  export type Commitment_of_tradersScalarFieldEnum = (typeof Commitment_of_tradersScalarFieldEnum)[keyof typeof Commitment_of_tradersScalarFieldEnum]


  export const Cotton_on_callScalarFieldEnum: {
    record_id: 'record_id',
    date: 'date',
    season_week: 'season_week',
    week: 'week',
    season: 'season',
    october_sales: 'october_sales',
    december_sales: 'december_sales',
    march_sales: 'march_sales',
    may_sales: 'may_sales',
    july_sales: 'july_sales',
    total_on_call_sales: 'total_on_call_sales',
    october_purchases: 'october_purchases',
    december_purchases: 'december_purchases',
    march_purchases: 'march_purchases',
    may_purchases: 'may_purchases',
    july_purchases: 'july_purchases',
    total_on_call_purchases: 'total_on_call_purchases',
    total_net_u_oc_position: 'total_net_u_oc_position',
    total_net_change: 'total_net_change'
  };

  export type Cotton_on_callScalarFieldEnum = (typeof Cotton_on_callScalarFieldEnum)[keyof typeof Cotton_on_callScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    record_id: 'record_id',
    comment: 'comment',
    section: 'section',
    date_of_comment: 'date_of_comment',
    added_by: 'added_by'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const Future_contracts_studyScalarFieldEnum: {
    record_id: 'record_id',
    year: 'year',
    month_of_high: 'month_of_high',
    date_of_high: 'date_of_high',
    high: 'high',
    month_of_low: 'month_of_low',
    date_of_low: 'date_of_low',
    low: 'low',
    price_range_between_high_and_low: 'price_range_between_high_and_low',
    day_range_between_high_and_low: 'day_range_between_high_and_low',
    inverse: 'inverse',
    comments: 'comments'
  };

  export type Future_contracts_studyScalarFieldEnum = (typeof Future_contracts_studyScalarFieldEnum)[keyof typeof Future_contracts_studyScalarFieldEnum]


  export const Cotton_contractsScalarFieldEnum: {
    record_id: 'record_id',
    datetime: 'datetime',
    contract: 'contract',
    high: 'high',
    low: 'low',
    open: 'open',
    close: 'close',
    change: 'change',
    rolling_average_200_day: 'rolling_average_200_day',
    rolling_average_100_day: 'rolling_average_100_day',
    rolling_average_50_day: 'rolling_average_50_day'
  };

  export type Cotton_contractsScalarFieldEnum = (typeof Cotton_contractsScalarFieldEnum)[keyof typeof Cotton_contractsScalarFieldEnum]


  export const Monthly_indexScalarFieldEnum: {
    record_id: 'record_id',
    month: 'month',
    year: 'year',
    inverse_month: 'inverse_month',
    probability_rate: 'probability_rate'
  };

  export type Monthly_indexScalarFieldEnum = (typeof Monthly_indexScalarFieldEnum)[keyof typeof Monthly_indexScalarFieldEnum]


  export const Seasonal_indexScalarFieldEnum: {
    record_id: 'record_id',
    season: 'season',
    inverse_year: 'inverse_year',
    probability_rate: 'probability_rate'
  };

  export type Seasonal_indexScalarFieldEnum = (typeof Seasonal_indexScalarFieldEnum)[keyof typeof Seasonal_indexScalarFieldEnum]


  export const Comparison_chartScalarFieldEnum: {
    record_id: 'record_id',
    date_of_close: 'date_of_close',
    cotton_spot_price: 'cotton_spot_price',
    dollar_basket_spot_price: 'dollar_basket_spot_price',
    crude_oil_spot_price: 'crude_oil_spot_price'
  };

  export type Comparison_chartScalarFieldEnum = (typeof Comparison_chartScalarFieldEnum)[keyof typeof Comparison_chartScalarFieldEnum]


  export const Snapshot_strategyScalarFieldEnum: {
    record_id: 'record_id',
    title_of_snapshot_strategy: 'title_of_snapshot_strategy',
    image_of_snapshot_strategy: 'image_of_snapshot_strategy',
    text_of_snapshot_strategy: 'text_of_snapshot_strategy',
    date_of_snapshot_strategy: 'date_of_snapshot_strategy',
    valid: 'valid',
    news_type: 'news_type',
    impact: 'impact',
    added_by: 'added_by',
    verified: 'verified'
  };

  export type Snapshot_strategyScalarFieldEnum = (typeof Snapshot_strategyScalarFieldEnum)[keyof typeof Snapshot_strategyScalarFieldEnum]


  export const Basis_comparisonScalarFieldEnum: {
    record_id: 'record_id',
    date_of_basis_report: 'date_of_basis_report',
    country: 'country',
    cost_type: 'cost_type',
    contract_december_2023: 'contract_december_2023',
    contract_december_2024: 'contract_december_2024',
    added_by: 'added_by'
  };

  export type Basis_comparisonScalarFieldEnum = (typeof Basis_comparisonScalarFieldEnum)[keyof typeof Basis_comparisonScalarFieldEnum]


  export const In_country_newsScalarFieldEnum: {
    record_id: 'record_id',
    country: 'country',
    image_of_in_country_news: 'image_of_in_country_news',
    title_of_in_country_news: 'title_of_in_country_news',
    text_of_in_country_news: 'text_of_in_country_news',
    date_of_in_country_news: 'date_of_in_country_news',
    impact: 'impact',
    added_by: 'added_by',
    verified: 'verified'
  };

  export type In_country_newsScalarFieldEnum = (typeof In_country_newsScalarFieldEnum)[keyof typeof In_country_newsScalarFieldEnum]


  export const Sentiment_surveyScalarFieldEnum: {
    record_id: 'record_id',
    bullish_or_bearish: 'bullish_or_bearish',
    bullish_or_bearish_value: 'bullish_or_bearish_value',
    high: 'high',
    low: 'low',
    intraday_average_points: 'intraday_average_points',
    open_interest: 'open_interest',
    date_of_survey: 'date_of_survey',
    added_by: 'added_by'
  };

  export type Sentiment_surveyScalarFieldEnum = (typeof Sentiment_surveyScalarFieldEnum)[keyof typeof Sentiment_surveyScalarFieldEnum]


  export const Comparison_charts_with_17_months_yearScalarFieldEnum: {
    record_id: 'record_id',
    season: 'season',
    low_price: 'low_price',
    date_of_low: 'date_of_low',
    month_of_low: 'month_of_low',
    calendar_week_of_low: 'calendar_week_of_low',
    high_price: 'high_price',
    date_of_high: 'date_of_high',
    month_of_high: 'month_of_high',
    calendar_week_of_high: 'calendar_week_of_high',
    range_between_high_low: 'range_between_high_low',
    rank_of_price_range: 'rank_of_price_range',
    percentage_rate_to_low: 'percentage_rate_to_low',
    day_range_between_high_low: 'day_range_between_high_low',
    rank_between_high_low: 'rank_between_high_low',
    inverse_season: 'inverse_season',
    us_seasonal_inflation: 'us_seasonal_inflation',
    us_inflation_cumm: 'us_inflation_cumm',
    us_interest_rate_mov: 'us_interest_rate_mov',
    us_interest_cumm: 'us_interest_cumm',
    world_population_cumm: 'world_population_cumm',
    world_population_mov: 'world_population_mov',
    world_acreage: 'world_acreage',
    world_acreage_movement: 'world_acreage_movement'
  };

  export type Comparison_charts_with_17_months_yearScalarFieldEnum = (typeof Comparison_charts_with_17_months_yearScalarFieldEnum)[keyof typeof Comparison_charts_with_17_months_yearScalarFieldEnum]


  export const Temporary_StorageScalarFieldEnum: {
    record_id: 'record_id',
    data: 'data',
    created_at: 'created_at'
  };

  export type Temporary_StorageScalarFieldEnum = (typeof Temporary_StorageScalarFieldEnum)[keyof typeof Temporary_StorageScalarFieldEnum]


  export const Report_TemplatesScalarFieldEnum: {
    record_id: 'record_id',
    name: 'name',
    data: 'data',
    company: 'company',
    created_at: 'created_at'
  };

  export type Report_TemplatesScalarFieldEnum = (typeof Report_TemplatesScalarFieldEnum)[keyof typeof Report_TemplatesScalarFieldEnum]


  export const Dashboard_TemplatesScalarFieldEnum: {
    record_id: 'record_id',
    data: 'data',
    company: 'company',
    created_at: 'created_at'
  };

  export type Dashboard_TemplatesScalarFieldEnum = (typeof Dashboard_TemplatesScalarFieldEnum)[keyof typeof Dashboard_TemplatesScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    company: 'company',
    user_id: 'user_id',
    filetype: 'filetype',
    linkedType: 'linkedType',
    fileName: 'fileName',
    createdAt: 'createdAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type ExampleWhereInput = {
    AND?: Enumerable<ExampleWhereInput>
    OR?: Enumerable<ExampleWhereInput>
    NOT?: Enumerable<ExampleWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ExampleOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExampleWhereUniqueInput = {
    id?: string
  }

  export type ExampleOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExampleCountOrderByAggregateInput
    _max?: ExampleMaxOrderByAggregateInput
    _min?: ExampleMinOrderByAggregateInput
  }

  export type ExampleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExampleScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExampleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExampleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = {
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    providerAccountId?: StringWithAggregatesFilter | string
    refresh_token?: StringNullableWithAggregatesFilter | string | null
    access_token?: StringNullableWithAggregatesFilter | string | null
    expires_at?: IntNullableWithAggregatesFilter | number | null
    token_type?: StringNullableWithAggregatesFilter | string | null
    scope?: StringNullableWithAggregatesFilter | string | null
    id_token?: StringNullableWithAggregatesFilter | string | null
    session_state?: StringNullableWithAggregatesFilter | string | null
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = {
    id?: string
    sessionToken?: string
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    sessionToken?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CompanyWhereInput = {
    AND?: Enumerable<CompanyWhereInput>
    OR?: Enumerable<CompanyWhereInput>
    NOT?: Enumerable<CompanyWhereInput>
    record_id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    tier?: StringFilter | string
    access_to_marketplace?: BoolNullableFilter | boolean | null
    created_at?: DateTimeFilter | Date | string
    company_manager_id?: StringNullableFilter | string | null
    macrovesta_manager_id?: StringNullableFilter | string | null
    company_manager?: XOR<UserRelationFilter, UserWhereInput> | null
    macrovesta_manager?: XOR<UserRelationFilter, UserWhereInput> | null
    users?: UserListRelationFilter
    selected_users?: UserListRelationFilter
    producer_production_estimates?: Producer_production_estimatesListRelationFilter
    producer_cost_estimates?: Producer_cost_estimatesListRelationFilter
    producer_commercialisation_estimates?: Producer_commercialisation_estimatesListRelationFilter
    strategy_log?: Strategy_logListRelationFilter
    fixed_cotton?: Fixed_cottonListRelationFilter
    unfixed_cotton?: Unfixed_cottonListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    record_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tier?: SortOrder
    access_to_marketplace?: SortOrderInput | SortOrder
    created_at?: SortOrder
    company_manager_id?: SortOrderInput | SortOrder
    macrovesta_manager_id?: SortOrderInput | SortOrder
    company_manager?: UserOrderByWithRelationInput
    macrovesta_manager?: UserOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    selected_users?: UserOrderByRelationAggregateInput
    producer_production_estimates?: producer_production_estimatesOrderByRelationAggregateInput
    producer_cost_estimates?: producer_cost_estimatesOrderByRelationAggregateInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesOrderByRelationAggregateInput
    strategy_log?: strategy_logOrderByRelationAggregateInput
    fixed_cotton?: fixed_cottonOrderByRelationAggregateInput
    unfixed_cotton?: unfixed_cottonOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = {
    record_id?: string
    company_manager_id?: string
  }

  export type CompanyOrderByWithAggregationInput = {
    record_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tier?: SortOrder
    access_to_marketplace?: SortOrderInput | SortOrder
    created_at?: SortOrder
    company_manager_id?: SortOrderInput | SortOrder
    macrovesta_manager_id?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    OR?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    tier?: StringWithAggregatesFilter | string
    access_to_marketplace?: BoolNullableWithAggregatesFilter | boolean | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    company_manager_id?: StringNullableWithAggregatesFilter | string | null
    macrovesta_manager_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: Enumerable<VerificationTokenWhereInput>
    OR?: Enumerable<VerificationTokenWhereInput>
    NOT?: Enumerable<VerificationTokenWhereInput>
    identifier?: StringFilter | string
    token?: StringFilter | string
    expires?: DateTimeFilter | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = {
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
  }

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VerificationTokenScalarWhereWithAggregatesInput>
    identifier?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    expires?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    role?: StringNullableFilter | string | null
    company_id?: StringNullableFilter | string | null
    selected_company_id?: StringNullableFilter | string | null
    submittedSurvey?: BoolNullableFilter | boolean | null
    image?: StringNullableFilter | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    selected_company?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    company_managing?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    macrovesta_managing?: CompanyListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    agents?: MarketplaceAgentListRelationFilter
    buyers?: MarketplaceBuyerListRelationFilter
    Marketplace?: MarketplaceListRelationFilter
    Notification?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    selected_company_id?: SortOrderInput | SortOrder
    submittedSurvey?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    selected_company?: CompanyOrderByWithRelationInput
    company_managing?: CompanyOrderByWithRelationInput
    macrovesta_managing?: CompanyOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    agents?: MarketplaceAgentOrderByRelationAggregateInput
    buyers?: MarketplaceBuyerOrderByRelationAggregateInput
    Marketplace?: MarketplaceOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    company_id?: SortOrderInput | SortOrder
    selected_company_id?: SortOrderInput | SortOrder
    submittedSurvey?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter | Date | string | null
    role?: StringNullableWithAggregatesFilter | string | null
    company_id?: StringNullableWithAggregatesFilter | string | null
    selected_company_id?: StringNullableWithAggregatesFilter | string | null
    submittedSurvey?: BoolNullableWithAggregatesFilter | boolean | null
    image?: StringNullableWithAggregatesFilter | string | null
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    record_id?: StringFilter | string
    title?: StringFilter | string
    description?: StringFilter | string
    is_read?: BoolFilter | boolean
    user_id?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    record_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    is_read?: SortOrder
    user_id?: SortOrder
    date_created?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = {
    record_id?: string
  }

  export type NotificationOrderByWithAggregationInput = {
    record_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    is_read?: SortOrder
    user_id?: SortOrder
    date_created?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    is_read?: BoolWithAggregatesFilter | boolean
    user_id?: StringWithAggregatesFilter | string
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MarketplaceWhereInput = {
    AND?: Enumerable<MarketplaceWhereInput>
    OR?: Enumerable<MarketplaceWhereInput>
    NOT?: Enumerable<MarketplaceWhereInput>
    record_id?: StringFilter | string
    product?: StringFilter | string
    category?: StringFilter | string
    quantity?: FloatFilter | number
    quality?: StringFilter | string
    description?: StringFilter | string
    image_url?: StringNullableFilter | string | null
    price_usd?: FloatFilter | number
    added_by?: StringFilter | string
    hvi_file?: StringFilter | string
    shipment?: StringFilter | string
    payment_terms?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
    expiry_date?: DateTimeFilter | Date | string
    reserved_by?: StringNullableFilter | string | null
    reserved_by_user?: XOR<UserRelationFilter, UserWhereInput> | null
    agents?: MarketplaceAgentListRelationFilter
    buyers?: MarketplaceBuyerListRelationFilter
  }

  export type MarketplaceOrderByWithRelationInput = {
    record_id?: SortOrder
    product?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    description?: SortOrder
    image_url?: SortOrderInput | SortOrder
    price_usd?: SortOrder
    added_by?: SortOrder
    hvi_file?: SortOrder
    shipment?: SortOrder
    payment_terms?: SortOrder
    date_created?: SortOrder
    expiry_date?: SortOrder
    reserved_by?: SortOrderInput | SortOrder
    reserved_by_user?: UserOrderByWithRelationInput
    agents?: MarketplaceAgentOrderByRelationAggregateInput
    buyers?: MarketplaceBuyerOrderByRelationAggregateInput
  }

  export type MarketplaceWhereUniqueInput = {
    record_id?: string
  }

  export type MarketplaceOrderByWithAggregationInput = {
    record_id?: SortOrder
    product?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    description?: SortOrder
    image_url?: SortOrderInput | SortOrder
    price_usd?: SortOrder
    added_by?: SortOrder
    hvi_file?: SortOrder
    shipment?: SortOrder
    payment_terms?: SortOrder
    date_created?: SortOrder
    expiry_date?: SortOrder
    reserved_by?: SortOrderInput | SortOrder
    _count?: MarketplaceCountOrderByAggregateInput
    _avg?: MarketplaceAvgOrderByAggregateInput
    _max?: MarketplaceMaxOrderByAggregateInput
    _min?: MarketplaceMinOrderByAggregateInput
    _sum?: MarketplaceSumOrderByAggregateInput
  }

  export type MarketplaceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarketplaceScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarketplaceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarketplaceScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    product?: StringWithAggregatesFilter | string
    category?: StringWithAggregatesFilter | string
    quantity?: FloatWithAggregatesFilter | number
    quality?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    image_url?: StringNullableWithAggregatesFilter | string | null
    price_usd?: FloatWithAggregatesFilter | number
    added_by?: StringWithAggregatesFilter | string
    hvi_file?: StringWithAggregatesFilter | string
    shipment?: StringWithAggregatesFilter | string
    payment_terms?: StringWithAggregatesFilter | string
    date_created?: DateTimeWithAggregatesFilter | Date | string
    expiry_date?: DateTimeWithAggregatesFilter | Date | string
    reserved_by?: StringNullableWithAggregatesFilter | string | null
  }

  export type MarketplaceAgentWhereInput = {
    AND?: Enumerable<MarketplaceAgentWhereInput>
    OR?: Enumerable<MarketplaceAgentWhereInput>
    NOT?: Enumerable<MarketplaceAgentWhereInput>
    record_id?: StringFilter | string
    marketplace_id?: StringFilter | string
    agent_id?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
    marketplace?: XOR<MarketplaceRelationFilter, MarketplaceWhereInput>
    agent?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MarketplaceAgentOrderByWithRelationInput = {
    record_id?: SortOrder
    marketplace_id?: SortOrder
    agent_id?: SortOrder
    date_created?: SortOrder
    marketplace?: MarketplaceOrderByWithRelationInput
    agent?: UserOrderByWithRelationInput
  }

  export type MarketplaceAgentWhereUniqueInput = {
    record_id?: string
  }

  export type MarketplaceAgentOrderByWithAggregationInput = {
    record_id?: SortOrder
    marketplace_id?: SortOrder
    agent_id?: SortOrder
    date_created?: SortOrder
    _count?: MarketplaceAgentCountOrderByAggregateInput
    _max?: MarketplaceAgentMaxOrderByAggregateInput
    _min?: MarketplaceAgentMinOrderByAggregateInput
  }

  export type MarketplaceAgentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarketplaceAgentScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarketplaceAgentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarketplaceAgentScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    marketplace_id?: StringWithAggregatesFilter | string
    agent_id?: StringWithAggregatesFilter | string
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MarketplaceBuyerWhereInput = {
    AND?: Enumerable<MarketplaceBuyerWhereInput>
    OR?: Enumerable<MarketplaceBuyerWhereInput>
    NOT?: Enumerable<MarketplaceBuyerWhereInput>
    record_id?: StringFilter | string
    marketplace_id?: StringFilter | string
    buyer_id?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
    buyer?: XOR<UserRelationFilter, UserWhereInput>
    marketplace?: XOR<MarketplaceRelationFilter, MarketplaceWhereInput>
  }

  export type MarketplaceBuyerOrderByWithRelationInput = {
    record_id?: SortOrder
    marketplace_id?: SortOrder
    buyer_id?: SortOrder
    date_created?: SortOrder
    buyer?: UserOrderByWithRelationInput
    marketplace?: MarketplaceOrderByWithRelationInput
  }

  export type MarketplaceBuyerWhereUniqueInput = {
    record_id?: string
  }

  export type MarketplaceBuyerOrderByWithAggregationInput = {
    record_id?: SortOrder
    marketplace_id?: SortOrder
    buyer_id?: SortOrder
    date_created?: SortOrder
    _count?: MarketplaceBuyerCountOrderByAggregateInput
    _max?: MarketplaceBuyerMaxOrderByAggregateInput
    _min?: MarketplaceBuyerMinOrderByAggregateInput
  }

  export type MarketplaceBuyerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarketplaceBuyerScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarketplaceBuyerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarketplaceBuyerScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    marketplace_id?: StringWithAggregatesFilter | string
    buyer_id?: StringWithAggregatesFilter | string
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type a_indexWhereInput = {
    AND?: Enumerable<a_indexWhereInput>
    OR?: Enumerable<a_indexWhereInput>
    NOT?: Enumerable<a_indexWhereInput>
    record_id?: StringFilter | string
    date?: DateTimeFilter | Date | string
    a_index?: DecimalFilter | Decimal | DecimalJsLike | number | string
    ice_highest_open_interest_17_months?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    cc_index?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    mcx?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    cepea?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type a_indexOrderByWithRelationInput = {
    record_id?: SortOrder
    date?: SortOrder
    a_index?: SortOrder
    ice_highest_open_interest_17_months?: SortOrderInput | SortOrder
    cc_index?: SortOrderInput | SortOrder
    mcx?: SortOrderInput | SortOrder
    cepea?: SortOrderInput | SortOrder
  }

  export type a_indexWhereUniqueInput = {
    record_id?: string
  }

  export type a_indexOrderByWithAggregationInput = {
    record_id?: SortOrder
    date?: SortOrder
    a_index?: SortOrder
    ice_highest_open_interest_17_months?: SortOrderInput | SortOrder
    cc_index?: SortOrderInput | SortOrder
    mcx?: SortOrderInput | SortOrder
    cepea?: SortOrderInput | SortOrder
    _count?: a_indexCountOrderByAggregateInput
    _avg?: a_indexAvgOrderByAggregateInput
    _max?: a_indexMaxOrderByAggregateInput
    _min?: a_indexMinOrderByAggregateInput
    _sum?: a_indexSumOrderByAggregateInput
  }

  export type a_indexScalarWhereWithAggregatesInput = {
    AND?: Enumerable<a_indexScalarWhereWithAggregatesInput>
    OR?: Enumerable<a_indexScalarWhereWithAggregatesInput>
    NOT?: Enumerable<a_indexScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    a_index?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    ice_highest_open_interest_17_months?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    cc_index?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    mcx?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    cepea?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type fixed_cottonWhereInput = {
    AND?: Enumerable<fixed_cottonWhereInput>
    OR?: Enumerable<fixed_cottonWhereInput>
    NOT?: Enumerable<fixed_cottonWhereInput>
    company_id?: StringFilter | string
    record_id?: StringFilter | string
    contract_number?: StringFilter | string
    futures_month?: StringFilter | string
    basis?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    amount_fixed?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type fixed_cottonOrderByWithRelationInput = {
    company_id?: SortOrder
    record_id?: SortOrder
    contract_number?: SortOrder
    futures_month?: SortOrder
    basis?: SortOrderInput | SortOrder
    fixed_price_without_basis?: SortOrderInput | SortOrder
    amount_fixed?: SortOrderInput | SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type fixed_cottonWhereUniqueInput = {
    record_id?: string
    contract_number?: string
  }

  export type fixed_cottonOrderByWithAggregationInput = {
    company_id?: SortOrder
    record_id?: SortOrder
    contract_number?: SortOrder
    futures_month?: SortOrder
    basis?: SortOrderInput | SortOrder
    fixed_price_without_basis?: SortOrderInput | SortOrder
    amount_fixed?: SortOrderInput | SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
    _count?: fixed_cottonCountOrderByAggregateInput
    _avg?: fixed_cottonAvgOrderByAggregateInput
    _max?: fixed_cottonMaxOrderByAggregateInput
    _min?: fixed_cottonMinOrderByAggregateInput
    _sum?: fixed_cottonSumOrderByAggregateInput
  }

  export type fixed_cottonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fixed_cottonScalarWhereWithAggregatesInput>
    OR?: Enumerable<fixed_cottonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fixed_cottonScalarWhereWithAggregatesInput>
    company_id?: StringWithAggregatesFilter | string
    record_id?: StringWithAggregatesFilter | string
    contract_number?: StringWithAggregatesFilter | string
    futures_month?: StringWithAggregatesFilter | string
    basis?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    amount_fixed?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    added_by?: StringWithAggregatesFilter | string
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type unfixed_cottonWhereInput = {
    AND?: Enumerable<unfixed_cottonWhereInput>
    OR?: Enumerable<unfixed_cottonWhereInput>
    NOT?: Enumerable<unfixed_cottonWhereInput>
    record_id?: StringFilter | string
    company_id?: StringFilter | string
    contract_number?: StringFilter | string
    futures_month?: StringFilter | string
    basis?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    fix_by?: DateTimeFilter | Date | string
    total_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    amount_remaining?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type unfixed_cottonOrderByWithRelationInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    contract_number?: SortOrder
    futures_month?: SortOrder
    basis?: SortOrderInput | SortOrder
    fix_by?: SortOrder
    total_amount?: SortOrderInput | SortOrder
    amount_remaining?: SortOrderInput | SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type unfixed_cottonWhereUniqueInput = {
    record_id?: string
    contract_number?: string
  }

  export type unfixed_cottonOrderByWithAggregationInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    contract_number?: SortOrder
    futures_month?: SortOrder
    basis?: SortOrderInput | SortOrder
    fix_by?: SortOrder
    total_amount?: SortOrderInput | SortOrder
    amount_remaining?: SortOrderInput | SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
    _count?: unfixed_cottonCountOrderByAggregateInput
    _avg?: unfixed_cottonAvgOrderByAggregateInput
    _max?: unfixed_cottonMaxOrderByAggregateInput
    _min?: unfixed_cottonMinOrderByAggregateInput
    _sum?: unfixed_cottonSumOrderByAggregateInput
  }

  export type unfixed_cottonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<unfixed_cottonScalarWhereWithAggregatesInput>
    OR?: Enumerable<unfixed_cottonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<unfixed_cottonScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    company_id?: StringWithAggregatesFilter | string
    contract_number?: StringWithAggregatesFilter | string
    futures_month?: StringWithAggregatesFilter | string
    basis?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    fix_by?: DateTimeWithAggregatesFilter | Date | string
    total_amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    amount_remaining?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    added_by?: StringWithAggregatesFilter | string
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type strategy_logWhereInput = {
    AND?: Enumerable<strategy_logWhereInput>
    OR?: Enumerable<strategy_logWhereInput>
    NOT?: Enumerable<strategy_logWhereInput>
    record_id?: StringFilter | string
    company_id?: StringFilter | string
    title?: StringNullableFilter | string | null
    text?: StringNullableFilter | string | null
    added_by?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type strategy_logOrderByWithRelationInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    title?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type strategy_logWhereUniqueInput = {
    record_id?: string
  }

  export type strategy_logOrderByWithAggregationInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    title?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
    _count?: strategy_logCountOrderByAggregateInput
    _max?: strategy_logMaxOrderByAggregateInput
    _min?: strategy_logMinOrderByAggregateInput
  }

  export type strategy_logScalarWhereWithAggregatesInput = {
    AND?: Enumerable<strategy_logScalarWhereWithAggregatesInput>
    OR?: Enumerable<strategy_logScalarWhereWithAggregatesInput>
    NOT?: Enumerable<strategy_logScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    company_id?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    text?: StringNullableWithAggregatesFilter | string | null
    added_by?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type producer_production_estimatesWhereInput = {
    AND?: Enumerable<producer_production_estimatesWhereInput>
    OR?: Enumerable<producer_production_estimatesWhereInput>
    NOT?: Enumerable<producer_production_estimatesWhereInput>
    record_id?: StringFilter | string
    company_id?: StringFilter | string
    season?: StringFilter | string
    production_estimate?: DecimalFilter | Decimal | DecimalJsLike | number | string
    yield_estimate?: DecimalFilter | Decimal | DecimalJsLike | number | string
    added_by?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type producer_production_estimatesOrderByWithRelationInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    production_estimate?: SortOrder
    yield_estimate?: SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type producer_production_estimatesWhereUniqueInput = {
    record_id?: string
  }

  export type producer_production_estimatesOrderByWithAggregationInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    production_estimate?: SortOrder
    yield_estimate?: SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
    _count?: producer_production_estimatesCountOrderByAggregateInput
    _avg?: producer_production_estimatesAvgOrderByAggregateInput
    _max?: producer_production_estimatesMaxOrderByAggregateInput
    _min?: producer_production_estimatesMinOrderByAggregateInput
    _sum?: producer_production_estimatesSumOrderByAggregateInput
  }

  export type producer_production_estimatesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<producer_production_estimatesScalarWhereWithAggregatesInput>
    OR?: Enumerable<producer_production_estimatesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<producer_production_estimatesScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    company_id?: StringWithAggregatesFilter | string
    season?: StringWithAggregatesFilter | string
    production_estimate?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    yield_estimate?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    added_by?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type producer_cost_estimatesWhereInput = {
    AND?: Enumerable<producer_cost_estimatesWhereInput>
    OR?: Enumerable<producer_cost_estimatesWhereInput>
    NOT?: Enumerable<producer_cost_estimatesWhereInput>
    record_id?: StringFilter | string
    company_id?: StringFilter | string
    season?: StringFilter | string
    cost_estimate_dollar_per_hectare?: DecimalFilter | Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound?: DecimalFilter | Decimal | DecimalJsLike | number | string
    added_by?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type producer_cost_estimatesOrderByWithRelationInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    cost_estimate_dollar_per_hectare?: SortOrder
    cost_estimate_cent_per_pound?: SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type producer_cost_estimatesWhereUniqueInput = {
    record_id?: string
  }

  export type producer_cost_estimatesOrderByWithAggregationInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    cost_estimate_dollar_per_hectare?: SortOrder
    cost_estimate_cent_per_pound?: SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
    _count?: producer_cost_estimatesCountOrderByAggregateInput
    _avg?: producer_cost_estimatesAvgOrderByAggregateInput
    _max?: producer_cost_estimatesMaxOrderByAggregateInput
    _min?: producer_cost_estimatesMinOrderByAggregateInput
    _sum?: producer_cost_estimatesSumOrderByAggregateInput
  }

  export type producer_cost_estimatesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<producer_cost_estimatesScalarWhereWithAggregatesInput>
    OR?: Enumerable<producer_cost_estimatesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<producer_cost_estimatesScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    company_id?: StringWithAggregatesFilter | string
    season?: StringWithAggregatesFilter | string
    cost_estimate_dollar_per_hectare?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    added_by?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type producer_commercialisation_estimatesWhereInput = {
    AND?: Enumerable<producer_commercialisation_estimatesWhereInput>
    OR?: Enumerable<producer_commercialisation_estimatesWhereInput>
    NOT?: Enumerable<producer_commercialisation_estimatesWhereInput>
    record_id?: StringFilter | string
    company_id?: StringFilter | string
    season?: StringFilter | string
    percentage_sold?: DecimalFilter | Decimal | DecimalJsLike | number | string
    added_by?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type producer_commercialisation_estimatesOrderByWithRelationInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    percentage_sold?: SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type producer_commercialisation_estimatesWhereUniqueInput = {
    record_id?: string
  }

  export type producer_commercialisation_estimatesOrderByWithAggregationInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    percentage_sold?: SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
    _count?: producer_commercialisation_estimatesCountOrderByAggregateInput
    _avg?: producer_commercialisation_estimatesAvgOrderByAggregateInput
    _max?: producer_commercialisation_estimatesMaxOrderByAggregateInput
    _min?: producer_commercialisation_estimatesMinOrderByAggregateInput
    _sum?: producer_commercialisation_estimatesSumOrderByAggregateInput
  }

  export type producer_commercialisation_estimatesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<producer_commercialisation_estimatesScalarWhereWithAggregatesInput>
    OR?: Enumerable<producer_commercialisation_estimatesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<producer_commercialisation_estimatesScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    company_id?: StringWithAggregatesFilter | string
    season?: StringWithAggregatesFilter | string
    percentage_sold?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    added_by?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type bug_reportWhereInput = {
    AND?: Enumerable<bug_reportWhereInput>
    OR?: Enumerable<bug_reportWhereInput>
    NOT?: Enumerable<bug_reportWhereInput>
    record_id?: StringFilter | string
    type?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    text?: StringNullableFilter | string | null
    added_by?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
  }

  export type bug_reportOrderByWithRelationInput = {
    record_id?: SortOrder
    type?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
  }

  export type bug_reportWhereUniqueInput = {
    record_id?: string
  }

  export type bug_reportOrderByWithAggregationInput = {
    record_id?: SortOrder
    type?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
    _count?: bug_reportCountOrderByAggregateInput
    _max?: bug_reportMaxOrderByAggregateInput
    _min?: bug_reportMinOrderByAggregateInput
  }

  export type bug_reportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<bug_reportScalarWhereWithAggregatesInput>
    OR?: Enumerable<bug_reportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<bug_reportScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    type?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    text?: StringNullableWithAggregatesFilter | string | null
    added_by?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type suggestionsWhereInput = {
    AND?: Enumerable<suggestionsWhereInput>
    OR?: Enumerable<suggestionsWhereInput>
    NOT?: Enumerable<suggestionsWhereInput>
    record_id?: StringFilter | string
    type?: StringNullableFilter | string | null
    text?: StringNullableFilter | string | null
    added_by?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
  }

  export type suggestionsOrderByWithRelationInput = {
    record_id?: SortOrder
    type?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
  }

  export type suggestionsWhereUniqueInput = {
    record_id?: string
  }

  export type suggestionsOrderByWithAggregationInput = {
    record_id?: SortOrder
    type?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    added_by?: SortOrderInput | SortOrder
    date_created?: SortOrder
    _count?: suggestionsCountOrderByAggregateInput
    _max?: suggestionsMaxOrderByAggregateInput
    _min?: suggestionsMinOrderByAggregateInput
  }

  export type suggestionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<suggestionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<suggestionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<suggestionsScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    type?: StringNullableWithAggregatesFilter | string | null
    text?: StringNullableWithAggregatesFilter | string | null
    added_by?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type upcoming_changesWhereInput = {
    AND?: Enumerable<upcoming_changesWhereInput>
    OR?: Enumerable<upcoming_changesWhereInput>
    NOT?: Enumerable<upcoming_changesWhereInput>
    record_id?: StringFilter | string
    type?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    text?: StringFilter | string
    image?: StringNullableFilter | string | null
    planned_released_date?: DateTimeNullableFilter | Date | string | null
  }

  export type upcoming_changesOrderByWithRelationInput = {
    record_id?: SortOrder
    type?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    text?: SortOrder
    image?: SortOrderInput | SortOrder
    planned_released_date?: SortOrderInput | SortOrder
  }

  export type upcoming_changesWhereUniqueInput = {
    record_id?: string
  }

  export type upcoming_changesOrderByWithAggregationInput = {
    record_id?: SortOrder
    type?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    text?: SortOrder
    image?: SortOrderInput | SortOrder
    planned_released_date?: SortOrderInput | SortOrder
    _count?: upcoming_changesCountOrderByAggregateInput
    _max?: upcoming_changesMaxOrderByAggregateInput
    _min?: upcoming_changesMinOrderByAggregateInput
  }

  export type upcoming_changesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<upcoming_changesScalarWhereWithAggregatesInput>
    OR?: Enumerable<upcoming_changesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<upcoming_changesScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    type?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    text?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    planned_released_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type conclusionWhereInput = {
    AND?: Enumerable<conclusionWhereInput>
    OR?: Enumerable<conclusionWhereInput>
    NOT?: Enumerable<conclusionWhereInput>
    record_id?: StringFilter | string
    text?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
  }

  export type conclusionOrderByWithRelationInput = {
    record_id?: SortOrder
    text?: SortOrder
    date_created?: SortOrder
  }

  export type conclusionWhereUniqueInput = {
    record_id?: string
  }

  export type conclusionOrderByWithAggregationInput = {
    record_id?: SortOrder
    text?: SortOrder
    date_created?: SortOrder
    _count?: conclusionCountOrderByAggregateInput
    _max?: conclusionMaxOrderByAggregateInput
    _min?: conclusionMinOrderByAggregateInput
  }

  export type conclusionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<conclusionScalarWhereWithAggregatesInput>
    OR?: Enumerable<conclusionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<conclusionScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Demo_RequestsWhereInput = {
    AND?: Enumerable<Demo_RequestsWhereInput>
    OR?: Enumerable<Demo_RequestsWhereInput>
    NOT?: Enumerable<Demo_RequestsWhereInput>
    record_id?: StringFilter | string
    first_name?: StringFilter | string
    last_name?: StringFilter | string
    email?: StringFilter | string
    company_name?: StringNullableFilter | string | null
    company_type?: StringNullableFilter | string | null
    preferred_date?: DateTimeNullableFilter | Date | string | null
    preferred_time?: DateTimeNullableFilter | Date | string | null
    date_created?: DateTimeFilter | Date | string
  }

  export type Demo_RequestsOrderByWithRelationInput = {
    record_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    company_name?: SortOrderInput | SortOrder
    company_type?: SortOrderInput | SortOrder
    preferred_date?: SortOrderInput | SortOrder
    preferred_time?: SortOrderInput | SortOrder
    date_created?: SortOrder
  }

  export type Demo_RequestsWhereUniqueInput = {
    record_id?: string
  }

  export type Demo_RequestsOrderByWithAggregationInput = {
    record_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    company_name?: SortOrderInput | SortOrder
    company_type?: SortOrderInput | SortOrder
    preferred_date?: SortOrderInput | SortOrder
    preferred_time?: SortOrderInput | SortOrder
    date_created?: SortOrder
    _count?: Demo_RequestsCountOrderByAggregateInput
    _max?: Demo_RequestsMaxOrderByAggregateInput
    _min?: Demo_RequestsMinOrderByAggregateInput
  }

  export type Demo_RequestsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Demo_RequestsScalarWhereWithAggregatesInput>
    OR?: Enumerable<Demo_RequestsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Demo_RequestsScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    first_name?: StringWithAggregatesFilter | string
    last_name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    company_name?: StringNullableWithAggregatesFilter | string | null
    company_type?: StringNullableWithAggregatesFilter | string | null
    preferred_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    preferred_time?: DateTimeNullableWithAggregatesFilter | Date | string | null
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type General_InquiriesWhereInput = {
    AND?: Enumerable<General_InquiriesWhereInput>
    OR?: Enumerable<General_InquiriesWhereInput>
    NOT?: Enumerable<General_InquiriesWhereInput>
    record_id?: StringFilter | string
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    company?: StringNullableFilter | string | null
    message?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
  }

  export type General_InquiriesOrderByWithRelationInput = {
    record_id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    date_created?: SortOrder
  }

  export type General_InquiriesWhereUniqueInput = {
    record_id?: string
  }

  export type General_InquiriesOrderByWithAggregationInput = {
    record_id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    date_created?: SortOrder
    _count?: General_InquiriesCountOrderByAggregateInput
    _max?: General_InquiriesMaxOrderByAggregateInput
    _min?: General_InquiriesMinOrderByAggregateInput
  }

  export type General_InquiriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<General_InquiriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<General_InquiriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<General_InquiriesScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    company?: StringNullableWithAggregatesFilter | string | null
    message?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type things_to_reviewWhereInput = {
    AND?: Enumerable<things_to_reviewWhereInput>
    OR?: Enumerable<things_to_reviewWhereInput>
    NOT?: Enumerable<things_to_reviewWhereInput>
    record_id?: StringFilter | string
    added_by?: StringFilter | string
    table?: StringFilter | string
    type?: StringFilter | string
    thing_id?: StringNullableFilter | string | null
    information?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
  }

  export type things_to_reviewOrderByWithRelationInput = {
    record_id?: SortOrder
    added_by?: SortOrder
    table?: SortOrder
    type?: SortOrder
    thing_id?: SortOrderInput | SortOrder
    information?: SortOrder
    date_created?: SortOrder
  }

  export type things_to_reviewWhereUniqueInput = {
    record_id?: string
  }

  export type things_to_reviewOrderByWithAggregationInput = {
    record_id?: SortOrder
    added_by?: SortOrder
    table?: SortOrder
    type?: SortOrder
    thing_id?: SortOrderInput | SortOrder
    information?: SortOrder
    date_created?: SortOrder
    _count?: things_to_reviewCountOrderByAggregateInput
    _max?: things_to_reviewMaxOrderByAggregateInput
    _min?: things_to_reviewMinOrderByAggregateInput
  }

  export type things_to_reviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<things_to_reviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<things_to_reviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<things_to_reviewScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    added_by?: StringWithAggregatesFilter | string
    table?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    thing_id?: StringNullableWithAggregatesFilter | string | null
    information?: StringWithAggregatesFilter | string
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type External_LinksWhereInput = {
    AND?: Enumerable<External_LinksWhereInput>
    OR?: Enumerable<External_LinksWhereInput>
    NOT?: Enumerable<External_LinksWhereInput>
    record_id?: StringFilter | string
    type?: StringFilter | string
    url?: StringFilter | string
    language?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
  }

  export type External_LinksOrderByWithRelationInput = {
    record_id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    language?: SortOrderInput | SortOrder
    date_created?: SortOrder
  }

  export type External_LinksWhereUniqueInput = {
    record_id?: string
  }

  export type External_LinksOrderByWithAggregationInput = {
    record_id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    language?: SortOrderInput | SortOrder
    date_created?: SortOrder
    _count?: External_LinksCountOrderByAggregateInput
    _max?: External_LinksMaxOrderByAggregateInput
    _min?: External_LinksMinOrderByAggregateInput
  }

  export type External_LinksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<External_LinksScalarWhereWithAggregatesInput>
    OR?: Enumerable<External_LinksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<External_LinksScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    language?: StringNullableWithAggregatesFilter | string | null
    date_created?: DateTimeWithAggregatesFilter | Date | string
  }

  export type supply_and_demandWhereInput = {
    AND?: Enumerable<supply_and_demandWhereInput>
    OR?: Enumerable<supply_and_demandWhereInput>
    NOT?: Enumerable<supply_and_demandWhereInput>
    record_id?: StringFilter | string
    date?: DateTimeFilter | Date | string
    season?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    beginning_stocks_usda?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    beginning_stocks_eap?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    production_usda?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    production_eap?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    imports_usda?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    imports_eap?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    domestic_use_usda?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    domestic_use_eap?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    exports_usda?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    exports_eap?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    ending_stocks_usda?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    ending_stocks_eap?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    projected?: BoolNullableFilter | boolean | null
  }

  export type supply_and_demandOrderByWithRelationInput = {
    record_id?: SortOrder
    date?: SortOrder
    season?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    beginning_stocks_usda?: SortOrderInput | SortOrder
    beginning_stocks_eap?: SortOrderInput | SortOrder
    production_usda?: SortOrderInput | SortOrder
    production_eap?: SortOrderInput | SortOrder
    imports_usda?: SortOrderInput | SortOrder
    imports_eap?: SortOrderInput | SortOrder
    domestic_use_usda?: SortOrderInput | SortOrder
    domestic_use_eap?: SortOrderInput | SortOrder
    exports_usda?: SortOrderInput | SortOrder
    exports_eap?: SortOrderInput | SortOrder
    ending_stocks_usda?: SortOrderInput | SortOrder
    ending_stocks_eap?: SortOrderInput | SortOrder
    projected?: SortOrderInput | SortOrder
  }

  export type supply_and_demandWhereUniqueInput = {
    record_id?: string
  }

  export type supply_and_demandOrderByWithAggregationInput = {
    record_id?: SortOrder
    date?: SortOrder
    season?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    beginning_stocks_usda?: SortOrderInput | SortOrder
    beginning_stocks_eap?: SortOrderInput | SortOrder
    production_usda?: SortOrderInput | SortOrder
    production_eap?: SortOrderInput | SortOrder
    imports_usda?: SortOrderInput | SortOrder
    imports_eap?: SortOrderInput | SortOrder
    domestic_use_usda?: SortOrderInput | SortOrder
    domestic_use_eap?: SortOrderInput | SortOrder
    exports_usda?: SortOrderInput | SortOrder
    exports_eap?: SortOrderInput | SortOrder
    ending_stocks_usda?: SortOrderInput | SortOrder
    ending_stocks_eap?: SortOrderInput | SortOrder
    projected?: SortOrderInput | SortOrder
    _count?: supply_and_demandCountOrderByAggregateInput
    _avg?: supply_and_demandAvgOrderByAggregateInput
    _max?: supply_and_demandMaxOrderByAggregateInput
    _min?: supply_and_demandMinOrderByAggregateInput
    _sum?: supply_and_demandSumOrderByAggregateInput
  }

  export type supply_and_demandScalarWhereWithAggregatesInput = {
    AND?: Enumerable<supply_and_demandScalarWhereWithAggregatesInput>
    OR?: Enumerable<supply_and_demandScalarWhereWithAggregatesInput>
    NOT?: Enumerable<supply_and_demandScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    season?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    beginning_stocks_usda?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    beginning_stocks_eap?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    production_usda?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    production_eap?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    imports_usda?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    imports_eap?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    domestic_use_usda?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    domestic_use_eap?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    exports_usda?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    exports_eap?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    ending_stocks_usda?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    ending_stocks_eap?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    projected?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type us_export_salesWhereInput = {
    AND?: Enumerable<us_export_salesWhereInput>
    OR?: Enumerable<us_export_salesWhereInput>
    NOT?: Enumerable<us_export_salesWhereInput>
    record_id?: StringFilter | string
    week_ending?: DateTimeFilter | Date | string
    weekly_exports?: IntNullableFilter | number | null
    accumulated_exports?: IntNullableFilter | number | null
    net_sales?: IntNullableFilter | number | null
    outstanding_sales?: IntNullableFilter | number | null
    next_marketing_year_net_sales?: IntNullableFilter | number | null
    next_marketing_year_outstanding_sales?: IntNullableFilter | number | null
  }

  export type us_export_salesOrderByWithRelationInput = {
    record_id?: SortOrder
    week_ending?: SortOrder
    weekly_exports?: SortOrderInput | SortOrder
    accumulated_exports?: SortOrderInput | SortOrder
    net_sales?: SortOrderInput | SortOrder
    outstanding_sales?: SortOrderInput | SortOrder
    next_marketing_year_net_sales?: SortOrderInput | SortOrder
    next_marketing_year_outstanding_sales?: SortOrderInput | SortOrder
  }

  export type us_export_salesWhereUniqueInput = {
    record_id?: string
  }

  export type us_export_salesOrderByWithAggregationInput = {
    record_id?: SortOrder
    week_ending?: SortOrder
    weekly_exports?: SortOrderInput | SortOrder
    accumulated_exports?: SortOrderInput | SortOrder
    net_sales?: SortOrderInput | SortOrder
    outstanding_sales?: SortOrderInput | SortOrder
    next_marketing_year_net_sales?: SortOrderInput | SortOrder
    next_marketing_year_outstanding_sales?: SortOrderInput | SortOrder
    _count?: us_export_salesCountOrderByAggregateInput
    _avg?: us_export_salesAvgOrderByAggregateInput
    _max?: us_export_salesMaxOrderByAggregateInput
    _min?: us_export_salesMinOrderByAggregateInput
    _sum?: us_export_salesSumOrderByAggregateInput
  }

  export type us_export_salesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<us_export_salesScalarWhereWithAggregatesInput>
    OR?: Enumerable<us_export_salesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<us_export_salesScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    week_ending?: DateTimeWithAggregatesFilter | Date | string
    weekly_exports?: IntNullableWithAggregatesFilter | number | null
    accumulated_exports?: IntNullableWithAggregatesFilter | number | null
    net_sales?: IntNullableWithAggregatesFilter | number | null
    outstanding_sales?: IntNullableWithAggregatesFilter | number | null
    next_marketing_year_net_sales?: IntNullableWithAggregatesFilter | number | null
    next_marketing_year_outstanding_sales?: IntNullableWithAggregatesFilter | number | null
  }

  export type commitment_of_tradersWhereInput = {
    AND?: Enumerable<commitment_of_tradersWhereInput>
    OR?: Enumerable<commitment_of_tradersWhereInput>
    NOT?: Enumerable<commitment_of_tradersWhereInput>
    record_id?: StringFilter | string
    calendar_year?: IntFilter | number
    crop_year?: StringFilter | string
    month?: StringFilter | string
    week?: IntNullableFilter | number | null
    report_date_as_dd_mm_yyyy?: DateTimeFilter | Date | string
    open_interest_all?: IntNullableFilter | number | null
    producer_merchant_net?: IntNullableFilter | number | null
    swap_position_net?: IntNullableFilter | number | null
    managed_money_long?: IntNullableFilter | number | null
    managed_money_short?: IntNullableFilter | number | null
    managed_money_net?: IntNullableFilter | number | null
    other_reportables_net?: IntNullableFilter | number | null
    total_reportables_net?: IntNullableFilter | number | null
    non_reportables_net?: IntNullableFilter | number | null
    specs_net?: IntNullableFilter | number | null
  }

  export type commitment_of_tradersOrderByWithRelationInput = {
    record_id?: SortOrder
    calendar_year?: SortOrder
    crop_year?: SortOrder
    month?: SortOrder
    week?: SortOrderInput | SortOrder
    report_date_as_dd_mm_yyyy?: SortOrder
    open_interest_all?: SortOrderInput | SortOrder
    producer_merchant_net?: SortOrderInput | SortOrder
    swap_position_net?: SortOrderInput | SortOrder
    managed_money_long?: SortOrderInput | SortOrder
    managed_money_short?: SortOrderInput | SortOrder
    managed_money_net?: SortOrderInput | SortOrder
    other_reportables_net?: SortOrderInput | SortOrder
    total_reportables_net?: SortOrderInput | SortOrder
    non_reportables_net?: SortOrderInput | SortOrder
    specs_net?: SortOrderInput | SortOrder
  }

  export type commitment_of_tradersWhereUniqueInput = {
    record_id?: string
  }

  export type commitment_of_tradersOrderByWithAggregationInput = {
    record_id?: SortOrder
    calendar_year?: SortOrder
    crop_year?: SortOrder
    month?: SortOrder
    week?: SortOrderInput | SortOrder
    report_date_as_dd_mm_yyyy?: SortOrder
    open_interest_all?: SortOrderInput | SortOrder
    producer_merchant_net?: SortOrderInput | SortOrder
    swap_position_net?: SortOrderInput | SortOrder
    managed_money_long?: SortOrderInput | SortOrder
    managed_money_short?: SortOrderInput | SortOrder
    managed_money_net?: SortOrderInput | SortOrder
    other_reportables_net?: SortOrderInput | SortOrder
    total_reportables_net?: SortOrderInput | SortOrder
    non_reportables_net?: SortOrderInput | SortOrder
    specs_net?: SortOrderInput | SortOrder
    _count?: commitment_of_tradersCountOrderByAggregateInput
    _avg?: commitment_of_tradersAvgOrderByAggregateInput
    _max?: commitment_of_tradersMaxOrderByAggregateInput
    _min?: commitment_of_tradersMinOrderByAggregateInput
    _sum?: commitment_of_tradersSumOrderByAggregateInput
  }

  export type commitment_of_tradersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<commitment_of_tradersScalarWhereWithAggregatesInput>
    OR?: Enumerable<commitment_of_tradersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<commitment_of_tradersScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    calendar_year?: IntWithAggregatesFilter | number
    crop_year?: StringWithAggregatesFilter | string
    month?: StringWithAggregatesFilter | string
    week?: IntNullableWithAggregatesFilter | number | null
    report_date_as_dd_mm_yyyy?: DateTimeWithAggregatesFilter | Date | string
    open_interest_all?: IntNullableWithAggregatesFilter | number | null
    producer_merchant_net?: IntNullableWithAggregatesFilter | number | null
    swap_position_net?: IntNullableWithAggregatesFilter | number | null
    managed_money_long?: IntNullableWithAggregatesFilter | number | null
    managed_money_short?: IntNullableWithAggregatesFilter | number | null
    managed_money_net?: IntNullableWithAggregatesFilter | number | null
    other_reportables_net?: IntNullableWithAggregatesFilter | number | null
    total_reportables_net?: IntNullableWithAggregatesFilter | number | null
    non_reportables_net?: IntNullableWithAggregatesFilter | number | null
    specs_net?: IntNullableWithAggregatesFilter | number | null
  }

  export type cotton_on_callWhereInput = {
    AND?: Enumerable<cotton_on_callWhereInput>
    OR?: Enumerable<cotton_on_callWhereInput>
    NOT?: Enumerable<cotton_on_callWhereInput>
    record_id?: StringFilter | string
    date?: DateTimeFilter | Date | string
    season_week?: IntNullableFilter | number | null
    week?: IntFilter | number
    season?: StringFilter | string
    october_sales?: IntNullableFilter | number | null
    december_sales?: IntNullableFilter | number | null
    march_sales?: IntNullableFilter | number | null
    may_sales?: IntNullableFilter | number | null
    july_sales?: IntNullableFilter | number | null
    total_on_call_sales?: IntNullableFilter | number | null
    october_purchases?: IntNullableFilter | number | null
    december_purchases?: IntNullableFilter | number | null
    march_purchases?: IntNullableFilter | number | null
    may_purchases?: IntNullableFilter | number | null
    july_purchases?: IntNullableFilter | number | null
    total_on_call_purchases?: IntNullableFilter | number | null
    total_net_u_oc_position?: IntNullableFilter | number | null
    total_net_change?: IntNullableFilter | number | null
  }

  export type cotton_on_callOrderByWithRelationInput = {
    record_id?: SortOrder
    date?: SortOrder
    season_week?: SortOrderInput | SortOrder
    week?: SortOrder
    season?: SortOrder
    october_sales?: SortOrderInput | SortOrder
    december_sales?: SortOrderInput | SortOrder
    march_sales?: SortOrderInput | SortOrder
    may_sales?: SortOrderInput | SortOrder
    july_sales?: SortOrderInput | SortOrder
    total_on_call_sales?: SortOrderInput | SortOrder
    october_purchases?: SortOrderInput | SortOrder
    december_purchases?: SortOrderInput | SortOrder
    march_purchases?: SortOrderInput | SortOrder
    may_purchases?: SortOrderInput | SortOrder
    july_purchases?: SortOrderInput | SortOrder
    total_on_call_purchases?: SortOrderInput | SortOrder
    total_net_u_oc_position?: SortOrderInput | SortOrder
    total_net_change?: SortOrderInput | SortOrder
  }

  export type cotton_on_callWhereUniqueInput = {
    record_id?: string
  }

  export type cotton_on_callOrderByWithAggregationInput = {
    record_id?: SortOrder
    date?: SortOrder
    season_week?: SortOrderInput | SortOrder
    week?: SortOrder
    season?: SortOrder
    october_sales?: SortOrderInput | SortOrder
    december_sales?: SortOrderInput | SortOrder
    march_sales?: SortOrderInput | SortOrder
    may_sales?: SortOrderInput | SortOrder
    july_sales?: SortOrderInput | SortOrder
    total_on_call_sales?: SortOrderInput | SortOrder
    october_purchases?: SortOrderInput | SortOrder
    december_purchases?: SortOrderInput | SortOrder
    march_purchases?: SortOrderInput | SortOrder
    may_purchases?: SortOrderInput | SortOrder
    july_purchases?: SortOrderInput | SortOrder
    total_on_call_purchases?: SortOrderInput | SortOrder
    total_net_u_oc_position?: SortOrderInput | SortOrder
    total_net_change?: SortOrderInput | SortOrder
    _count?: cotton_on_callCountOrderByAggregateInput
    _avg?: cotton_on_callAvgOrderByAggregateInput
    _max?: cotton_on_callMaxOrderByAggregateInput
    _min?: cotton_on_callMinOrderByAggregateInput
    _sum?: cotton_on_callSumOrderByAggregateInput
  }

  export type cotton_on_callScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cotton_on_callScalarWhereWithAggregatesInput>
    OR?: Enumerable<cotton_on_callScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cotton_on_callScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    season_week?: IntNullableWithAggregatesFilter | number | null
    week?: IntWithAggregatesFilter | number
    season?: StringWithAggregatesFilter | string
    october_sales?: IntNullableWithAggregatesFilter | number | null
    december_sales?: IntNullableWithAggregatesFilter | number | null
    march_sales?: IntNullableWithAggregatesFilter | number | null
    may_sales?: IntNullableWithAggregatesFilter | number | null
    july_sales?: IntNullableWithAggregatesFilter | number | null
    total_on_call_sales?: IntNullableWithAggregatesFilter | number | null
    october_purchases?: IntNullableWithAggregatesFilter | number | null
    december_purchases?: IntNullableWithAggregatesFilter | number | null
    march_purchases?: IntNullableWithAggregatesFilter | number | null
    may_purchases?: IntNullableWithAggregatesFilter | number | null
    july_purchases?: IntNullableWithAggregatesFilter | number | null
    total_on_call_purchases?: IntNullableWithAggregatesFilter | number | null
    total_net_u_oc_position?: IntNullableWithAggregatesFilter | number | null
    total_net_change?: IntNullableWithAggregatesFilter | number | null
  }

  export type commentsWhereInput = {
    AND?: Enumerable<commentsWhereInput>
    OR?: Enumerable<commentsWhereInput>
    NOT?: Enumerable<commentsWhereInput>
    record_id?: StringFilter | string
    comment?: StringFilter | string
    section?: StringFilter | string
    date_of_comment?: DateTimeFilter | Date | string
    added_by?: StringFilter | string
  }

  export type commentsOrderByWithRelationInput = {
    record_id?: SortOrder
    comment?: SortOrder
    section?: SortOrder
    date_of_comment?: SortOrder
    added_by?: SortOrder
  }

  export type commentsWhereUniqueInput = {
    record_id?: string
  }

  export type commentsOrderByWithAggregationInput = {
    record_id?: SortOrder
    comment?: SortOrder
    section?: SortOrder
    date_of_comment?: SortOrder
    added_by?: SortOrder
    _count?: commentsCountOrderByAggregateInput
    _max?: commentsMaxOrderByAggregateInput
    _min?: commentsMinOrderByAggregateInput
  }

  export type commentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<commentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<commentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<commentsScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    comment?: StringWithAggregatesFilter | string
    section?: StringWithAggregatesFilter | string
    date_of_comment?: DateTimeWithAggregatesFilter | Date | string
    added_by?: StringWithAggregatesFilter | string
  }

  export type future_contracts_studyWhereInput = {
    AND?: Enumerable<future_contracts_studyWhereInput>
    OR?: Enumerable<future_contracts_studyWhereInput>
    NOT?: Enumerable<future_contracts_studyWhereInput>
    record_id?: StringFilter | string
    year?: StringFilter | string
    month_of_high?: IntNullableFilter | number | null
    date_of_high?: DateTimeNullableFilter | Date | string | null
    high?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    month_of_low?: IntNullableFilter | number | null
    date_of_low?: DateTimeNullableFilter | Date | string | null
    low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    price_range_between_high_and_low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_and_low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    inverse?: StringNullableFilter | string | null
    comments?: StringNullableFilter | string | null
  }

  export type future_contracts_studyOrderByWithRelationInput = {
    record_id?: SortOrder
    year?: SortOrder
    month_of_high?: SortOrderInput | SortOrder
    date_of_high?: SortOrderInput | SortOrder
    high?: SortOrderInput | SortOrder
    month_of_low?: SortOrderInput | SortOrder
    date_of_low?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    price_range_between_high_and_low?: SortOrderInput | SortOrder
    day_range_between_high_and_low?: SortOrderInput | SortOrder
    inverse?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
  }

  export type future_contracts_studyWhereUniqueInput = {
    record_id?: string
  }

  export type future_contracts_studyOrderByWithAggregationInput = {
    record_id?: SortOrder
    year?: SortOrder
    month_of_high?: SortOrderInput | SortOrder
    date_of_high?: SortOrderInput | SortOrder
    high?: SortOrderInput | SortOrder
    month_of_low?: SortOrderInput | SortOrder
    date_of_low?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    price_range_between_high_and_low?: SortOrderInput | SortOrder
    day_range_between_high_and_low?: SortOrderInput | SortOrder
    inverse?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    _count?: future_contracts_studyCountOrderByAggregateInput
    _avg?: future_contracts_studyAvgOrderByAggregateInput
    _max?: future_contracts_studyMaxOrderByAggregateInput
    _min?: future_contracts_studyMinOrderByAggregateInput
    _sum?: future_contracts_studySumOrderByAggregateInput
  }

  export type future_contracts_studyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<future_contracts_studyScalarWhereWithAggregatesInput>
    OR?: Enumerable<future_contracts_studyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<future_contracts_studyScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    year?: StringWithAggregatesFilter | string
    month_of_high?: IntNullableWithAggregatesFilter | number | null
    date_of_high?: DateTimeNullableWithAggregatesFilter | Date | string | null
    high?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    month_of_low?: IntNullableWithAggregatesFilter | number | null
    date_of_low?: DateTimeNullableWithAggregatesFilter | Date | string | null
    low?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    price_range_between_high_and_low?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_and_low?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    inverse?: StringNullableWithAggregatesFilter | string | null
    comments?: StringNullableWithAggregatesFilter | string | null
  }

  export type cotton_contractsWhereInput = {
    AND?: Enumerable<cotton_contractsWhereInput>
    OR?: Enumerable<cotton_contractsWhereInput>
    NOT?: Enumerable<cotton_contractsWhereInput>
    record_id?: StringFilter | string
    datetime?: DateTimeFilter | Date | string
    contract?: StringFilter | string
    high?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    open?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    change?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    rolling_average_200_day?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    rolling_average_100_day?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    rolling_average_50_day?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type cotton_contractsOrderByWithRelationInput = {
    record_id?: SortOrder
    datetime?: SortOrder
    contract?: SortOrder
    high?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    open?: SortOrderInput | SortOrder
    close?: SortOrderInput | SortOrder
    change?: SortOrderInput | SortOrder
    rolling_average_200_day?: SortOrderInput | SortOrder
    rolling_average_100_day?: SortOrderInput | SortOrder
    rolling_average_50_day?: SortOrderInput | SortOrder
  }

  export type cotton_contractsWhereUniqueInput = {
    record_id?: string
  }

  export type cotton_contractsOrderByWithAggregationInput = {
    record_id?: SortOrder
    datetime?: SortOrder
    contract?: SortOrder
    high?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    open?: SortOrderInput | SortOrder
    close?: SortOrderInput | SortOrder
    change?: SortOrderInput | SortOrder
    rolling_average_200_day?: SortOrderInput | SortOrder
    rolling_average_100_day?: SortOrderInput | SortOrder
    rolling_average_50_day?: SortOrderInput | SortOrder
    _count?: cotton_contractsCountOrderByAggregateInput
    _avg?: cotton_contractsAvgOrderByAggregateInput
    _max?: cotton_contractsMaxOrderByAggregateInput
    _min?: cotton_contractsMinOrderByAggregateInput
    _sum?: cotton_contractsSumOrderByAggregateInput
  }

  export type cotton_contractsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cotton_contractsScalarWhereWithAggregatesInput>
    OR?: Enumerable<cotton_contractsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cotton_contractsScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    datetime?: DateTimeWithAggregatesFilter | Date | string
    contract?: StringWithAggregatesFilter | string
    high?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    open?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    change?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    rolling_average_200_day?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    rolling_average_100_day?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    rolling_average_50_day?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type monthly_indexWhereInput = {
    AND?: Enumerable<monthly_indexWhereInput>
    OR?: Enumerable<monthly_indexWhereInput>
    NOT?: Enumerable<monthly_indexWhereInput>
    record_id?: StringFilter | string
    month?: StringFilter | string
    year?: IntFilter | number
    inverse_month?: StringFilter | string
    probability_rate?: StringFilter | string
  }

  export type monthly_indexOrderByWithRelationInput = {
    record_id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    inverse_month?: SortOrder
    probability_rate?: SortOrder
  }

  export type monthly_indexWhereUniqueInput = {
    record_id?: string
  }

  export type monthly_indexOrderByWithAggregationInput = {
    record_id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    inverse_month?: SortOrder
    probability_rate?: SortOrder
    _count?: monthly_indexCountOrderByAggregateInput
    _avg?: monthly_indexAvgOrderByAggregateInput
    _max?: monthly_indexMaxOrderByAggregateInput
    _min?: monthly_indexMinOrderByAggregateInput
    _sum?: monthly_indexSumOrderByAggregateInput
  }

  export type monthly_indexScalarWhereWithAggregatesInput = {
    AND?: Enumerable<monthly_indexScalarWhereWithAggregatesInput>
    OR?: Enumerable<monthly_indexScalarWhereWithAggregatesInput>
    NOT?: Enumerable<monthly_indexScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    month?: StringWithAggregatesFilter | string
    year?: IntWithAggregatesFilter | number
    inverse_month?: StringWithAggregatesFilter | string
    probability_rate?: StringWithAggregatesFilter | string
  }

  export type seasonal_indexWhereInput = {
    AND?: Enumerable<seasonal_indexWhereInput>
    OR?: Enumerable<seasonal_indexWhereInput>
    NOT?: Enumerable<seasonal_indexWhereInput>
    record_id?: StringFilter | string
    season?: StringFilter | string
    inverse_year?: StringFilter | string
    probability_rate?: StringFilter | string
  }

  export type seasonal_indexOrderByWithRelationInput = {
    record_id?: SortOrder
    season?: SortOrder
    inverse_year?: SortOrder
    probability_rate?: SortOrder
  }

  export type seasonal_indexWhereUniqueInput = {
    record_id?: string
  }

  export type seasonal_indexOrderByWithAggregationInput = {
    record_id?: SortOrder
    season?: SortOrder
    inverse_year?: SortOrder
    probability_rate?: SortOrder
    _count?: seasonal_indexCountOrderByAggregateInput
    _max?: seasonal_indexMaxOrderByAggregateInput
    _min?: seasonal_indexMinOrderByAggregateInput
  }

  export type seasonal_indexScalarWhereWithAggregatesInput = {
    AND?: Enumerable<seasonal_indexScalarWhereWithAggregatesInput>
    OR?: Enumerable<seasonal_indexScalarWhereWithAggregatesInput>
    NOT?: Enumerable<seasonal_indexScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    season?: StringWithAggregatesFilter | string
    inverse_year?: StringWithAggregatesFilter | string
    probability_rate?: StringWithAggregatesFilter | string
  }

  export type comparison_chartWhereInput = {
    AND?: Enumerable<comparison_chartWhereInput>
    OR?: Enumerable<comparison_chartWhereInput>
    NOT?: Enumerable<comparison_chartWhereInput>
    record_id?: StringFilter | string
    date_of_close?: DateTimeFilter | Date | string
    cotton_spot_price?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    dollar_basket_spot_price?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    crude_oil_spot_price?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type comparison_chartOrderByWithRelationInput = {
    record_id?: SortOrder
    date_of_close?: SortOrder
    cotton_spot_price?: SortOrderInput | SortOrder
    dollar_basket_spot_price?: SortOrderInput | SortOrder
    crude_oil_spot_price?: SortOrderInput | SortOrder
  }

  export type comparison_chartWhereUniqueInput = {
    record_id?: string
  }

  export type comparison_chartOrderByWithAggregationInput = {
    record_id?: SortOrder
    date_of_close?: SortOrder
    cotton_spot_price?: SortOrderInput | SortOrder
    dollar_basket_spot_price?: SortOrderInput | SortOrder
    crude_oil_spot_price?: SortOrderInput | SortOrder
    _count?: comparison_chartCountOrderByAggregateInput
    _avg?: comparison_chartAvgOrderByAggregateInput
    _max?: comparison_chartMaxOrderByAggregateInput
    _min?: comparison_chartMinOrderByAggregateInput
    _sum?: comparison_chartSumOrderByAggregateInput
  }

  export type comparison_chartScalarWhereWithAggregatesInput = {
    AND?: Enumerable<comparison_chartScalarWhereWithAggregatesInput>
    OR?: Enumerable<comparison_chartScalarWhereWithAggregatesInput>
    NOT?: Enumerable<comparison_chartScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    date_of_close?: DateTimeWithAggregatesFilter | Date | string
    cotton_spot_price?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    dollar_basket_spot_price?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    crude_oil_spot_price?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type snapshot_strategyWhereInput = {
    AND?: Enumerable<snapshot_strategyWhereInput>
    OR?: Enumerable<snapshot_strategyWhereInput>
    NOT?: Enumerable<snapshot_strategyWhereInput>
    record_id?: StringFilter | string
    title_of_snapshot_strategy?: StringFilter | string
    image_of_snapshot_strategy?: StringNullableFilter | string | null
    text_of_snapshot_strategy?: StringFilter | string
    date_of_snapshot_strategy?: DateTimeFilter | Date | string
    valid?: BoolFilter | boolean
    news_type?: StringFilter | string
    impact?: StringNullableFilter | string | null
    added_by?: StringFilter | string
    verified?: BoolFilter | boolean
  }

  export type snapshot_strategyOrderByWithRelationInput = {
    record_id?: SortOrder
    title_of_snapshot_strategy?: SortOrder
    image_of_snapshot_strategy?: SortOrderInput | SortOrder
    text_of_snapshot_strategy?: SortOrder
    date_of_snapshot_strategy?: SortOrder
    valid?: SortOrder
    news_type?: SortOrder
    impact?: SortOrderInput | SortOrder
    added_by?: SortOrder
    verified?: SortOrder
  }

  export type snapshot_strategyWhereUniqueInput = {
    record_id?: string
  }

  export type snapshot_strategyOrderByWithAggregationInput = {
    record_id?: SortOrder
    title_of_snapshot_strategy?: SortOrder
    image_of_snapshot_strategy?: SortOrderInput | SortOrder
    text_of_snapshot_strategy?: SortOrder
    date_of_snapshot_strategy?: SortOrder
    valid?: SortOrder
    news_type?: SortOrder
    impact?: SortOrderInput | SortOrder
    added_by?: SortOrder
    verified?: SortOrder
    _count?: snapshot_strategyCountOrderByAggregateInput
    _max?: snapshot_strategyMaxOrderByAggregateInput
    _min?: snapshot_strategyMinOrderByAggregateInput
  }

  export type snapshot_strategyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<snapshot_strategyScalarWhereWithAggregatesInput>
    OR?: Enumerable<snapshot_strategyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<snapshot_strategyScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    title_of_snapshot_strategy?: StringWithAggregatesFilter | string
    image_of_snapshot_strategy?: StringNullableWithAggregatesFilter | string | null
    text_of_snapshot_strategy?: StringWithAggregatesFilter | string
    date_of_snapshot_strategy?: DateTimeWithAggregatesFilter | Date | string
    valid?: BoolWithAggregatesFilter | boolean
    news_type?: StringWithAggregatesFilter | string
    impact?: StringNullableWithAggregatesFilter | string | null
    added_by?: StringWithAggregatesFilter | string
    verified?: BoolWithAggregatesFilter | boolean
  }

  export type basis_comparisonWhereInput = {
    AND?: Enumerable<basis_comparisonWhereInput>
    OR?: Enumerable<basis_comparisonWhereInput>
    NOT?: Enumerable<basis_comparisonWhereInput>
    record_id?: StringFilter | string
    date_of_basis_report?: DateTimeFilter | Date | string
    country?: StringFilter | string
    cost_type?: StringFilter | string
    contract_december_2023?: IntFilter | number
    contract_december_2024?: IntFilter | number
    added_by?: StringFilter | string
  }

  export type basis_comparisonOrderByWithRelationInput = {
    record_id?: SortOrder
    date_of_basis_report?: SortOrder
    country?: SortOrder
    cost_type?: SortOrder
    contract_december_2023?: SortOrder
    contract_december_2024?: SortOrder
    added_by?: SortOrder
  }

  export type basis_comparisonWhereUniqueInput = {
    record_id?: string
  }

  export type basis_comparisonOrderByWithAggregationInput = {
    record_id?: SortOrder
    date_of_basis_report?: SortOrder
    country?: SortOrder
    cost_type?: SortOrder
    contract_december_2023?: SortOrder
    contract_december_2024?: SortOrder
    added_by?: SortOrder
    _count?: basis_comparisonCountOrderByAggregateInput
    _avg?: basis_comparisonAvgOrderByAggregateInput
    _max?: basis_comparisonMaxOrderByAggregateInput
    _min?: basis_comparisonMinOrderByAggregateInput
    _sum?: basis_comparisonSumOrderByAggregateInput
  }

  export type basis_comparisonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<basis_comparisonScalarWhereWithAggregatesInput>
    OR?: Enumerable<basis_comparisonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<basis_comparisonScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    date_of_basis_report?: DateTimeWithAggregatesFilter | Date | string
    country?: StringWithAggregatesFilter | string
    cost_type?: StringWithAggregatesFilter | string
    contract_december_2023?: IntWithAggregatesFilter | number
    contract_december_2024?: IntWithAggregatesFilter | number
    added_by?: StringWithAggregatesFilter | string
  }

  export type in_country_newsWhereInput = {
    AND?: Enumerable<in_country_newsWhereInput>
    OR?: Enumerable<in_country_newsWhereInput>
    NOT?: Enumerable<in_country_newsWhereInput>
    record_id?: StringFilter | string
    country?: StringNullableFilter | string | null
    image_of_in_country_news?: StringNullableFilter | string | null
    title_of_in_country_news?: StringFilter | string
    text_of_in_country_news?: StringFilter | string
    date_of_in_country_news?: DateTimeFilter | Date | string
    impact?: StringNullableFilter | string | null
    added_by?: StringFilter | string
    verified?: BoolFilter | boolean
  }

  export type in_country_newsOrderByWithRelationInput = {
    record_id?: SortOrder
    country?: SortOrderInput | SortOrder
    image_of_in_country_news?: SortOrderInput | SortOrder
    title_of_in_country_news?: SortOrder
    text_of_in_country_news?: SortOrder
    date_of_in_country_news?: SortOrder
    impact?: SortOrderInput | SortOrder
    added_by?: SortOrder
    verified?: SortOrder
  }

  export type in_country_newsWhereUniqueInput = {
    record_id?: string
  }

  export type in_country_newsOrderByWithAggregationInput = {
    record_id?: SortOrder
    country?: SortOrderInput | SortOrder
    image_of_in_country_news?: SortOrderInput | SortOrder
    title_of_in_country_news?: SortOrder
    text_of_in_country_news?: SortOrder
    date_of_in_country_news?: SortOrder
    impact?: SortOrderInput | SortOrder
    added_by?: SortOrder
    verified?: SortOrder
    _count?: in_country_newsCountOrderByAggregateInput
    _max?: in_country_newsMaxOrderByAggregateInput
    _min?: in_country_newsMinOrderByAggregateInput
  }

  export type in_country_newsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<in_country_newsScalarWhereWithAggregatesInput>
    OR?: Enumerable<in_country_newsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<in_country_newsScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    country?: StringNullableWithAggregatesFilter | string | null
    image_of_in_country_news?: StringNullableWithAggregatesFilter | string | null
    title_of_in_country_news?: StringWithAggregatesFilter | string
    text_of_in_country_news?: StringWithAggregatesFilter | string
    date_of_in_country_news?: DateTimeWithAggregatesFilter | Date | string
    impact?: StringNullableWithAggregatesFilter | string | null
    added_by?: StringWithAggregatesFilter | string
    verified?: BoolWithAggregatesFilter | boolean
  }

  export type sentiment_surveyWhereInput = {
    AND?: Enumerable<sentiment_surveyWhereInput>
    OR?: Enumerable<sentiment_surveyWhereInput>
    NOT?: Enumerable<sentiment_surveyWhereInput>
    record_id?: StringFilter | string
    bullish_or_bearish?: StringFilter | string
    bullish_or_bearish_value?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    intraday_average_points?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    open_interest?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    date_of_survey?: DateTimeNullableFilter | Date | string | null
    added_by?: StringFilter | string
  }

  export type sentiment_surveyOrderByWithRelationInput = {
    record_id?: SortOrder
    bullish_or_bearish?: SortOrder
    bullish_or_bearish_value?: SortOrderInput | SortOrder
    high?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    intraday_average_points?: SortOrderInput | SortOrder
    open_interest?: SortOrderInput | SortOrder
    date_of_survey?: SortOrderInput | SortOrder
    added_by?: SortOrder
  }

  export type sentiment_surveyWhereUniqueInput = {
    record_id?: string
  }

  export type sentiment_surveyOrderByWithAggregationInput = {
    record_id?: SortOrder
    bullish_or_bearish?: SortOrder
    bullish_or_bearish_value?: SortOrderInput | SortOrder
    high?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    intraday_average_points?: SortOrderInput | SortOrder
    open_interest?: SortOrderInput | SortOrder
    date_of_survey?: SortOrderInput | SortOrder
    added_by?: SortOrder
    _count?: sentiment_surveyCountOrderByAggregateInput
    _avg?: sentiment_surveyAvgOrderByAggregateInput
    _max?: sentiment_surveyMaxOrderByAggregateInput
    _min?: sentiment_surveyMinOrderByAggregateInput
    _sum?: sentiment_surveySumOrderByAggregateInput
  }

  export type sentiment_surveyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sentiment_surveyScalarWhereWithAggregatesInput>
    OR?: Enumerable<sentiment_surveyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sentiment_surveyScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    bullish_or_bearish?: StringWithAggregatesFilter | string
    bullish_or_bearish_value?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    intraday_average_points?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    open_interest?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    date_of_survey?: DateTimeNullableWithAggregatesFilter | Date | string | null
    added_by?: StringWithAggregatesFilter | string
  }

  export type comparison_charts_with_17_months_yearWhereInput = {
    AND?: Enumerable<comparison_charts_with_17_months_yearWhereInput>
    OR?: Enumerable<comparison_charts_with_17_months_yearWhereInput>
    NOT?: Enumerable<comparison_charts_with_17_months_yearWhereInput>
    record_id?: StringFilter | string
    season?: StringFilter | string
    low_price?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    date_of_low?: DateTimeFilter | Date | string
    month_of_low?: IntFilter | number
    calendar_week_of_low?: IntFilter | number
    high_price?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    date_of_high?: DateTimeFilter | Date | string
    month_of_high?: IntFilter | number
    calendar_week_of_high?: IntFilter | number
    range_between_high_low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    rank_of_price_range?: IntFilter | number
    percentage_rate_to_low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_low?: IntFilter | number
    rank_between_high_low?: IntFilter | number
    inverse_season?: StringFilter | string
    us_seasonal_inflation?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    us_inflation_cumm?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    us_interest_rate_mov?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    us_interest_cumm?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    world_population_cumm?: IntFilter | number
    world_population_mov?: IntFilter | number
    world_acreage?: IntFilter | number
    world_acreage_movement?: IntFilter | number
  }

  export type comparison_charts_with_17_months_yearOrderByWithRelationInput = {
    record_id?: SortOrder
    season?: SortOrder
    low_price?: SortOrderInput | SortOrder
    date_of_low?: SortOrder
    month_of_low?: SortOrder
    calendar_week_of_low?: SortOrder
    high_price?: SortOrderInput | SortOrder
    date_of_high?: SortOrder
    month_of_high?: SortOrder
    calendar_week_of_high?: SortOrder
    range_between_high_low?: SortOrderInput | SortOrder
    rank_of_price_range?: SortOrder
    percentage_rate_to_low?: SortOrderInput | SortOrder
    day_range_between_high_low?: SortOrder
    rank_between_high_low?: SortOrder
    inverse_season?: SortOrder
    us_seasonal_inflation?: SortOrderInput | SortOrder
    us_inflation_cumm?: SortOrderInput | SortOrder
    us_interest_rate_mov?: SortOrderInput | SortOrder
    us_interest_cumm?: SortOrderInput | SortOrder
    world_population_cumm?: SortOrder
    world_population_mov?: SortOrder
    world_acreage?: SortOrder
    world_acreage_movement?: SortOrder
  }

  export type comparison_charts_with_17_months_yearWhereUniqueInput = {
    record_id?: string
  }

  export type comparison_charts_with_17_months_yearOrderByWithAggregationInput = {
    record_id?: SortOrder
    season?: SortOrder
    low_price?: SortOrderInput | SortOrder
    date_of_low?: SortOrder
    month_of_low?: SortOrder
    calendar_week_of_low?: SortOrder
    high_price?: SortOrderInput | SortOrder
    date_of_high?: SortOrder
    month_of_high?: SortOrder
    calendar_week_of_high?: SortOrder
    range_between_high_low?: SortOrderInput | SortOrder
    rank_of_price_range?: SortOrder
    percentage_rate_to_low?: SortOrderInput | SortOrder
    day_range_between_high_low?: SortOrder
    rank_between_high_low?: SortOrder
    inverse_season?: SortOrder
    us_seasonal_inflation?: SortOrderInput | SortOrder
    us_inflation_cumm?: SortOrderInput | SortOrder
    us_interest_rate_mov?: SortOrderInput | SortOrder
    us_interest_cumm?: SortOrderInput | SortOrder
    world_population_cumm?: SortOrder
    world_population_mov?: SortOrder
    world_acreage?: SortOrder
    world_acreage_movement?: SortOrder
    _count?: comparison_charts_with_17_months_yearCountOrderByAggregateInput
    _avg?: comparison_charts_with_17_months_yearAvgOrderByAggregateInput
    _max?: comparison_charts_with_17_months_yearMaxOrderByAggregateInput
    _min?: comparison_charts_with_17_months_yearMinOrderByAggregateInput
    _sum?: comparison_charts_with_17_months_yearSumOrderByAggregateInput
  }

  export type comparison_charts_with_17_months_yearScalarWhereWithAggregatesInput = {
    AND?: Enumerable<comparison_charts_with_17_months_yearScalarWhereWithAggregatesInput>
    OR?: Enumerable<comparison_charts_with_17_months_yearScalarWhereWithAggregatesInput>
    NOT?: Enumerable<comparison_charts_with_17_months_yearScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    season?: StringWithAggregatesFilter | string
    low_price?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    date_of_low?: DateTimeWithAggregatesFilter | Date | string
    month_of_low?: IntWithAggregatesFilter | number
    calendar_week_of_low?: IntWithAggregatesFilter | number
    high_price?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    date_of_high?: DateTimeWithAggregatesFilter | Date | string
    month_of_high?: IntWithAggregatesFilter | number
    calendar_week_of_high?: IntWithAggregatesFilter | number
    range_between_high_low?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    rank_of_price_range?: IntWithAggregatesFilter | number
    percentage_rate_to_low?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_low?: IntWithAggregatesFilter | number
    rank_between_high_low?: IntWithAggregatesFilter | number
    inverse_season?: StringWithAggregatesFilter | string
    us_seasonal_inflation?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    us_inflation_cumm?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    us_interest_rate_mov?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    us_interest_cumm?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    world_population_cumm?: IntWithAggregatesFilter | number
    world_population_mov?: IntWithAggregatesFilter | number
    world_acreage?: IntWithAggregatesFilter | number
    world_acreage_movement?: IntWithAggregatesFilter | number
  }

  export type Temporary_StorageWhereInput = {
    AND?: Enumerable<Temporary_StorageWhereInput>
    OR?: Enumerable<Temporary_StorageWhereInput>
    NOT?: Enumerable<Temporary_StorageWhereInput>
    record_id?: StringFilter | string
    data?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
  }

  export type Temporary_StorageOrderByWithRelationInput = {
    record_id?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
  }

  export type Temporary_StorageWhereUniqueInput = {
    record_id?: string
  }

  export type Temporary_StorageOrderByWithAggregationInput = {
    record_id?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    _count?: Temporary_StorageCountOrderByAggregateInput
    _max?: Temporary_StorageMaxOrderByAggregateInput
    _min?: Temporary_StorageMinOrderByAggregateInput
  }

  export type Temporary_StorageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Temporary_StorageScalarWhereWithAggregatesInput>
    OR?: Enumerable<Temporary_StorageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Temporary_StorageScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    data?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Report_TemplatesWhereInput = {
    AND?: Enumerable<Report_TemplatesWhereInput>
    OR?: Enumerable<Report_TemplatesWhereInput>
    NOT?: Enumerable<Report_TemplatesWhereInput>
    record_id?: StringFilter | string
    name?: StringFilter | string
    data?: StringFilter | string
    company?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
  }

  export type Report_TemplatesOrderByWithRelationInput = {
    record_id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    company?: SortOrder
    created_at?: SortOrder
  }

  export type Report_TemplatesWhereUniqueInput = {
    record_id?: string
  }

  export type Report_TemplatesOrderByWithAggregationInput = {
    record_id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    company?: SortOrder
    created_at?: SortOrder
    _count?: Report_TemplatesCountOrderByAggregateInput
    _max?: Report_TemplatesMaxOrderByAggregateInput
    _min?: Report_TemplatesMinOrderByAggregateInput
  }

  export type Report_TemplatesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Report_TemplatesScalarWhereWithAggregatesInput>
    OR?: Enumerable<Report_TemplatesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Report_TemplatesScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    data?: StringWithAggregatesFilter | string
    company?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Dashboard_TemplatesWhereInput = {
    AND?: Enumerable<Dashboard_TemplatesWhereInput>
    OR?: Enumerable<Dashboard_TemplatesWhereInput>
    NOT?: Enumerable<Dashboard_TemplatesWhereInput>
    record_id?: StringFilter | string
    data?: StringFilter | string
    company?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
  }

  export type Dashboard_TemplatesOrderByWithRelationInput = {
    record_id?: SortOrder
    data?: SortOrder
    company?: SortOrder
    created_at?: SortOrder
  }

  export type Dashboard_TemplatesWhereUniqueInput = {
    record_id?: string
    company?: string
  }

  export type Dashboard_TemplatesOrderByWithAggregationInput = {
    record_id?: SortOrder
    data?: SortOrder
    company?: SortOrder
    created_at?: SortOrder
    _count?: Dashboard_TemplatesCountOrderByAggregateInput
    _max?: Dashboard_TemplatesMaxOrderByAggregateInput
    _min?: Dashboard_TemplatesMinOrderByAggregateInput
  }

  export type Dashboard_TemplatesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Dashboard_TemplatesScalarWhereWithAggregatesInput>
    OR?: Enumerable<Dashboard_TemplatesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Dashboard_TemplatesScalarWhereWithAggregatesInput>
    record_id?: StringWithAggregatesFilter | string
    data?: StringWithAggregatesFilter | string
    company?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DocumentWhereInput = {
    AND?: Enumerable<DocumentWhereInput>
    OR?: Enumerable<DocumentWhereInput>
    NOT?: Enumerable<DocumentWhereInput>
    id?: StringFilter | string
    company?: StringFilter | string
    user_id?: StringNullableFilter | string | null
    filetype?: StringFilter | string
    linkedType?: StringFilter | string
    fileName?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    company?: SortOrder
    user_id?: SortOrderInput | SortOrder
    filetype?: SortOrder
    linkedType?: SortOrder
    fileName?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
  }

  export type DocumentWhereUniqueInput = {
    id?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    company?: SortOrder
    user_id?: SortOrderInput | SortOrder
    filetype?: SortOrder
    linkedType?: SortOrder
    fileName?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    company?: StringWithAggregatesFilter | string
    user_id?: StringNullableWithAggregatesFilter | string | null
    filetype?: StringWithAggregatesFilter | string
    linkedType?: StringWithAggregatesFilter | string
    fileName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ExampleCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager?: UserCreateNestedOneWithoutCompany_managingInput
    macrovesta_manager?: UserCreateNestedOneWithoutMacrovesta_managingInput
    users?: UserCreateNestedManyWithoutCompanyInput
    selected_users?: UserCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    macrovesta_manager_id?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    selected_users?: UserUncheckedCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logUncheckedCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager?: UserUpdateOneWithoutCompany_managingNestedInput
    macrovesta_manager?: UserUpdateOneWithoutMacrovesta_managingNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUncheckedUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUncheckedUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    macrovesta_manager_id?: string | null
  }

  export type CompanyUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    selected_company?: CompanyCreateNestedOneWithoutSelected_usersInput
    company_managing?: CompanyCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company_managing?: CompanyUncheckedCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    selected_company?: CompanyUpdateOneWithoutSelected_usersNestedInput
    company_managing?: CompanyUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company_managing?: CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    record_id?: string
    title: string
    description: string
    is_read: boolean
    date_created?: Date | string
    user?: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    record_id?: string
    title: string
    description: string
    is_read: boolean
    user_id: string
    date_created?: Date | string
  }

  export type NotificationUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    record_id?: string
    title: string
    description: string
    is_read: boolean
    user_id: string
    date_created?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceCreateInput = {
    record_id?: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url?: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created?: Date | string
    expiry_date?: Date | string
    reserved_by_user?: UserCreateNestedOneWithoutMarketplaceInput
    agents?: MarketplaceAgentCreateNestedManyWithoutMarketplaceInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutMarketplaceInput
  }

  export type MarketplaceUncheckedCreateInput = {
    record_id?: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url?: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created?: Date | string
    expiry_date?: Date | string
    reserved_by?: string | null
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutMarketplaceInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutMarketplaceInput
  }

  export type MarketplaceUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reserved_by_user?: UserUpdateOneWithoutMarketplaceNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutMarketplaceNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutMarketplaceNestedInput
  }

  export type MarketplaceUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reserved_by?: NullableStringFieldUpdateOperationsInput | string | null
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutMarketplaceNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutMarketplaceNestedInput
  }

  export type MarketplaceCreateManyInput = {
    record_id?: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url?: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created?: Date | string
    expiry_date?: Date | string
    reserved_by?: string | null
  }

  export type MarketplaceUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reserved_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketplaceAgentCreateInput = {
    record_id?: string
    date_created?: Date | string
    marketplace: MarketplaceCreateNestedOneWithoutAgentsInput
    agent: UserCreateNestedOneWithoutAgentsInput
  }

  export type MarketplaceAgentUncheckedCreateInput = {
    record_id?: string
    marketplace_id: string
    agent_id: string
    date_created?: Date | string
  }

  export type MarketplaceAgentUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: MarketplaceUpdateOneRequiredWithoutAgentsNestedInput
    agent?: UserUpdateOneRequiredWithoutAgentsNestedInput
  }

  export type MarketplaceAgentUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    marketplace_id?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceAgentCreateManyInput = {
    record_id?: string
    marketplace_id: string
    agent_id: string
    date_created?: Date | string
  }

  export type MarketplaceAgentUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceAgentUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    marketplace_id?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceBuyerCreateInput = {
    record_id?: string
    date_created?: Date | string
    buyer: UserCreateNestedOneWithoutBuyersInput
    marketplace: MarketplaceCreateNestedOneWithoutBuyersInput
  }

  export type MarketplaceBuyerUncheckedCreateInput = {
    record_id?: string
    marketplace_id: string
    buyer_id: string
    date_created?: Date | string
  }

  export type MarketplaceBuyerUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: UserUpdateOneRequiredWithoutBuyersNestedInput
    marketplace?: MarketplaceUpdateOneRequiredWithoutBuyersNestedInput
  }

  export type MarketplaceBuyerUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    marketplace_id?: StringFieldUpdateOperationsInput | string
    buyer_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceBuyerCreateManyInput = {
    record_id?: string
    marketplace_id: string
    buyer_id: string
    date_created?: Date | string
  }

  export type MarketplaceBuyerUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceBuyerUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    marketplace_id?: StringFieldUpdateOperationsInput | string
    buyer_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type a_indexCreateInput = {
    record_id?: string
    date: Date | string
    a_index: Decimal | DecimalJsLike | number | string
    ice_highest_open_interest_17_months?: Decimal | DecimalJsLike | number | string | null
    cc_index?: Decimal | DecimalJsLike | number | string | null
    mcx?: Decimal | DecimalJsLike | number | string | null
    cepea?: Decimal | DecimalJsLike | number | string | null
  }

  export type a_indexUncheckedCreateInput = {
    record_id?: string
    date: Date | string
    a_index: Decimal | DecimalJsLike | number | string
    ice_highest_open_interest_17_months?: Decimal | DecimalJsLike | number | string | null
    cc_index?: Decimal | DecimalJsLike | number | string | null
    mcx?: Decimal | DecimalJsLike | number | string | null
    cepea?: Decimal | DecimalJsLike | number | string | null
  }

  export type a_indexUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    a_index?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ice_highest_open_interest_17_months?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cc_index?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mcx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cepea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type a_indexUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    a_index?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ice_highest_open_interest_17_months?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cc_index?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mcx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cepea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type a_indexCreateManyInput = {
    record_id?: string
    date: Date | string
    a_index: Decimal | DecimalJsLike | number | string
    ice_highest_open_interest_17_months?: Decimal | DecimalJsLike | number | string | null
    cc_index?: Decimal | DecimalJsLike | number | string | null
    mcx?: Decimal | DecimalJsLike | number | string | null
    cepea?: Decimal | DecimalJsLike | number | string | null
  }

  export type a_indexUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    a_index?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ice_highest_open_interest_17_months?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cc_index?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mcx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cepea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type a_indexUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    a_index?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ice_highest_open_interest_17_months?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cc_index?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mcx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cepea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type fixed_cottonCreateInput = {
    record_id?: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: Decimal | DecimalJsLike | number | string | null
    amount_fixed?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
    company: CompanyCreateNestedOneWithoutFixed_cottonInput
  }

  export type fixed_cottonUncheckedCreateInput = {
    company_id: string
    record_id?: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: Decimal | DecimalJsLike | number | string | null
    amount_fixed?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
  }

  export type fixed_cottonUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFixed_cottonNestedInput
  }

  export type fixed_cottonUncheckedUpdateInput = {
    company_id?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fixed_cottonCreateManyInput = {
    company_id: string
    record_id?: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: Decimal | DecimalJsLike | number | string | null
    amount_fixed?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
  }

  export type fixed_cottonUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fixed_cottonUncheckedUpdateManyInput = {
    company_id?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unfixed_cottonCreateInput = {
    record_id?: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fix_by: Date | string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    amount_remaining?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
    company: CompanyCreateNestedOneWithoutUnfixed_cottonInput
  }

  export type unfixed_cottonUncheckedCreateInput = {
    record_id?: string
    company_id: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fix_by: Date | string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    amount_remaining?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
  }

  export type unfixed_cottonUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fix_by?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_remaining?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnfixed_cottonNestedInput
  }

  export type unfixed_cottonUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fix_by?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_remaining?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unfixed_cottonCreateManyInput = {
    record_id?: string
    company_id: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fix_by: Date | string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    amount_remaining?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
  }

  export type unfixed_cottonUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fix_by?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_remaining?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unfixed_cottonUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fix_by?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_remaining?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type strategy_logCreateInput = {
    record_id?: string
    title?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
    company: CompanyCreateNestedOneWithoutStrategy_logInput
  }

  export type strategy_logUncheckedCreateInput = {
    record_id?: string
    company_id: string
    title?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type strategy_logUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStrategy_logNestedInput
  }

  export type strategy_logUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type strategy_logCreateManyInput = {
    record_id?: string
    company_id: string
    title?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type strategy_logUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type strategy_logUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_production_estimatesCreateInput = {
    record_id?: string
    season: string
    production_estimate: Decimal | DecimalJsLike | number | string
    yield_estimate: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
    company: CompanyCreateNestedOneWithoutProducer_production_estimatesInput
  }

  export type producer_production_estimatesUncheckedCreateInput = {
    record_id?: string
    company_id: string
    season: string
    production_estimate: Decimal | DecimalJsLike | number | string
    yield_estimate: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_production_estimatesUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    production_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yield_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProducer_production_estimatesNestedInput
  }

  export type producer_production_estimatesUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    production_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yield_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_production_estimatesCreateManyInput = {
    record_id?: string
    company_id: string
    season: string
    production_estimate: Decimal | DecimalJsLike | number | string
    yield_estimate: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_production_estimatesUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    production_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yield_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_production_estimatesUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    production_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yield_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_cost_estimatesCreateInput = {
    record_id?: string
    season: string
    cost_estimate_dollar_per_hectare: Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
    company: CompanyCreateNestedOneWithoutProducer_cost_estimatesInput
  }

  export type producer_cost_estimatesUncheckedCreateInput = {
    record_id?: string
    company_id: string
    season: string
    cost_estimate_dollar_per_hectare: Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_cost_estimatesUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    cost_estimate_dollar_per_hectare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProducer_cost_estimatesNestedInput
  }

  export type producer_cost_estimatesUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    cost_estimate_dollar_per_hectare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_cost_estimatesCreateManyInput = {
    record_id?: string
    company_id: string
    season: string
    cost_estimate_dollar_per_hectare: Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_cost_estimatesUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    cost_estimate_dollar_per_hectare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_cost_estimatesUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    cost_estimate_dollar_per_hectare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_commercialisation_estimatesCreateInput = {
    record_id?: string
    season: string
    percentage_sold: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
    company: CompanyCreateNestedOneWithoutProducer_commercialisation_estimatesInput
  }

  export type producer_commercialisation_estimatesUncheckedCreateInput = {
    record_id?: string
    company_id: string
    season: string
    percentage_sold: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_commercialisation_estimatesUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    percentage_sold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutProducer_commercialisation_estimatesNestedInput
  }

  export type producer_commercialisation_estimatesUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    percentage_sold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_commercialisation_estimatesCreateManyInput = {
    record_id?: string
    company_id: string
    season: string
    percentage_sold: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_commercialisation_estimatesUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    percentage_sold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_commercialisation_estimatesUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    percentage_sold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bug_reportCreateInput = {
    record_id?: string
    type?: string | null
    title?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type bug_reportUncheckedCreateInput = {
    record_id?: string
    type?: string | null
    title?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type bug_reportUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bug_reportUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bug_reportCreateManyInput = {
    record_id?: string
    type?: string | null
    title?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type bug_reportUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bug_reportUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsCreateInput = {
    record_id?: string
    type?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type suggestionsUncheckedCreateInput = {
    record_id?: string
    type?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type suggestionsUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsCreateManyInput = {
    record_id?: string
    type?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type suggestionsUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suggestionsUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type upcoming_changesCreateInput = {
    record_id?: string
    type?: string | null
    title?: string | null
    text: string
    image?: string | null
    planned_released_date?: Date | string | null
  }

  export type upcoming_changesUncheckedCreateInput = {
    record_id?: string
    type?: string | null
    title?: string | null
    text: string
    image?: string | null
    planned_released_date?: Date | string | null
  }

  export type upcoming_changesUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    planned_released_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type upcoming_changesUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    planned_released_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type upcoming_changesCreateManyInput = {
    record_id?: string
    type?: string | null
    title?: string | null
    text: string
    image?: string | null
    planned_released_date?: Date | string | null
  }

  export type upcoming_changesUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    planned_released_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type upcoming_changesUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    planned_released_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conclusionCreateInput = {
    record_id?: string
    text: string
    date_created?: Date | string
  }

  export type conclusionUncheckedCreateInput = {
    record_id?: string
    text: string
    date_created?: Date | string
  }

  export type conclusionUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conclusionUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conclusionCreateManyInput = {
    record_id?: string
    text: string
    date_created?: Date | string
  }

  export type conclusionUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conclusionUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Demo_RequestsCreateInput = {
    record_id?: string
    first_name: string
    last_name: string
    email: string
    company_name?: string | null
    company_type?: string | null
    preferred_date?: Date | string | null
    preferred_time?: Date | string | null
    date_created?: Date | string
  }

  export type Demo_RequestsUncheckedCreateInput = {
    record_id?: string
    first_name: string
    last_name: string
    email: string
    company_name?: string | null
    company_type?: string | null
    preferred_date?: Date | string | null
    preferred_time?: Date | string | null
    date_created?: Date | string
  }

  export type Demo_RequestsUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Demo_RequestsUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Demo_RequestsCreateManyInput = {
    record_id?: string
    first_name: string
    last_name: string
    email: string
    company_name?: string | null
    company_type?: string | null
    preferred_date?: Date | string | null
    preferred_time?: Date | string | null
    date_created?: Date | string
  }

  export type Demo_RequestsUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Demo_RequestsUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: NullableStringFieldUpdateOperationsInput | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type General_InquiriesCreateInput = {
    record_id?: string
    name?: string | null
    email?: string | null
    company?: string | null
    message?: string | null
    date_created?: Date | string
  }

  export type General_InquiriesUncheckedCreateInput = {
    record_id?: string
    name?: string | null
    email?: string | null
    company?: string | null
    message?: string | null
    date_created?: Date | string
  }

  export type General_InquiriesUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type General_InquiriesUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type General_InquiriesCreateManyInput = {
    record_id?: string
    name?: string | null
    email?: string | null
    company?: string | null
    message?: string | null
    date_created?: Date | string
  }

  export type General_InquiriesUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type General_InquiriesUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type things_to_reviewCreateInput = {
    record_id?: string
    added_by: string
    table: string
    type: string
    thing_id?: string | null
    information: string
    date_created?: Date | string
  }

  export type things_to_reviewUncheckedCreateInput = {
    record_id?: string
    added_by: string
    table: string
    type: string
    thing_id?: string | null
    information: string
    date_created?: Date | string
  }

  export type things_to_reviewUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    added_by?: StringFieldUpdateOperationsInput | string
    table?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thing_id?: NullableStringFieldUpdateOperationsInput | string | null
    information?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type things_to_reviewUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    added_by?: StringFieldUpdateOperationsInput | string
    table?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thing_id?: NullableStringFieldUpdateOperationsInput | string | null
    information?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type things_to_reviewCreateManyInput = {
    record_id?: string
    added_by: string
    table: string
    type: string
    thing_id?: string | null
    information: string
    date_created?: Date | string
  }

  export type things_to_reviewUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    added_by?: StringFieldUpdateOperationsInput | string
    table?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thing_id?: NullableStringFieldUpdateOperationsInput | string | null
    information?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type things_to_reviewUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    added_by?: StringFieldUpdateOperationsInput | string
    table?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    thing_id?: NullableStringFieldUpdateOperationsInput | string | null
    information?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type External_LinksCreateInput = {
    record_id?: string
    type: string
    url: string
    language?: string | null
    date_created?: Date | string
  }

  export type External_LinksUncheckedCreateInput = {
    record_id?: string
    type: string
    url: string
    language?: string | null
    date_created?: Date | string
  }

  export type External_LinksUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type External_LinksUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type External_LinksCreateManyInput = {
    record_id?: string
    type: string
    url: string
    language?: string | null
    date_created?: Date | string
  }

  export type External_LinksUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type External_LinksUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supply_and_demandCreateInput = {
    record_id?: string
    date: Date | string
    season?: string | null
    country?: string | null
    beginning_stocks_usda?: Decimal | DecimalJsLike | number | string | null
    beginning_stocks_eap?: Decimal | DecimalJsLike | number | string | null
    production_usda?: Decimal | DecimalJsLike | number | string | null
    production_eap?: Decimal | DecimalJsLike | number | string | null
    imports_usda?: Decimal | DecimalJsLike | number | string | null
    imports_eap?: Decimal | DecimalJsLike | number | string | null
    domestic_use_usda?: Decimal | DecimalJsLike | number | string | null
    domestic_use_eap?: Decimal | DecimalJsLike | number | string | null
    exports_usda?: Decimal | DecimalJsLike | number | string | null
    exports_eap?: Decimal | DecimalJsLike | number | string | null
    ending_stocks_usda?: Decimal | DecimalJsLike | number | string | null
    ending_stocks_eap?: Decimal | DecimalJsLike | number | string | null
    projected?: boolean | null
  }

  export type supply_and_demandUncheckedCreateInput = {
    record_id?: string
    date: Date | string
    season?: string | null
    country?: string | null
    beginning_stocks_usda?: Decimal | DecimalJsLike | number | string | null
    beginning_stocks_eap?: Decimal | DecimalJsLike | number | string | null
    production_usda?: Decimal | DecimalJsLike | number | string | null
    production_eap?: Decimal | DecimalJsLike | number | string | null
    imports_usda?: Decimal | DecimalJsLike | number | string | null
    imports_eap?: Decimal | DecimalJsLike | number | string | null
    domestic_use_usda?: Decimal | DecimalJsLike | number | string | null
    domestic_use_eap?: Decimal | DecimalJsLike | number | string | null
    exports_usda?: Decimal | DecimalJsLike | number | string | null
    exports_eap?: Decimal | DecimalJsLike | number | string | null
    ending_stocks_usda?: Decimal | DecimalJsLike | number | string | null
    ending_stocks_eap?: Decimal | DecimalJsLike | number | string | null
    projected?: boolean | null
  }

  export type supply_and_demandUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    beginning_stocks_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    beginning_stocks_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imports_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imports_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    domestic_use_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    domestic_use_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exports_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exports_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ending_stocks_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ending_stocks_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    projected?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type supply_and_demandUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    beginning_stocks_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    beginning_stocks_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imports_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imports_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    domestic_use_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    domestic_use_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exports_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exports_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ending_stocks_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ending_stocks_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    projected?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type supply_and_demandCreateManyInput = {
    record_id?: string
    date: Date | string
    season?: string | null
    country?: string | null
    beginning_stocks_usda?: Decimal | DecimalJsLike | number | string | null
    beginning_stocks_eap?: Decimal | DecimalJsLike | number | string | null
    production_usda?: Decimal | DecimalJsLike | number | string | null
    production_eap?: Decimal | DecimalJsLike | number | string | null
    imports_usda?: Decimal | DecimalJsLike | number | string | null
    imports_eap?: Decimal | DecimalJsLike | number | string | null
    domestic_use_usda?: Decimal | DecimalJsLike | number | string | null
    domestic_use_eap?: Decimal | DecimalJsLike | number | string | null
    exports_usda?: Decimal | DecimalJsLike | number | string | null
    exports_eap?: Decimal | DecimalJsLike | number | string | null
    ending_stocks_usda?: Decimal | DecimalJsLike | number | string | null
    ending_stocks_eap?: Decimal | DecimalJsLike | number | string | null
    projected?: boolean | null
  }

  export type supply_and_demandUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    beginning_stocks_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    beginning_stocks_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imports_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imports_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    domestic_use_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    domestic_use_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exports_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exports_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ending_stocks_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ending_stocks_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    projected?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type supply_and_demandUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    beginning_stocks_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    beginning_stocks_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imports_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imports_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    domestic_use_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    domestic_use_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exports_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exports_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ending_stocks_usda?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ending_stocks_eap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    projected?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type us_export_salesCreateInput = {
    record_id?: string
    week_ending: Date | string
    weekly_exports?: number | null
    accumulated_exports?: number | null
    net_sales?: number | null
    outstanding_sales?: number | null
    next_marketing_year_net_sales?: number | null
    next_marketing_year_outstanding_sales?: number | null
  }

  export type us_export_salesUncheckedCreateInput = {
    record_id?: string
    week_ending: Date | string
    weekly_exports?: number | null
    accumulated_exports?: number | null
    net_sales?: number | null
    outstanding_sales?: number | null
    next_marketing_year_net_sales?: number | null
    next_marketing_year_outstanding_sales?: number | null
  }

  export type us_export_salesUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    week_ending?: DateTimeFieldUpdateOperationsInput | Date | string
    weekly_exports?: NullableIntFieldUpdateOperationsInput | number | null
    accumulated_exports?: NullableIntFieldUpdateOperationsInput | number | null
    net_sales?: NullableIntFieldUpdateOperationsInput | number | null
    outstanding_sales?: NullableIntFieldUpdateOperationsInput | number | null
    next_marketing_year_net_sales?: NullableIntFieldUpdateOperationsInput | number | null
    next_marketing_year_outstanding_sales?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type us_export_salesUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    week_ending?: DateTimeFieldUpdateOperationsInput | Date | string
    weekly_exports?: NullableIntFieldUpdateOperationsInput | number | null
    accumulated_exports?: NullableIntFieldUpdateOperationsInput | number | null
    net_sales?: NullableIntFieldUpdateOperationsInput | number | null
    outstanding_sales?: NullableIntFieldUpdateOperationsInput | number | null
    next_marketing_year_net_sales?: NullableIntFieldUpdateOperationsInput | number | null
    next_marketing_year_outstanding_sales?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type us_export_salesCreateManyInput = {
    record_id?: string
    week_ending: Date | string
    weekly_exports?: number | null
    accumulated_exports?: number | null
    net_sales?: number | null
    outstanding_sales?: number | null
    next_marketing_year_net_sales?: number | null
    next_marketing_year_outstanding_sales?: number | null
  }

  export type us_export_salesUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    week_ending?: DateTimeFieldUpdateOperationsInput | Date | string
    weekly_exports?: NullableIntFieldUpdateOperationsInput | number | null
    accumulated_exports?: NullableIntFieldUpdateOperationsInput | number | null
    net_sales?: NullableIntFieldUpdateOperationsInput | number | null
    outstanding_sales?: NullableIntFieldUpdateOperationsInput | number | null
    next_marketing_year_net_sales?: NullableIntFieldUpdateOperationsInput | number | null
    next_marketing_year_outstanding_sales?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type us_export_salesUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    week_ending?: DateTimeFieldUpdateOperationsInput | Date | string
    weekly_exports?: NullableIntFieldUpdateOperationsInput | number | null
    accumulated_exports?: NullableIntFieldUpdateOperationsInput | number | null
    net_sales?: NullableIntFieldUpdateOperationsInput | number | null
    outstanding_sales?: NullableIntFieldUpdateOperationsInput | number | null
    next_marketing_year_net_sales?: NullableIntFieldUpdateOperationsInput | number | null
    next_marketing_year_outstanding_sales?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type commitment_of_tradersCreateInput = {
    record_id?: string
    calendar_year: number
    crop_year: string
    month: string
    week?: number | null
    report_date_as_dd_mm_yyyy: Date | string
    open_interest_all?: number | null
    producer_merchant_net?: number | null
    swap_position_net?: number | null
    managed_money_long?: number | null
    managed_money_short?: number | null
    managed_money_net?: number | null
    other_reportables_net?: number | null
    total_reportables_net?: number | null
    non_reportables_net?: number | null
    specs_net?: number | null
  }

  export type commitment_of_tradersUncheckedCreateInput = {
    record_id?: string
    calendar_year: number
    crop_year: string
    month: string
    week?: number | null
    report_date_as_dd_mm_yyyy: Date | string
    open_interest_all?: number | null
    producer_merchant_net?: number | null
    swap_position_net?: number | null
    managed_money_long?: number | null
    managed_money_short?: number | null
    managed_money_net?: number | null
    other_reportables_net?: number | null
    total_reportables_net?: number | null
    non_reportables_net?: number | null
    specs_net?: number | null
  }

  export type commitment_of_tradersUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    calendar_year?: IntFieldUpdateOperationsInput | number
    crop_year?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    week?: NullableIntFieldUpdateOperationsInput | number | null
    report_date_as_dd_mm_yyyy?: DateTimeFieldUpdateOperationsInput | Date | string
    open_interest_all?: NullableIntFieldUpdateOperationsInput | number | null
    producer_merchant_net?: NullableIntFieldUpdateOperationsInput | number | null
    swap_position_net?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_long?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_short?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_net?: NullableIntFieldUpdateOperationsInput | number | null
    other_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    total_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    non_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    specs_net?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type commitment_of_tradersUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    calendar_year?: IntFieldUpdateOperationsInput | number
    crop_year?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    week?: NullableIntFieldUpdateOperationsInput | number | null
    report_date_as_dd_mm_yyyy?: DateTimeFieldUpdateOperationsInput | Date | string
    open_interest_all?: NullableIntFieldUpdateOperationsInput | number | null
    producer_merchant_net?: NullableIntFieldUpdateOperationsInput | number | null
    swap_position_net?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_long?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_short?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_net?: NullableIntFieldUpdateOperationsInput | number | null
    other_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    total_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    non_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    specs_net?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type commitment_of_tradersCreateManyInput = {
    record_id?: string
    calendar_year: number
    crop_year: string
    month: string
    week?: number | null
    report_date_as_dd_mm_yyyy: Date | string
    open_interest_all?: number | null
    producer_merchant_net?: number | null
    swap_position_net?: number | null
    managed_money_long?: number | null
    managed_money_short?: number | null
    managed_money_net?: number | null
    other_reportables_net?: number | null
    total_reportables_net?: number | null
    non_reportables_net?: number | null
    specs_net?: number | null
  }

  export type commitment_of_tradersUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    calendar_year?: IntFieldUpdateOperationsInput | number
    crop_year?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    week?: NullableIntFieldUpdateOperationsInput | number | null
    report_date_as_dd_mm_yyyy?: DateTimeFieldUpdateOperationsInput | Date | string
    open_interest_all?: NullableIntFieldUpdateOperationsInput | number | null
    producer_merchant_net?: NullableIntFieldUpdateOperationsInput | number | null
    swap_position_net?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_long?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_short?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_net?: NullableIntFieldUpdateOperationsInput | number | null
    other_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    total_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    non_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    specs_net?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type commitment_of_tradersUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    calendar_year?: IntFieldUpdateOperationsInput | number
    crop_year?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    week?: NullableIntFieldUpdateOperationsInput | number | null
    report_date_as_dd_mm_yyyy?: DateTimeFieldUpdateOperationsInput | Date | string
    open_interest_all?: NullableIntFieldUpdateOperationsInput | number | null
    producer_merchant_net?: NullableIntFieldUpdateOperationsInput | number | null
    swap_position_net?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_long?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_short?: NullableIntFieldUpdateOperationsInput | number | null
    managed_money_net?: NullableIntFieldUpdateOperationsInput | number | null
    other_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    total_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    non_reportables_net?: NullableIntFieldUpdateOperationsInput | number | null
    specs_net?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cotton_on_callCreateInput = {
    record_id?: string
    date: Date | string
    season_week?: number | null
    week: number
    season: string
    october_sales?: number | null
    december_sales?: number | null
    march_sales?: number | null
    may_sales?: number | null
    july_sales?: number | null
    total_on_call_sales?: number | null
    october_purchases?: number | null
    december_purchases?: number | null
    march_purchases?: number | null
    may_purchases?: number | null
    july_purchases?: number | null
    total_on_call_purchases?: number | null
    total_net_u_oc_position?: number | null
    total_net_change?: number | null
  }

  export type cotton_on_callUncheckedCreateInput = {
    record_id?: string
    date: Date | string
    season_week?: number | null
    week: number
    season: string
    october_sales?: number | null
    december_sales?: number | null
    march_sales?: number | null
    may_sales?: number | null
    july_sales?: number | null
    total_on_call_sales?: number | null
    october_purchases?: number | null
    december_purchases?: number | null
    march_purchases?: number | null
    may_purchases?: number | null
    july_purchases?: number | null
    total_on_call_purchases?: number | null
    total_net_u_oc_position?: number | null
    total_net_change?: number | null
  }

  export type cotton_on_callUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    season_week?: NullableIntFieldUpdateOperationsInput | number | null
    week?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    october_sales?: NullableIntFieldUpdateOperationsInput | number | null
    december_sales?: NullableIntFieldUpdateOperationsInput | number | null
    march_sales?: NullableIntFieldUpdateOperationsInput | number | null
    may_sales?: NullableIntFieldUpdateOperationsInput | number | null
    july_sales?: NullableIntFieldUpdateOperationsInput | number | null
    total_on_call_sales?: NullableIntFieldUpdateOperationsInput | number | null
    october_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    december_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    march_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    may_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    july_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    total_on_call_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_u_oc_position?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_change?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cotton_on_callUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    season_week?: NullableIntFieldUpdateOperationsInput | number | null
    week?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    october_sales?: NullableIntFieldUpdateOperationsInput | number | null
    december_sales?: NullableIntFieldUpdateOperationsInput | number | null
    march_sales?: NullableIntFieldUpdateOperationsInput | number | null
    may_sales?: NullableIntFieldUpdateOperationsInput | number | null
    july_sales?: NullableIntFieldUpdateOperationsInput | number | null
    total_on_call_sales?: NullableIntFieldUpdateOperationsInput | number | null
    october_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    december_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    march_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    may_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    july_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    total_on_call_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_u_oc_position?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_change?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cotton_on_callCreateManyInput = {
    record_id?: string
    date: Date | string
    season_week?: number | null
    week: number
    season: string
    october_sales?: number | null
    december_sales?: number | null
    march_sales?: number | null
    may_sales?: number | null
    july_sales?: number | null
    total_on_call_sales?: number | null
    october_purchases?: number | null
    december_purchases?: number | null
    march_purchases?: number | null
    may_purchases?: number | null
    july_purchases?: number | null
    total_on_call_purchases?: number | null
    total_net_u_oc_position?: number | null
    total_net_change?: number | null
  }

  export type cotton_on_callUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    season_week?: NullableIntFieldUpdateOperationsInput | number | null
    week?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    october_sales?: NullableIntFieldUpdateOperationsInput | number | null
    december_sales?: NullableIntFieldUpdateOperationsInput | number | null
    march_sales?: NullableIntFieldUpdateOperationsInput | number | null
    may_sales?: NullableIntFieldUpdateOperationsInput | number | null
    july_sales?: NullableIntFieldUpdateOperationsInput | number | null
    total_on_call_sales?: NullableIntFieldUpdateOperationsInput | number | null
    october_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    december_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    march_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    may_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    july_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    total_on_call_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_u_oc_position?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_change?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cotton_on_callUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    season_week?: NullableIntFieldUpdateOperationsInput | number | null
    week?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    october_sales?: NullableIntFieldUpdateOperationsInput | number | null
    december_sales?: NullableIntFieldUpdateOperationsInput | number | null
    march_sales?: NullableIntFieldUpdateOperationsInput | number | null
    may_sales?: NullableIntFieldUpdateOperationsInput | number | null
    july_sales?: NullableIntFieldUpdateOperationsInput | number | null
    total_on_call_sales?: NullableIntFieldUpdateOperationsInput | number | null
    october_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    december_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    march_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    may_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    july_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    total_on_call_purchases?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_u_oc_position?: NullableIntFieldUpdateOperationsInput | number | null
    total_net_change?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type commentsCreateInput = {
    record_id?: string
    comment: string
    section: string
    date_of_comment: Date | string
    added_by: string
  }

  export type commentsUncheckedCreateInput = {
    record_id?: string
    comment: string
    section: string
    date_of_comment: Date | string
    added_by: string
  }

  export type commentsUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    date_of_comment?: DateTimeFieldUpdateOperationsInput | Date | string
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type commentsUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    date_of_comment?: DateTimeFieldUpdateOperationsInput | Date | string
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type commentsCreateManyInput = {
    record_id?: string
    comment: string
    section: string
    date_of_comment: Date | string
    added_by: string
  }

  export type commentsUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    date_of_comment?: DateTimeFieldUpdateOperationsInput | Date | string
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type commentsUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    date_of_comment?: DateTimeFieldUpdateOperationsInput | Date | string
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type future_contracts_studyCreateInput = {
    record_id?: string
    year: string
    month_of_high?: number | null
    date_of_high?: Date | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    month_of_low?: number | null
    date_of_low?: Date | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    price_range_between_high_and_low?: Decimal | DecimalJsLike | number | string | null
    day_range_between_high_and_low?: Decimal | DecimalJsLike | number | string | null
    inverse?: string | null
    comments?: string | null
  }

  export type future_contracts_studyUncheckedCreateInput = {
    record_id?: string
    year: string
    month_of_high?: number | null
    date_of_high?: Date | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    month_of_low?: number | null
    date_of_low?: Date | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    price_range_between_high_and_low?: Decimal | DecimalJsLike | number | string | null
    day_range_between_high_and_low?: Decimal | DecimalJsLike | number | string | null
    inverse?: string | null
    comments?: string | null
  }

  export type future_contracts_studyUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    month_of_high?: NullableIntFieldUpdateOperationsInput | number | null
    date_of_high?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month_of_low?: NullableIntFieldUpdateOperationsInput | number | null
    date_of_low?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_range_between_high_and_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_and_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inverse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type future_contracts_studyUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    month_of_high?: NullableIntFieldUpdateOperationsInput | number | null
    date_of_high?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month_of_low?: NullableIntFieldUpdateOperationsInput | number | null
    date_of_low?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_range_between_high_and_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_and_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inverse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type future_contracts_studyCreateManyInput = {
    record_id?: string
    year: string
    month_of_high?: number | null
    date_of_high?: Date | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    month_of_low?: number | null
    date_of_low?: Date | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    price_range_between_high_and_low?: Decimal | DecimalJsLike | number | string | null
    day_range_between_high_and_low?: Decimal | DecimalJsLike | number | string | null
    inverse?: string | null
    comments?: string | null
  }

  export type future_contracts_studyUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    month_of_high?: NullableIntFieldUpdateOperationsInput | number | null
    date_of_high?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month_of_low?: NullableIntFieldUpdateOperationsInput | number | null
    date_of_low?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_range_between_high_and_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_and_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inverse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type future_contracts_studyUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    month_of_high?: NullableIntFieldUpdateOperationsInput | number | null
    date_of_high?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month_of_low?: NullableIntFieldUpdateOperationsInput | number | null
    date_of_low?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price_range_between_high_and_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_and_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    inverse?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cotton_contractsCreateInput = {
    record_id?: string
    datetime: Date | string
    contract: string
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    change?: Decimal | DecimalJsLike | number | string | null
    rolling_average_200_day?: Decimal | DecimalJsLike | number | string | null
    rolling_average_100_day?: Decimal | DecimalJsLike | number | string | null
    rolling_average_50_day?: Decimal | DecimalJsLike | number | string | null
  }

  export type cotton_contractsUncheckedCreateInput = {
    record_id?: string
    datetime: Date | string
    contract: string
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    change?: Decimal | DecimalJsLike | number | string | null
    rolling_average_200_day?: Decimal | DecimalJsLike | number | string | null
    rolling_average_100_day?: Decimal | DecimalJsLike | number | string | null
    rolling_average_50_day?: Decimal | DecimalJsLike | number | string | null
  }

  export type cotton_contractsUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    change?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_200_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_100_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_50_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type cotton_contractsUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    change?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_200_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_100_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_50_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type cotton_contractsCreateManyInput = {
    record_id?: string
    datetime: Date | string
    contract: string
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    change?: Decimal | DecimalJsLike | number | string | null
    rolling_average_200_day?: Decimal | DecimalJsLike | number | string | null
    rolling_average_100_day?: Decimal | DecimalJsLike | number | string | null
    rolling_average_50_day?: Decimal | DecimalJsLike | number | string | null
  }

  export type cotton_contractsUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    change?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_200_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_100_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_50_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type cotton_contractsUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: StringFieldUpdateOperationsInput | string
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    change?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_200_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_100_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rolling_average_50_day?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type monthly_indexCreateInput = {
    record_id?: string
    month: string
    year?: number
    inverse_month: string
    probability_rate: string
  }

  export type monthly_indexUncheckedCreateInput = {
    record_id?: string
    month: string
    year?: number
    inverse_month: string
    probability_rate: string
  }

  export type monthly_indexUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    inverse_month?: StringFieldUpdateOperationsInput | string
    probability_rate?: StringFieldUpdateOperationsInput | string
  }

  export type monthly_indexUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    inverse_month?: StringFieldUpdateOperationsInput | string
    probability_rate?: StringFieldUpdateOperationsInput | string
  }

  export type monthly_indexCreateManyInput = {
    record_id?: string
    month: string
    year?: number
    inverse_month: string
    probability_rate: string
  }

  export type monthly_indexUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    inverse_month?: StringFieldUpdateOperationsInput | string
    probability_rate?: StringFieldUpdateOperationsInput | string
  }

  export type monthly_indexUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    inverse_month?: StringFieldUpdateOperationsInput | string
    probability_rate?: StringFieldUpdateOperationsInput | string
  }

  export type seasonal_indexCreateInput = {
    record_id?: string
    season: string
    inverse_year: string
    probability_rate: string
  }

  export type seasonal_indexUncheckedCreateInput = {
    record_id?: string
    season: string
    inverse_year: string
    probability_rate: string
  }

  export type seasonal_indexUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    inverse_year?: StringFieldUpdateOperationsInput | string
    probability_rate?: StringFieldUpdateOperationsInput | string
  }

  export type seasonal_indexUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    inverse_year?: StringFieldUpdateOperationsInput | string
    probability_rate?: StringFieldUpdateOperationsInput | string
  }

  export type seasonal_indexCreateManyInput = {
    record_id?: string
    season: string
    inverse_year: string
    probability_rate: string
  }

  export type seasonal_indexUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    inverse_year?: StringFieldUpdateOperationsInput | string
    probability_rate?: StringFieldUpdateOperationsInput | string
  }

  export type seasonal_indexUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    inverse_year?: StringFieldUpdateOperationsInput | string
    probability_rate?: StringFieldUpdateOperationsInput | string
  }

  export type comparison_chartCreateInput = {
    record_id?: string
    date_of_close: Date | string
    cotton_spot_price?: Decimal | DecimalJsLike | number | string | null
    dollar_basket_spot_price?: Decimal | DecimalJsLike | number | string | null
    crude_oil_spot_price?: Decimal | DecimalJsLike | number | string | null
  }

  export type comparison_chartUncheckedCreateInput = {
    record_id?: string
    date_of_close: Date | string
    cotton_spot_price?: Decimal | DecimalJsLike | number | string | null
    dollar_basket_spot_price?: Decimal | DecimalJsLike | number | string | null
    crude_oil_spot_price?: Decimal | DecimalJsLike | number | string | null
  }

  export type comparison_chartUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_of_close?: DateTimeFieldUpdateOperationsInput | Date | string
    cotton_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dollar_basket_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crude_oil_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type comparison_chartUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_of_close?: DateTimeFieldUpdateOperationsInput | Date | string
    cotton_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dollar_basket_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crude_oil_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type comparison_chartCreateManyInput = {
    record_id?: string
    date_of_close: Date | string
    cotton_spot_price?: Decimal | DecimalJsLike | number | string | null
    dollar_basket_spot_price?: Decimal | DecimalJsLike | number | string | null
    crude_oil_spot_price?: Decimal | DecimalJsLike | number | string | null
  }

  export type comparison_chartUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_of_close?: DateTimeFieldUpdateOperationsInput | Date | string
    cotton_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dollar_basket_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crude_oil_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type comparison_chartUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_of_close?: DateTimeFieldUpdateOperationsInput | Date | string
    cotton_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dollar_basket_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    crude_oil_spot_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type snapshot_strategyCreateInput = {
    record_id?: string
    title_of_snapshot_strategy: string
    image_of_snapshot_strategy?: string | null
    text_of_snapshot_strategy: string
    date_of_snapshot_strategy?: Date | string
    valid?: boolean
    news_type?: string
    impact?: string | null
    added_by?: string
    verified?: boolean
  }

  export type snapshot_strategyUncheckedCreateInput = {
    record_id?: string
    title_of_snapshot_strategy: string
    image_of_snapshot_strategy?: string | null
    text_of_snapshot_strategy: string
    date_of_snapshot_strategy?: Date | string
    valid?: boolean
    news_type?: string
    impact?: string | null
    added_by?: string
    verified?: boolean
  }

  export type snapshot_strategyUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title_of_snapshot_strategy?: StringFieldUpdateOperationsInput | string
    image_of_snapshot_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    text_of_snapshot_strategy?: StringFieldUpdateOperationsInput | string
    date_of_snapshot_strategy?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    news_type?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type snapshot_strategyUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title_of_snapshot_strategy?: StringFieldUpdateOperationsInput | string
    image_of_snapshot_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    text_of_snapshot_strategy?: StringFieldUpdateOperationsInput | string
    date_of_snapshot_strategy?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    news_type?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type snapshot_strategyCreateManyInput = {
    record_id?: string
    title_of_snapshot_strategy: string
    image_of_snapshot_strategy?: string | null
    text_of_snapshot_strategy: string
    date_of_snapshot_strategy?: Date | string
    valid?: boolean
    news_type?: string
    impact?: string | null
    added_by?: string
    verified?: boolean
  }

  export type snapshot_strategyUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title_of_snapshot_strategy?: StringFieldUpdateOperationsInput | string
    image_of_snapshot_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    text_of_snapshot_strategy?: StringFieldUpdateOperationsInput | string
    date_of_snapshot_strategy?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    news_type?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type snapshot_strategyUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title_of_snapshot_strategy?: StringFieldUpdateOperationsInput | string
    image_of_snapshot_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    text_of_snapshot_strategy?: StringFieldUpdateOperationsInput | string
    date_of_snapshot_strategy?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    news_type?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type basis_comparisonCreateInput = {
    record_id?: string
    date_of_basis_report: Date | string
    country: string
    cost_type: string
    contract_december_2023?: number
    contract_december_2024?: number
    added_by?: string
  }

  export type basis_comparisonUncheckedCreateInput = {
    record_id?: string
    date_of_basis_report: Date | string
    country: string
    cost_type: string
    contract_december_2023?: number
    contract_december_2024?: number
    added_by?: string
  }

  export type basis_comparisonUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_of_basis_report?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    cost_type?: StringFieldUpdateOperationsInput | string
    contract_december_2023?: IntFieldUpdateOperationsInput | number
    contract_december_2024?: IntFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type basis_comparisonUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_of_basis_report?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    cost_type?: StringFieldUpdateOperationsInput | string
    contract_december_2023?: IntFieldUpdateOperationsInput | number
    contract_december_2024?: IntFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type basis_comparisonCreateManyInput = {
    record_id?: string
    date_of_basis_report: Date | string
    country: string
    cost_type: string
    contract_december_2023?: number
    contract_december_2024?: number
    added_by?: string
  }

  export type basis_comparisonUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_of_basis_report?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    cost_type?: StringFieldUpdateOperationsInput | string
    contract_december_2023?: IntFieldUpdateOperationsInput | number
    contract_december_2024?: IntFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type basis_comparisonUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_of_basis_report?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    cost_type?: StringFieldUpdateOperationsInput | string
    contract_december_2023?: IntFieldUpdateOperationsInput | number
    contract_december_2024?: IntFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type in_country_newsCreateInput = {
    record_id?: string
    country?: string | null
    image_of_in_country_news?: string | null
    title_of_in_country_news: string
    text_of_in_country_news: string
    date_of_in_country_news: Date | string
    impact?: string | null
    added_by?: string
    verified?: boolean
  }

  export type in_country_newsUncheckedCreateInput = {
    record_id?: string
    country?: string | null
    image_of_in_country_news?: string | null
    title_of_in_country_news: string
    text_of_in_country_news: string
    date_of_in_country_news: Date | string
    impact?: string | null
    added_by?: string
    verified?: boolean
  }

  export type in_country_newsUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    image_of_in_country_news?: NullableStringFieldUpdateOperationsInput | string | null
    title_of_in_country_news?: StringFieldUpdateOperationsInput | string
    text_of_in_country_news?: StringFieldUpdateOperationsInput | string
    date_of_in_country_news?: DateTimeFieldUpdateOperationsInput | Date | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type in_country_newsUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    image_of_in_country_news?: NullableStringFieldUpdateOperationsInput | string | null
    title_of_in_country_news?: StringFieldUpdateOperationsInput | string
    text_of_in_country_news?: StringFieldUpdateOperationsInput | string
    date_of_in_country_news?: DateTimeFieldUpdateOperationsInput | Date | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type in_country_newsCreateManyInput = {
    record_id?: string
    country?: string | null
    image_of_in_country_news?: string | null
    title_of_in_country_news: string
    text_of_in_country_news: string
    date_of_in_country_news: Date | string
    impact?: string | null
    added_by?: string
    verified?: boolean
  }

  export type in_country_newsUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    image_of_in_country_news?: NullableStringFieldUpdateOperationsInput | string | null
    title_of_in_country_news?: StringFieldUpdateOperationsInput | string
    text_of_in_country_news?: StringFieldUpdateOperationsInput | string
    date_of_in_country_news?: DateTimeFieldUpdateOperationsInput | Date | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type in_country_newsUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    image_of_in_country_news?: NullableStringFieldUpdateOperationsInput | string | null
    title_of_in_country_news?: StringFieldUpdateOperationsInput | string
    text_of_in_country_news?: StringFieldUpdateOperationsInput | string
    date_of_in_country_news?: DateTimeFieldUpdateOperationsInput | Date | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sentiment_surveyCreateInput = {
    record_id?: string
    bullish_or_bearish: string
    bullish_or_bearish_value?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    intraday_average_points?: Decimal | DecimalJsLike | number | string | null
    open_interest?: Decimal | DecimalJsLike | number | string | null
    date_of_survey?: Date | string | null
    added_by?: string
  }

  export type sentiment_surveyUncheckedCreateInput = {
    record_id?: string
    bullish_or_bearish: string
    bullish_or_bearish_value?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    intraday_average_points?: Decimal | DecimalJsLike | number | string | null
    open_interest?: Decimal | DecimalJsLike | number | string | null
    date_of_survey?: Date | string | null
    added_by?: string
  }

  export type sentiment_surveyUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    bullish_or_bearish?: StringFieldUpdateOperationsInput | string
    bullish_or_bearish_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    intraday_average_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    open_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_survey?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type sentiment_surveyUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    bullish_or_bearish?: StringFieldUpdateOperationsInput | string
    bullish_or_bearish_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    intraday_average_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    open_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_survey?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type sentiment_surveyCreateManyInput = {
    record_id?: string
    bullish_or_bearish: string
    bullish_or_bearish_value?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    intraday_average_points?: Decimal | DecimalJsLike | number | string | null
    open_interest?: Decimal | DecimalJsLike | number | string | null
    date_of_survey?: Date | string | null
    added_by?: string
  }

  export type sentiment_surveyUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    bullish_or_bearish?: StringFieldUpdateOperationsInput | string
    bullish_or_bearish_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    intraday_average_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    open_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_survey?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type sentiment_surveyUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    bullish_or_bearish?: StringFieldUpdateOperationsInput | string
    bullish_or_bearish_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    intraday_average_points?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    open_interest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_survey?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    added_by?: StringFieldUpdateOperationsInput | string
  }

  export type comparison_charts_with_17_months_yearCreateInput = {
    record_id?: string
    season: string
    low_price?: Decimal | DecimalJsLike | number | string | null
    date_of_low: Date | string
    month_of_low?: number
    calendar_week_of_low?: number
    high_price?: Decimal | DecimalJsLike | number | string | null
    date_of_high: Date | string
    month_of_high?: number
    calendar_week_of_high?: number
    range_between_high_low?: Decimal | DecimalJsLike | number | string | null
    rank_of_price_range?: number
    percentage_rate_to_low?: Decimal | DecimalJsLike | number | string | null
    day_range_between_high_low?: number
    rank_between_high_low?: number
    inverse_season: string
    us_seasonal_inflation?: Decimal | DecimalJsLike | number | string | null
    us_inflation_cumm?: Decimal | DecimalJsLike | number | string | null
    us_interest_rate_mov?: Decimal | DecimalJsLike | number | string | null
    us_interest_cumm?: Decimal | DecimalJsLike | number | string | null
    world_population_cumm?: number
    world_population_mov?: number
    world_acreage?: number
    world_acreage_movement?: number
  }

  export type comparison_charts_with_17_months_yearUncheckedCreateInput = {
    record_id?: string
    season: string
    low_price?: Decimal | DecimalJsLike | number | string | null
    date_of_low: Date | string
    month_of_low?: number
    calendar_week_of_low?: number
    high_price?: Decimal | DecimalJsLike | number | string | null
    date_of_high: Date | string
    month_of_high?: number
    calendar_week_of_high?: number
    range_between_high_low?: Decimal | DecimalJsLike | number | string | null
    rank_of_price_range?: number
    percentage_rate_to_low?: Decimal | DecimalJsLike | number | string | null
    day_range_between_high_low?: number
    rank_between_high_low?: number
    inverse_season: string
    us_seasonal_inflation?: Decimal | DecimalJsLike | number | string | null
    us_inflation_cumm?: Decimal | DecimalJsLike | number | string | null
    us_interest_rate_mov?: Decimal | DecimalJsLike | number | string | null
    us_interest_cumm?: Decimal | DecimalJsLike | number | string | null
    world_population_cumm?: number
    world_population_mov?: number
    world_acreage?: number
    world_acreage_movement?: number
  }

  export type comparison_charts_with_17_months_yearUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_low?: DateTimeFieldUpdateOperationsInput | Date | string
    month_of_low?: IntFieldUpdateOperationsInput | number
    calendar_week_of_low?: IntFieldUpdateOperationsInput | number
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_high?: DateTimeFieldUpdateOperationsInput | Date | string
    month_of_high?: IntFieldUpdateOperationsInput | number
    calendar_week_of_high?: IntFieldUpdateOperationsInput | number
    range_between_high_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank_of_price_range?: IntFieldUpdateOperationsInput | number
    percentage_rate_to_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_low?: IntFieldUpdateOperationsInput | number
    rank_between_high_low?: IntFieldUpdateOperationsInput | number
    inverse_season?: StringFieldUpdateOperationsInput | string
    us_seasonal_inflation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_inflation_cumm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_interest_rate_mov?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_interest_cumm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    world_population_cumm?: IntFieldUpdateOperationsInput | number
    world_population_mov?: IntFieldUpdateOperationsInput | number
    world_acreage?: IntFieldUpdateOperationsInput | number
    world_acreage_movement?: IntFieldUpdateOperationsInput | number
  }

  export type comparison_charts_with_17_months_yearUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_low?: DateTimeFieldUpdateOperationsInput | Date | string
    month_of_low?: IntFieldUpdateOperationsInput | number
    calendar_week_of_low?: IntFieldUpdateOperationsInput | number
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_high?: DateTimeFieldUpdateOperationsInput | Date | string
    month_of_high?: IntFieldUpdateOperationsInput | number
    calendar_week_of_high?: IntFieldUpdateOperationsInput | number
    range_between_high_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank_of_price_range?: IntFieldUpdateOperationsInput | number
    percentage_rate_to_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_low?: IntFieldUpdateOperationsInput | number
    rank_between_high_low?: IntFieldUpdateOperationsInput | number
    inverse_season?: StringFieldUpdateOperationsInput | string
    us_seasonal_inflation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_inflation_cumm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_interest_rate_mov?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_interest_cumm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    world_population_cumm?: IntFieldUpdateOperationsInput | number
    world_population_mov?: IntFieldUpdateOperationsInput | number
    world_acreage?: IntFieldUpdateOperationsInput | number
    world_acreage_movement?: IntFieldUpdateOperationsInput | number
  }

  export type comparison_charts_with_17_months_yearCreateManyInput = {
    record_id?: string
    season: string
    low_price?: Decimal | DecimalJsLike | number | string | null
    date_of_low: Date | string
    month_of_low?: number
    calendar_week_of_low?: number
    high_price?: Decimal | DecimalJsLike | number | string | null
    date_of_high: Date | string
    month_of_high?: number
    calendar_week_of_high?: number
    range_between_high_low?: Decimal | DecimalJsLike | number | string | null
    rank_of_price_range?: number
    percentage_rate_to_low?: Decimal | DecimalJsLike | number | string | null
    day_range_between_high_low?: number
    rank_between_high_low?: number
    inverse_season: string
    us_seasonal_inflation?: Decimal | DecimalJsLike | number | string | null
    us_inflation_cumm?: Decimal | DecimalJsLike | number | string | null
    us_interest_rate_mov?: Decimal | DecimalJsLike | number | string | null
    us_interest_cumm?: Decimal | DecimalJsLike | number | string | null
    world_population_cumm?: number
    world_population_mov?: number
    world_acreage?: number
    world_acreage_movement?: number
  }

  export type comparison_charts_with_17_months_yearUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_low?: DateTimeFieldUpdateOperationsInput | Date | string
    month_of_low?: IntFieldUpdateOperationsInput | number
    calendar_week_of_low?: IntFieldUpdateOperationsInput | number
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_high?: DateTimeFieldUpdateOperationsInput | Date | string
    month_of_high?: IntFieldUpdateOperationsInput | number
    calendar_week_of_high?: IntFieldUpdateOperationsInput | number
    range_between_high_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank_of_price_range?: IntFieldUpdateOperationsInput | number
    percentage_rate_to_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_low?: IntFieldUpdateOperationsInput | number
    rank_between_high_low?: IntFieldUpdateOperationsInput | number
    inverse_season?: StringFieldUpdateOperationsInput | string
    us_seasonal_inflation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_inflation_cumm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_interest_rate_mov?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_interest_cumm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    world_population_cumm?: IntFieldUpdateOperationsInput | number
    world_population_mov?: IntFieldUpdateOperationsInput | number
    world_acreage?: IntFieldUpdateOperationsInput | number
    world_acreage_movement?: IntFieldUpdateOperationsInput | number
  }

  export type comparison_charts_with_17_months_yearUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    low_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_low?: DateTimeFieldUpdateOperationsInput | Date | string
    month_of_low?: IntFieldUpdateOperationsInput | number
    calendar_week_of_low?: IntFieldUpdateOperationsInput | number
    high_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date_of_high?: DateTimeFieldUpdateOperationsInput | Date | string
    month_of_high?: IntFieldUpdateOperationsInput | number
    calendar_week_of_high?: IntFieldUpdateOperationsInput | number
    range_between_high_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank_of_price_range?: IntFieldUpdateOperationsInput | number
    percentage_rate_to_low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    day_range_between_high_low?: IntFieldUpdateOperationsInput | number
    rank_between_high_low?: IntFieldUpdateOperationsInput | number
    inverse_season?: StringFieldUpdateOperationsInput | string
    us_seasonal_inflation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_inflation_cumm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_interest_rate_mov?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    us_interest_cumm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    world_population_cumm?: IntFieldUpdateOperationsInput | number
    world_population_mov?: IntFieldUpdateOperationsInput | number
    world_acreage?: IntFieldUpdateOperationsInput | number
    world_acreage_movement?: IntFieldUpdateOperationsInput | number
  }

  export type Temporary_StorageCreateInput = {
    record_id?: string
    data: string
    created_at?: Date | string
  }

  export type Temporary_StorageUncheckedCreateInput = {
    record_id?: string
    data: string
    created_at?: Date | string
  }

  export type Temporary_StorageUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Temporary_StorageUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Temporary_StorageCreateManyInput = {
    record_id?: string
    data: string
    created_at?: Date | string
  }

  export type Temporary_StorageUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Temporary_StorageUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Report_TemplatesCreateInput = {
    record_id?: string
    name: string
    data: string
    company: string
    created_at?: Date | string
  }

  export type Report_TemplatesUncheckedCreateInput = {
    record_id?: string
    name: string
    data: string
    company: string
    created_at?: Date | string
  }

  export type Report_TemplatesUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Report_TemplatesUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Report_TemplatesCreateManyInput = {
    record_id?: string
    name: string
    data: string
    company: string
    created_at?: Date | string
  }

  export type Report_TemplatesUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Report_TemplatesUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Dashboard_TemplatesCreateInput = {
    record_id?: string
    data: string
    company: string
    created_at?: Date | string
  }

  export type Dashboard_TemplatesUncheckedCreateInput = {
    record_id?: string
    data: string
    company: string
    created_at?: Date | string
  }

  export type Dashboard_TemplatesUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Dashboard_TemplatesUncheckedUpdateInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Dashboard_TemplatesCreateManyInput = {
    record_id?: string
    data: string
    company: string
    created_at?: Date | string
  }

  export type Dashboard_TemplatesUpdateManyMutationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Dashboard_TemplatesUncheckedUpdateManyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    company: string
    user_id?: string | null
    filetype: string
    linkedType: string
    fileName?: string | null
    createdAt?: Date | string | null
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    company: string
    user_id?: string | null
    filetype: string
    linkedType: string
    fileName?: string | null
    createdAt?: Date | string | null
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: StringFieldUpdateOperationsInput | string
    linkedType?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: StringFieldUpdateOperationsInput | string
    linkedType?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentCreateManyInput = {
    id?: string
    company: string
    user_id?: string | null
    filetype: string
    linkedType: string
    fileName?: string | null
    createdAt?: Date | string | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: StringFieldUpdateOperationsInput | string
    linkedType?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    filetype?: StringFieldUpdateOperationsInput | string
    linkedType?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ExampleCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExampleMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExampleMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type Producer_production_estimatesListRelationFilter = {
    every?: producer_production_estimatesWhereInput
    some?: producer_production_estimatesWhereInput
    none?: producer_production_estimatesWhereInput
  }

  export type Producer_cost_estimatesListRelationFilter = {
    every?: producer_cost_estimatesWhereInput
    some?: producer_cost_estimatesWhereInput
    none?: producer_cost_estimatesWhereInput
  }

  export type Producer_commercialisation_estimatesListRelationFilter = {
    every?: producer_commercialisation_estimatesWhereInput
    some?: producer_commercialisation_estimatesWhereInput
    none?: producer_commercialisation_estimatesWhereInput
  }

  export type Strategy_logListRelationFilter = {
    every?: strategy_logWhereInput
    some?: strategy_logWhereInput
    none?: strategy_logWhereInput
  }

  export type Fixed_cottonListRelationFilter = {
    every?: fixed_cottonWhereInput
    some?: fixed_cottonWhereInput
    none?: fixed_cottonWhereInput
  }

  export type Unfixed_cottonListRelationFilter = {
    every?: unfixed_cottonWhereInput
    some?: unfixed_cottonWhereInput
    none?: unfixed_cottonWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type producer_production_estimatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type producer_cost_estimatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type producer_commercialisation_estimatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type strategy_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fixed_cottonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type unfixed_cottonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    record_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tier?: SortOrder
    access_to_marketplace?: SortOrder
    created_at?: SortOrder
    company_manager_id?: SortOrder
    macrovesta_manager_id?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    record_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tier?: SortOrder
    access_to_marketplace?: SortOrder
    created_at?: SortOrder
    company_manager_id?: SortOrder
    macrovesta_manager_id?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    record_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    tier?: SortOrder
    access_to_marketplace?: SortOrder
    created_at?: SortOrder
    company_manager_id?: SortOrder
    macrovesta_manager_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type CompanyListRelationFilter = {
    every?: CompanyWhereInput
    some?: CompanyWhereInput
    none?: CompanyWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type MarketplaceAgentListRelationFilter = {
    every?: MarketplaceAgentWhereInput
    some?: MarketplaceAgentWhereInput
    none?: MarketplaceAgentWhereInput
  }

  export type MarketplaceBuyerListRelationFilter = {
    every?: MarketplaceBuyerWhereInput
    some?: MarketplaceBuyerWhereInput
    none?: MarketplaceBuyerWhereInput
  }

  export type MarketplaceListRelationFilter = {
    every?: MarketplaceWhereInput
    some?: MarketplaceWhereInput
    none?: MarketplaceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceAgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceBuyerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    company_id?: SortOrder
    selected_company_id?: SortOrder
    submittedSurvey?: SortOrder
    image?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    company_id?: SortOrder
    selected_company_id?: SortOrder
    submittedSurvey?: SortOrder
    image?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    company_id?: SortOrder
    selected_company_id?: SortOrder
    submittedSurvey?: SortOrder
    image?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NotificationCountOrderByAggregateInput = {
    record_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    is_read?: SortOrder
    user_id?: SortOrder
    date_created?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    record_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    is_read?: SortOrder
    user_id?: SortOrder
    date_created?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    record_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    is_read?: SortOrder
    user_id?: SortOrder
    date_created?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type MarketplaceCountOrderByAggregateInput = {
    record_id?: SortOrder
    product?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    price_usd?: SortOrder
    added_by?: SortOrder
    hvi_file?: SortOrder
    shipment?: SortOrder
    payment_terms?: SortOrder
    date_created?: SortOrder
    expiry_date?: SortOrder
    reserved_by?: SortOrder
  }

  export type MarketplaceAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price_usd?: SortOrder
  }

  export type MarketplaceMaxOrderByAggregateInput = {
    record_id?: SortOrder
    product?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    price_usd?: SortOrder
    added_by?: SortOrder
    hvi_file?: SortOrder
    shipment?: SortOrder
    payment_terms?: SortOrder
    date_created?: SortOrder
    expiry_date?: SortOrder
    reserved_by?: SortOrder
  }

  export type MarketplaceMinOrderByAggregateInput = {
    record_id?: SortOrder
    product?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    quality?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    price_usd?: SortOrder
    added_by?: SortOrder
    hvi_file?: SortOrder
    shipment?: SortOrder
    payment_terms?: SortOrder
    date_created?: SortOrder
    expiry_date?: SortOrder
    reserved_by?: SortOrder
  }

  export type MarketplaceSumOrderByAggregateInput = {
    quantity?: SortOrder
    price_usd?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type MarketplaceRelationFilter = {
    is?: MarketplaceWhereInput | null
    isNot?: MarketplaceWhereInput | null
  }

  export type MarketplaceAgentCountOrderByAggregateInput = {
    record_id?: SortOrder
    marketplace_id?: SortOrder
    agent_id?: SortOrder
    date_created?: SortOrder
  }

  export type MarketplaceAgentMaxOrderByAggregateInput = {
    record_id?: SortOrder
    marketplace_id?: SortOrder
    agent_id?: SortOrder
    date_created?: SortOrder
  }

  export type MarketplaceAgentMinOrderByAggregateInput = {
    record_id?: SortOrder
    marketplace_id?: SortOrder
    agent_id?: SortOrder
    date_created?: SortOrder
  }

  export type MarketplaceBuyerCountOrderByAggregateInput = {
    record_id?: SortOrder
    marketplace_id?: SortOrder
    buyer_id?: SortOrder
    date_created?: SortOrder
  }

  export type MarketplaceBuyerMaxOrderByAggregateInput = {
    record_id?: SortOrder
    marketplace_id?: SortOrder
    buyer_id?: SortOrder
    date_created?: SortOrder
  }

  export type MarketplaceBuyerMinOrderByAggregateInput = {
    record_id?: SortOrder
    marketplace_id?: SortOrder
    buyer_id?: SortOrder
    date_created?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type a_indexCountOrderByAggregateInput = {
    record_id?: SortOrder
    date?: SortOrder
    a_index?: SortOrder
    ice_highest_open_interest_17_months?: SortOrder
    cc_index?: SortOrder
    mcx?: SortOrder
    cepea?: SortOrder
  }

  export type a_indexAvgOrderByAggregateInput = {
    a_index?: SortOrder
    ice_highest_open_interest_17_months?: SortOrder
    cc_index?: SortOrder
    mcx?: SortOrder
    cepea?: SortOrder
  }

  export type a_indexMaxOrderByAggregateInput = {
    record_id?: SortOrder
    date?: SortOrder
    a_index?: SortOrder
    ice_highest_open_interest_17_months?: SortOrder
    cc_index?: SortOrder
    mcx?: SortOrder
    cepea?: SortOrder
  }

  export type a_indexMinOrderByAggregateInput = {
    record_id?: SortOrder
    date?: SortOrder
    a_index?: SortOrder
    ice_highest_open_interest_17_months?: SortOrder
    cc_index?: SortOrder
    mcx?: SortOrder
    cepea?: SortOrder
  }

  export type a_indexSumOrderByAggregateInput = {
    a_index?: SortOrder
    ice_highest_open_interest_17_months?: SortOrder
    cc_index?: SortOrder
    mcx?: SortOrder
    cepea?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type fixed_cottonCountOrderByAggregateInput = {
    company_id?: SortOrder
    record_id?: SortOrder
    contract_number?: SortOrder
    futures_month?: SortOrder
    basis?: SortOrder
    fixed_price_without_basis?: SortOrder
    amount_fixed?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type fixed_cottonAvgOrderByAggregateInput = {
    basis?: SortOrder
    fixed_price_without_basis?: SortOrder
    amount_fixed?: SortOrder
  }

  export type fixed_cottonMaxOrderByAggregateInput = {
    company_id?: SortOrder
    record_id?: SortOrder
    contract_number?: SortOrder
    futures_month?: SortOrder
    basis?: SortOrder
    fixed_price_without_basis?: SortOrder
    amount_fixed?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type fixed_cottonMinOrderByAggregateInput = {
    company_id?: SortOrder
    record_id?: SortOrder
    contract_number?: SortOrder
    futures_month?: SortOrder
    basis?: SortOrder
    fixed_price_without_basis?: SortOrder
    amount_fixed?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type fixed_cottonSumOrderByAggregateInput = {
    basis?: SortOrder
    fixed_price_without_basis?: SortOrder
    amount_fixed?: SortOrder
  }

  export type unfixed_cottonCountOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    contract_number?: SortOrder
    futures_month?: SortOrder
    basis?: SortOrder
    fix_by?: SortOrder
    total_amount?: SortOrder
    amount_remaining?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type unfixed_cottonAvgOrderByAggregateInput = {
    basis?: SortOrder
    total_amount?: SortOrder
    amount_remaining?: SortOrder
  }

  export type unfixed_cottonMaxOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    contract_number?: SortOrder
    futures_month?: SortOrder
    basis?: SortOrder
    fix_by?: SortOrder
    total_amount?: SortOrder
    amount_remaining?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type unfixed_cottonMinOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    contract_number?: SortOrder
    futures_month?: SortOrder
    basis?: SortOrder
    fix_by?: SortOrder
    total_amount?: SortOrder
    amount_remaining?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type unfixed_cottonSumOrderByAggregateInput = {
    basis?: SortOrder
    total_amount?: SortOrder
    amount_remaining?: SortOrder
  }

  export type strategy_logCountOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    text?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type strategy_logMaxOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    text?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type strategy_logMinOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    text?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type producer_production_estimatesCountOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    production_estimate?: SortOrder
    yield_estimate?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type producer_production_estimatesAvgOrderByAggregateInput = {
    production_estimate?: SortOrder
    yield_estimate?: SortOrder
  }

  export type producer_production_estimatesMaxOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    production_estimate?: SortOrder
    yield_estimate?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type producer_production_estimatesMinOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    production_estimate?: SortOrder
    yield_estimate?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type producer_production_estimatesSumOrderByAggregateInput = {
    production_estimate?: SortOrder
    yield_estimate?: SortOrder
  }

  export type producer_cost_estimatesCountOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    cost_estimate_dollar_per_hectare?: SortOrder
    cost_estimate_cent_per_pound?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type producer_cost_estimatesAvgOrderByAggregateInput = {
    cost_estimate_dollar_per_hectare?: SortOrder
    cost_estimate_cent_per_pound?: SortOrder
  }

  export type producer_cost_estimatesMaxOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    cost_estimate_dollar_per_hectare?: SortOrder
    cost_estimate_cent_per_pound?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type producer_cost_estimatesMinOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    cost_estimate_dollar_per_hectare?: SortOrder
    cost_estimate_cent_per_pound?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type producer_cost_estimatesSumOrderByAggregateInput = {
    cost_estimate_dollar_per_hectare?: SortOrder
    cost_estimate_cent_per_pound?: SortOrder
  }

  export type producer_commercialisation_estimatesCountOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    percentage_sold?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type producer_commercialisation_estimatesAvgOrderByAggregateInput = {
    percentage_sold?: SortOrder
  }

  export type producer_commercialisation_estimatesMaxOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    percentage_sold?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type producer_commercialisation_estimatesMinOrderByAggregateInput = {
    record_id?: SortOrder
    company_id?: SortOrder
    season?: SortOrder
    percentage_sold?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type producer_commercialisation_estimatesSumOrderByAggregateInput = {
    percentage_sold?: SortOrder
  }

  export type bug_reportCountOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    text?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type bug_reportMaxOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    text?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type bug_reportMinOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    text?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type suggestionsCountOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    text?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type suggestionsMaxOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    text?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type suggestionsMinOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    text?: SortOrder
    added_by?: SortOrder
    date_created?: SortOrder
  }

  export type upcoming_changesCountOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    text?: SortOrder
    image?: SortOrder
    planned_released_date?: SortOrder
  }

  export type upcoming_changesMaxOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    text?: SortOrder
    image?: SortOrder
    planned_released_date?: SortOrder
  }

  export type upcoming_changesMinOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    text?: SortOrder
    image?: SortOrder
    planned_released_date?: SortOrder
  }

  export type conclusionCountOrderByAggregateInput = {
    record_id?: SortOrder
    text?: SortOrder
    date_created?: SortOrder
  }

  export type conclusionMaxOrderByAggregateInput = {
    record_id?: SortOrder
    text?: SortOrder
    date_created?: SortOrder
  }

  export type conclusionMinOrderByAggregateInput = {
    record_id?: SortOrder
    text?: SortOrder
    date_created?: SortOrder
  }

  export type Demo_RequestsCountOrderByAggregateInput = {
    record_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    company_name?: SortOrder
    company_type?: SortOrder
    preferred_date?: SortOrder
    preferred_time?: SortOrder
    date_created?: SortOrder
  }

  export type Demo_RequestsMaxOrderByAggregateInput = {
    record_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    company_name?: SortOrder
    company_type?: SortOrder
    preferred_date?: SortOrder
    preferred_time?: SortOrder
    date_created?: SortOrder
  }

  export type Demo_RequestsMinOrderByAggregateInput = {
    record_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    company_name?: SortOrder
    company_type?: SortOrder
    preferred_date?: SortOrder
    preferred_time?: SortOrder
    date_created?: SortOrder
  }

  export type General_InquiriesCountOrderByAggregateInput = {
    record_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrder
    message?: SortOrder
    date_created?: SortOrder
  }

  export type General_InquiriesMaxOrderByAggregateInput = {
    record_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrder
    message?: SortOrder
    date_created?: SortOrder
  }

  export type General_InquiriesMinOrderByAggregateInput = {
    record_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrder
    message?: SortOrder
    date_created?: SortOrder
  }

  export type things_to_reviewCountOrderByAggregateInput = {
    record_id?: SortOrder
    added_by?: SortOrder
    table?: SortOrder
    type?: SortOrder
    thing_id?: SortOrder
    information?: SortOrder
    date_created?: SortOrder
  }

  export type things_to_reviewMaxOrderByAggregateInput = {
    record_id?: SortOrder
    added_by?: SortOrder
    table?: SortOrder
    type?: SortOrder
    thing_id?: SortOrder
    information?: SortOrder
    date_created?: SortOrder
  }

  export type things_to_reviewMinOrderByAggregateInput = {
    record_id?: SortOrder
    added_by?: SortOrder
    table?: SortOrder
    type?: SortOrder
    thing_id?: SortOrder
    information?: SortOrder
    date_created?: SortOrder
  }

  export type External_LinksCountOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    language?: SortOrder
    date_created?: SortOrder
  }

  export type External_LinksMaxOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    language?: SortOrder
    date_created?: SortOrder
  }

  export type External_LinksMinOrderByAggregateInput = {
    record_id?: SortOrder
    type?: SortOrder
    url?: SortOrder
    language?: SortOrder
    date_created?: SortOrder
  }

  export type supply_and_demandCountOrderByAggregateInput = {
    record_id?: SortOrder
    date?: SortOrder
    season?: SortOrder
    country?: SortOrder
    beginning_stocks_usda?: SortOrder
    beginning_stocks_eap?: SortOrder
    production_usda?: SortOrder
    production_eap?: SortOrder
    imports_usda?: SortOrder
    imports_eap?: SortOrder
    domestic_use_usda?: SortOrder
    domestic_use_eap?: SortOrder
    exports_usda?: SortOrder
    exports_eap?: SortOrder
    ending_stocks_usda?: SortOrder
    ending_stocks_eap?: SortOrder
    projected?: SortOrder
  }

  export type supply_and_demandAvgOrderByAggregateInput = {
    beginning_stocks_usda?: SortOrder
    beginning_stocks_eap?: SortOrder
    production_usda?: SortOrder
    production_eap?: SortOrder
    imports_usda?: SortOrder
    imports_eap?: SortOrder
    domestic_use_usda?: SortOrder
    domestic_use_eap?: SortOrder
    exports_usda?: SortOrder
    exports_eap?: SortOrder
    ending_stocks_usda?: SortOrder
    ending_stocks_eap?: SortOrder
  }

  export type supply_and_demandMaxOrderByAggregateInput = {
    record_id?: SortOrder
    date?: SortOrder
    season?: SortOrder
    country?: SortOrder
    beginning_stocks_usda?: SortOrder
    beginning_stocks_eap?: SortOrder
    production_usda?: SortOrder
    production_eap?: SortOrder
    imports_usda?: SortOrder
    imports_eap?: SortOrder
    domestic_use_usda?: SortOrder
    domestic_use_eap?: SortOrder
    exports_usda?: SortOrder
    exports_eap?: SortOrder
    ending_stocks_usda?: SortOrder
    ending_stocks_eap?: SortOrder
    projected?: SortOrder
  }

  export type supply_and_demandMinOrderByAggregateInput = {
    record_id?: SortOrder
    date?: SortOrder
    season?: SortOrder
    country?: SortOrder
    beginning_stocks_usda?: SortOrder
    beginning_stocks_eap?: SortOrder
    production_usda?: SortOrder
    production_eap?: SortOrder
    imports_usda?: SortOrder
    imports_eap?: SortOrder
    domestic_use_usda?: SortOrder
    domestic_use_eap?: SortOrder
    exports_usda?: SortOrder
    exports_eap?: SortOrder
    ending_stocks_usda?: SortOrder
    ending_stocks_eap?: SortOrder
    projected?: SortOrder
  }

  export type supply_and_demandSumOrderByAggregateInput = {
    beginning_stocks_usda?: SortOrder
    beginning_stocks_eap?: SortOrder
    production_usda?: SortOrder
    production_eap?: SortOrder
    imports_usda?: SortOrder
    imports_eap?: SortOrder
    domestic_use_usda?: SortOrder
    domestic_use_eap?: SortOrder
    exports_usda?: SortOrder
    exports_eap?: SortOrder
    ending_stocks_usda?: SortOrder
    ending_stocks_eap?: SortOrder
  }

  export type us_export_salesCountOrderByAggregateInput = {
    record_id?: SortOrder
    week_ending?: SortOrder
    weekly_exports?: SortOrder
    accumulated_exports?: SortOrder
    net_sales?: SortOrder
    outstanding_sales?: SortOrder
    next_marketing_year_net_sales?: SortOrder
    next_marketing_year_outstanding_sales?: SortOrder
  }

  export type us_export_salesAvgOrderByAggregateInput = {
    weekly_exports?: SortOrder
    accumulated_exports?: SortOrder
    net_sales?: SortOrder
    outstanding_sales?: SortOrder
    next_marketing_year_net_sales?: SortOrder
    next_marketing_year_outstanding_sales?: SortOrder
  }

  export type us_export_salesMaxOrderByAggregateInput = {
    record_id?: SortOrder
    week_ending?: SortOrder
    weekly_exports?: SortOrder
    accumulated_exports?: SortOrder
    net_sales?: SortOrder
    outstanding_sales?: SortOrder
    next_marketing_year_net_sales?: SortOrder
    next_marketing_year_outstanding_sales?: SortOrder
  }

  export type us_export_salesMinOrderByAggregateInput = {
    record_id?: SortOrder
    week_ending?: SortOrder
    weekly_exports?: SortOrder
    accumulated_exports?: SortOrder
    net_sales?: SortOrder
    outstanding_sales?: SortOrder
    next_marketing_year_net_sales?: SortOrder
    next_marketing_year_outstanding_sales?: SortOrder
  }

  export type us_export_salesSumOrderByAggregateInput = {
    weekly_exports?: SortOrder
    accumulated_exports?: SortOrder
    net_sales?: SortOrder
    outstanding_sales?: SortOrder
    next_marketing_year_net_sales?: SortOrder
    next_marketing_year_outstanding_sales?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type commitment_of_tradersCountOrderByAggregateInput = {
    record_id?: SortOrder
    calendar_year?: SortOrder
    crop_year?: SortOrder
    month?: SortOrder
    week?: SortOrder
    report_date_as_dd_mm_yyyy?: SortOrder
    open_interest_all?: SortOrder
    producer_merchant_net?: SortOrder
    swap_position_net?: SortOrder
    managed_money_long?: SortOrder
    managed_money_short?: SortOrder
    managed_money_net?: SortOrder
    other_reportables_net?: SortOrder
    total_reportables_net?: SortOrder
    non_reportables_net?: SortOrder
    specs_net?: SortOrder
  }

  export type commitment_of_tradersAvgOrderByAggregateInput = {
    calendar_year?: SortOrder
    week?: SortOrder
    open_interest_all?: SortOrder
    producer_merchant_net?: SortOrder
    swap_position_net?: SortOrder
    managed_money_long?: SortOrder
    managed_money_short?: SortOrder
    managed_money_net?: SortOrder
    other_reportables_net?: SortOrder
    total_reportables_net?: SortOrder
    non_reportables_net?: SortOrder
    specs_net?: SortOrder
  }

  export type commitment_of_tradersMaxOrderByAggregateInput = {
    record_id?: SortOrder
    calendar_year?: SortOrder
    crop_year?: SortOrder
    month?: SortOrder
    week?: SortOrder
    report_date_as_dd_mm_yyyy?: SortOrder
    open_interest_all?: SortOrder
    producer_merchant_net?: SortOrder
    swap_position_net?: SortOrder
    managed_money_long?: SortOrder
    managed_money_short?: SortOrder
    managed_money_net?: SortOrder
    other_reportables_net?: SortOrder
    total_reportables_net?: SortOrder
    non_reportables_net?: SortOrder
    specs_net?: SortOrder
  }

  export type commitment_of_tradersMinOrderByAggregateInput = {
    record_id?: SortOrder
    calendar_year?: SortOrder
    crop_year?: SortOrder
    month?: SortOrder
    week?: SortOrder
    report_date_as_dd_mm_yyyy?: SortOrder
    open_interest_all?: SortOrder
    producer_merchant_net?: SortOrder
    swap_position_net?: SortOrder
    managed_money_long?: SortOrder
    managed_money_short?: SortOrder
    managed_money_net?: SortOrder
    other_reportables_net?: SortOrder
    total_reportables_net?: SortOrder
    non_reportables_net?: SortOrder
    specs_net?: SortOrder
  }

  export type commitment_of_tradersSumOrderByAggregateInput = {
    calendar_year?: SortOrder
    week?: SortOrder
    open_interest_all?: SortOrder
    producer_merchant_net?: SortOrder
    swap_position_net?: SortOrder
    managed_money_long?: SortOrder
    managed_money_short?: SortOrder
    managed_money_net?: SortOrder
    other_reportables_net?: SortOrder
    total_reportables_net?: SortOrder
    non_reportables_net?: SortOrder
    specs_net?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type cotton_on_callCountOrderByAggregateInput = {
    record_id?: SortOrder
    date?: SortOrder
    season_week?: SortOrder
    week?: SortOrder
    season?: SortOrder
    october_sales?: SortOrder
    december_sales?: SortOrder
    march_sales?: SortOrder
    may_sales?: SortOrder
    july_sales?: SortOrder
    total_on_call_sales?: SortOrder
    october_purchases?: SortOrder
    december_purchases?: SortOrder
    march_purchases?: SortOrder
    may_purchases?: SortOrder
    july_purchases?: SortOrder
    total_on_call_purchases?: SortOrder
    total_net_u_oc_position?: SortOrder
    total_net_change?: SortOrder
  }

  export type cotton_on_callAvgOrderByAggregateInput = {
    season_week?: SortOrder
    week?: SortOrder
    october_sales?: SortOrder
    december_sales?: SortOrder
    march_sales?: SortOrder
    may_sales?: SortOrder
    july_sales?: SortOrder
    total_on_call_sales?: SortOrder
    october_purchases?: SortOrder
    december_purchases?: SortOrder
    march_purchases?: SortOrder
    may_purchases?: SortOrder
    july_purchases?: SortOrder
    total_on_call_purchases?: SortOrder
    total_net_u_oc_position?: SortOrder
    total_net_change?: SortOrder
  }

  export type cotton_on_callMaxOrderByAggregateInput = {
    record_id?: SortOrder
    date?: SortOrder
    season_week?: SortOrder
    week?: SortOrder
    season?: SortOrder
    october_sales?: SortOrder
    december_sales?: SortOrder
    march_sales?: SortOrder
    may_sales?: SortOrder
    july_sales?: SortOrder
    total_on_call_sales?: SortOrder
    october_purchases?: SortOrder
    december_purchases?: SortOrder
    march_purchases?: SortOrder
    may_purchases?: SortOrder
    july_purchases?: SortOrder
    total_on_call_purchases?: SortOrder
    total_net_u_oc_position?: SortOrder
    total_net_change?: SortOrder
  }

  export type cotton_on_callMinOrderByAggregateInput = {
    record_id?: SortOrder
    date?: SortOrder
    season_week?: SortOrder
    week?: SortOrder
    season?: SortOrder
    october_sales?: SortOrder
    december_sales?: SortOrder
    march_sales?: SortOrder
    may_sales?: SortOrder
    july_sales?: SortOrder
    total_on_call_sales?: SortOrder
    october_purchases?: SortOrder
    december_purchases?: SortOrder
    march_purchases?: SortOrder
    may_purchases?: SortOrder
    july_purchases?: SortOrder
    total_on_call_purchases?: SortOrder
    total_net_u_oc_position?: SortOrder
    total_net_change?: SortOrder
  }

  export type cotton_on_callSumOrderByAggregateInput = {
    season_week?: SortOrder
    week?: SortOrder
    october_sales?: SortOrder
    december_sales?: SortOrder
    march_sales?: SortOrder
    may_sales?: SortOrder
    july_sales?: SortOrder
    total_on_call_sales?: SortOrder
    october_purchases?: SortOrder
    december_purchases?: SortOrder
    march_purchases?: SortOrder
    may_purchases?: SortOrder
    july_purchases?: SortOrder
    total_on_call_purchases?: SortOrder
    total_net_u_oc_position?: SortOrder
    total_net_change?: SortOrder
  }

  export type commentsCountOrderByAggregateInput = {
    record_id?: SortOrder
    comment?: SortOrder
    section?: SortOrder
    date_of_comment?: SortOrder
    added_by?: SortOrder
  }

  export type commentsMaxOrderByAggregateInput = {
    record_id?: SortOrder
    comment?: SortOrder
    section?: SortOrder
    date_of_comment?: SortOrder
    added_by?: SortOrder
  }

  export type commentsMinOrderByAggregateInput = {
    record_id?: SortOrder
    comment?: SortOrder
    section?: SortOrder
    date_of_comment?: SortOrder
    added_by?: SortOrder
  }

  export type future_contracts_studyCountOrderByAggregateInput = {
    record_id?: SortOrder
    year?: SortOrder
    month_of_high?: SortOrder
    date_of_high?: SortOrder
    high?: SortOrder
    month_of_low?: SortOrder
    date_of_low?: SortOrder
    low?: SortOrder
    price_range_between_high_and_low?: SortOrder
    day_range_between_high_and_low?: SortOrder
    inverse?: SortOrder
    comments?: SortOrder
  }

  export type future_contracts_studyAvgOrderByAggregateInput = {
    month_of_high?: SortOrder
    high?: SortOrder
    month_of_low?: SortOrder
    low?: SortOrder
    price_range_between_high_and_low?: SortOrder
    day_range_between_high_and_low?: SortOrder
  }

  export type future_contracts_studyMaxOrderByAggregateInput = {
    record_id?: SortOrder
    year?: SortOrder
    month_of_high?: SortOrder
    date_of_high?: SortOrder
    high?: SortOrder
    month_of_low?: SortOrder
    date_of_low?: SortOrder
    low?: SortOrder
    price_range_between_high_and_low?: SortOrder
    day_range_between_high_and_low?: SortOrder
    inverse?: SortOrder
    comments?: SortOrder
  }

  export type future_contracts_studyMinOrderByAggregateInput = {
    record_id?: SortOrder
    year?: SortOrder
    month_of_high?: SortOrder
    date_of_high?: SortOrder
    high?: SortOrder
    month_of_low?: SortOrder
    date_of_low?: SortOrder
    low?: SortOrder
    price_range_between_high_and_low?: SortOrder
    day_range_between_high_and_low?: SortOrder
    inverse?: SortOrder
    comments?: SortOrder
  }

  export type future_contracts_studySumOrderByAggregateInput = {
    month_of_high?: SortOrder
    high?: SortOrder
    month_of_low?: SortOrder
    low?: SortOrder
    price_range_between_high_and_low?: SortOrder
    day_range_between_high_and_low?: SortOrder
  }

  export type cotton_contractsCountOrderByAggregateInput = {
    record_id?: SortOrder
    datetime?: SortOrder
    contract?: SortOrder
    high?: SortOrder
    low?: SortOrder
    open?: SortOrder
    close?: SortOrder
    change?: SortOrder
    rolling_average_200_day?: SortOrder
    rolling_average_100_day?: SortOrder
    rolling_average_50_day?: SortOrder
  }

  export type cotton_contractsAvgOrderByAggregateInput = {
    high?: SortOrder
    low?: SortOrder
    open?: SortOrder
    close?: SortOrder
    change?: SortOrder
    rolling_average_200_day?: SortOrder
    rolling_average_100_day?: SortOrder
    rolling_average_50_day?: SortOrder
  }

  export type cotton_contractsMaxOrderByAggregateInput = {
    record_id?: SortOrder
    datetime?: SortOrder
    contract?: SortOrder
    high?: SortOrder
    low?: SortOrder
    open?: SortOrder
    close?: SortOrder
    change?: SortOrder
    rolling_average_200_day?: SortOrder
    rolling_average_100_day?: SortOrder
    rolling_average_50_day?: SortOrder
  }

  export type cotton_contractsMinOrderByAggregateInput = {
    record_id?: SortOrder
    datetime?: SortOrder
    contract?: SortOrder
    high?: SortOrder
    low?: SortOrder
    open?: SortOrder
    close?: SortOrder
    change?: SortOrder
    rolling_average_200_day?: SortOrder
    rolling_average_100_day?: SortOrder
    rolling_average_50_day?: SortOrder
  }

  export type cotton_contractsSumOrderByAggregateInput = {
    high?: SortOrder
    low?: SortOrder
    open?: SortOrder
    close?: SortOrder
    change?: SortOrder
    rolling_average_200_day?: SortOrder
    rolling_average_100_day?: SortOrder
    rolling_average_50_day?: SortOrder
  }

  export type monthly_indexCountOrderByAggregateInput = {
    record_id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    inverse_month?: SortOrder
    probability_rate?: SortOrder
  }

  export type monthly_indexAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type monthly_indexMaxOrderByAggregateInput = {
    record_id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    inverse_month?: SortOrder
    probability_rate?: SortOrder
  }

  export type monthly_indexMinOrderByAggregateInput = {
    record_id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    inverse_month?: SortOrder
    probability_rate?: SortOrder
  }

  export type monthly_indexSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type seasonal_indexCountOrderByAggregateInput = {
    record_id?: SortOrder
    season?: SortOrder
    inverse_year?: SortOrder
    probability_rate?: SortOrder
  }

  export type seasonal_indexMaxOrderByAggregateInput = {
    record_id?: SortOrder
    season?: SortOrder
    inverse_year?: SortOrder
    probability_rate?: SortOrder
  }

  export type seasonal_indexMinOrderByAggregateInput = {
    record_id?: SortOrder
    season?: SortOrder
    inverse_year?: SortOrder
    probability_rate?: SortOrder
  }

  export type comparison_chartCountOrderByAggregateInput = {
    record_id?: SortOrder
    date_of_close?: SortOrder
    cotton_spot_price?: SortOrder
    dollar_basket_spot_price?: SortOrder
    crude_oil_spot_price?: SortOrder
  }

  export type comparison_chartAvgOrderByAggregateInput = {
    cotton_spot_price?: SortOrder
    dollar_basket_spot_price?: SortOrder
    crude_oil_spot_price?: SortOrder
  }

  export type comparison_chartMaxOrderByAggregateInput = {
    record_id?: SortOrder
    date_of_close?: SortOrder
    cotton_spot_price?: SortOrder
    dollar_basket_spot_price?: SortOrder
    crude_oil_spot_price?: SortOrder
  }

  export type comparison_chartMinOrderByAggregateInput = {
    record_id?: SortOrder
    date_of_close?: SortOrder
    cotton_spot_price?: SortOrder
    dollar_basket_spot_price?: SortOrder
    crude_oil_spot_price?: SortOrder
  }

  export type comparison_chartSumOrderByAggregateInput = {
    cotton_spot_price?: SortOrder
    dollar_basket_spot_price?: SortOrder
    crude_oil_spot_price?: SortOrder
  }

  export type snapshot_strategyCountOrderByAggregateInput = {
    record_id?: SortOrder
    title_of_snapshot_strategy?: SortOrder
    image_of_snapshot_strategy?: SortOrder
    text_of_snapshot_strategy?: SortOrder
    date_of_snapshot_strategy?: SortOrder
    valid?: SortOrder
    news_type?: SortOrder
    impact?: SortOrder
    added_by?: SortOrder
    verified?: SortOrder
  }

  export type snapshot_strategyMaxOrderByAggregateInput = {
    record_id?: SortOrder
    title_of_snapshot_strategy?: SortOrder
    image_of_snapshot_strategy?: SortOrder
    text_of_snapshot_strategy?: SortOrder
    date_of_snapshot_strategy?: SortOrder
    valid?: SortOrder
    news_type?: SortOrder
    impact?: SortOrder
    added_by?: SortOrder
    verified?: SortOrder
  }

  export type snapshot_strategyMinOrderByAggregateInput = {
    record_id?: SortOrder
    title_of_snapshot_strategy?: SortOrder
    image_of_snapshot_strategy?: SortOrder
    text_of_snapshot_strategy?: SortOrder
    date_of_snapshot_strategy?: SortOrder
    valid?: SortOrder
    news_type?: SortOrder
    impact?: SortOrder
    added_by?: SortOrder
    verified?: SortOrder
  }

  export type basis_comparisonCountOrderByAggregateInput = {
    record_id?: SortOrder
    date_of_basis_report?: SortOrder
    country?: SortOrder
    cost_type?: SortOrder
    contract_december_2023?: SortOrder
    contract_december_2024?: SortOrder
    added_by?: SortOrder
  }

  export type basis_comparisonAvgOrderByAggregateInput = {
    contract_december_2023?: SortOrder
    contract_december_2024?: SortOrder
  }

  export type basis_comparisonMaxOrderByAggregateInput = {
    record_id?: SortOrder
    date_of_basis_report?: SortOrder
    country?: SortOrder
    cost_type?: SortOrder
    contract_december_2023?: SortOrder
    contract_december_2024?: SortOrder
    added_by?: SortOrder
  }

  export type basis_comparisonMinOrderByAggregateInput = {
    record_id?: SortOrder
    date_of_basis_report?: SortOrder
    country?: SortOrder
    cost_type?: SortOrder
    contract_december_2023?: SortOrder
    contract_december_2024?: SortOrder
    added_by?: SortOrder
  }

  export type basis_comparisonSumOrderByAggregateInput = {
    contract_december_2023?: SortOrder
    contract_december_2024?: SortOrder
  }

  export type in_country_newsCountOrderByAggregateInput = {
    record_id?: SortOrder
    country?: SortOrder
    image_of_in_country_news?: SortOrder
    title_of_in_country_news?: SortOrder
    text_of_in_country_news?: SortOrder
    date_of_in_country_news?: SortOrder
    impact?: SortOrder
    added_by?: SortOrder
    verified?: SortOrder
  }

  export type in_country_newsMaxOrderByAggregateInput = {
    record_id?: SortOrder
    country?: SortOrder
    image_of_in_country_news?: SortOrder
    title_of_in_country_news?: SortOrder
    text_of_in_country_news?: SortOrder
    date_of_in_country_news?: SortOrder
    impact?: SortOrder
    added_by?: SortOrder
    verified?: SortOrder
  }

  export type in_country_newsMinOrderByAggregateInput = {
    record_id?: SortOrder
    country?: SortOrder
    image_of_in_country_news?: SortOrder
    title_of_in_country_news?: SortOrder
    text_of_in_country_news?: SortOrder
    date_of_in_country_news?: SortOrder
    impact?: SortOrder
    added_by?: SortOrder
    verified?: SortOrder
  }

  export type sentiment_surveyCountOrderByAggregateInput = {
    record_id?: SortOrder
    bullish_or_bearish?: SortOrder
    bullish_or_bearish_value?: SortOrder
    high?: SortOrder
    low?: SortOrder
    intraday_average_points?: SortOrder
    open_interest?: SortOrder
    date_of_survey?: SortOrder
    added_by?: SortOrder
  }

  export type sentiment_surveyAvgOrderByAggregateInput = {
    bullish_or_bearish_value?: SortOrder
    high?: SortOrder
    low?: SortOrder
    intraday_average_points?: SortOrder
    open_interest?: SortOrder
  }

  export type sentiment_surveyMaxOrderByAggregateInput = {
    record_id?: SortOrder
    bullish_or_bearish?: SortOrder
    bullish_or_bearish_value?: SortOrder
    high?: SortOrder
    low?: SortOrder
    intraday_average_points?: SortOrder
    open_interest?: SortOrder
    date_of_survey?: SortOrder
    added_by?: SortOrder
  }

  export type sentiment_surveyMinOrderByAggregateInput = {
    record_id?: SortOrder
    bullish_or_bearish?: SortOrder
    bullish_or_bearish_value?: SortOrder
    high?: SortOrder
    low?: SortOrder
    intraday_average_points?: SortOrder
    open_interest?: SortOrder
    date_of_survey?: SortOrder
    added_by?: SortOrder
  }

  export type sentiment_surveySumOrderByAggregateInput = {
    bullish_or_bearish_value?: SortOrder
    high?: SortOrder
    low?: SortOrder
    intraday_average_points?: SortOrder
    open_interest?: SortOrder
  }

  export type comparison_charts_with_17_months_yearCountOrderByAggregateInput = {
    record_id?: SortOrder
    season?: SortOrder
    low_price?: SortOrder
    date_of_low?: SortOrder
    month_of_low?: SortOrder
    calendar_week_of_low?: SortOrder
    high_price?: SortOrder
    date_of_high?: SortOrder
    month_of_high?: SortOrder
    calendar_week_of_high?: SortOrder
    range_between_high_low?: SortOrder
    rank_of_price_range?: SortOrder
    percentage_rate_to_low?: SortOrder
    day_range_between_high_low?: SortOrder
    rank_between_high_low?: SortOrder
    inverse_season?: SortOrder
    us_seasonal_inflation?: SortOrder
    us_inflation_cumm?: SortOrder
    us_interest_rate_mov?: SortOrder
    us_interest_cumm?: SortOrder
    world_population_cumm?: SortOrder
    world_population_mov?: SortOrder
    world_acreage?: SortOrder
    world_acreage_movement?: SortOrder
  }

  export type comparison_charts_with_17_months_yearAvgOrderByAggregateInput = {
    low_price?: SortOrder
    month_of_low?: SortOrder
    calendar_week_of_low?: SortOrder
    high_price?: SortOrder
    month_of_high?: SortOrder
    calendar_week_of_high?: SortOrder
    range_between_high_low?: SortOrder
    rank_of_price_range?: SortOrder
    percentage_rate_to_low?: SortOrder
    day_range_between_high_low?: SortOrder
    rank_between_high_low?: SortOrder
    us_seasonal_inflation?: SortOrder
    us_inflation_cumm?: SortOrder
    us_interest_rate_mov?: SortOrder
    us_interest_cumm?: SortOrder
    world_population_cumm?: SortOrder
    world_population_mov?: SortOrder
    world_acreage?: SortOrder
    world_acreage_movement?: SortOrder
  }

  export type comparison_charts_with_17_months_yearMaxOrderByAggregateInput = {
    record_id?: SortOrder
    season?: SortOrder
    low_price?: SortOrder
    date_of_low?: SortOrder
    month_of_low?: SortOrder
    calendar_week_of_low?: SortOrder
    high_price?: SortOrder
    date_of_high?: SortOrder
    month_of_high?: SortOrder
    calendar_week_of_high?: SortOrder
    range_between_high_low?: SortOrder
    rank_of_price_range?: SortOrder
    percentage_rate_to_low?: SortOrder
    day_range_between_high_low?: SortOrder
    rank_between_high_low?: SortOrder
    inverse_season?: SortOrder
    us_seasonal_inflation?: SortOrder
    us_inflation_cumm?: SortOrder
    us_interest_rate_mov?: SortOrder
    us_interest_cumm?: SortOrder
    world_population_cumm?: SortOrder
    world_population_mov?: SortOrder
    world_acreage?: SortOrder
    world_acreage_movement?: SortOrder
  }

  export type comparison_charts_with_17_months_yearMinOrderByAggregateInput = {
    record_id?: SortOrder
    season?: SortOrder
    low_price?: SortOrder
    date_of_low?: SortOrder
    month_of_low?: SortOrder
    calendar_week_of_low?: SortOrder
    high_price?: SortOrder
    date_of_high?: SortOrder
    month_of_high?: SortOrder
    calendar_week_of_high?: SortOrder
    range_between_high_low?: SortOrder
    rank_of_price_range?: SortOrder
    percentage_rate_to_low?: SortOrder
    day_range_between_high_low?: SortOrder
    rank_between_high_low?: SortOrder
    inverse_season?: SortOrder
    us_seasonal_inflation?: SortOrder
    us_inflation_cumm?: SortOrder
    us_interest_rate_mov?: SortOrder
    us_interest_cumm?: SortOrder
    world_population_cumm?: SortOrder
    world_population_mov?: SortOrder
    world_acreage?: SortOrder
    world_acreage_movement?: SortOrder
  }

  export type comparison_charts_with_17_months_yearSumOrderByAggregateInput = {
    low_price?: SortOrder
    month_of_low?: SortOrder
    calendar_week_of_low?: SortOrder
    high_price?: SortOrder
    month_of_high?: SortOrder
    calendar_week_of_high?: SortOrder
    range_between_high_low?: SortOrder
    rank_of_price_range?: SortOrder
    percentage_rate_to_low?: SortOrder
    day_range_between_high_low?: SortOrder
    rank_between_high_low?: SortOrder
    us_seasonal_inflation?: SortOrder
    us_inflation_cumm?: SortOrder
    us_interest_rate_mov?: SortOrder
    us_interest_cumm?: SortOrder
    world_population_cumm?: SortOrder
    world_population_mov?: SortOrder
    world_acreage?: SortOrder
    world_acreage_movement?: SortOrder
  }

  export type Temporary_StorageCountOrderByAggregateInput = {
    record_id?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
  }

  export type Temporary_StorageMaxOrderByAggregateInput = {
    record_id?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
  }

  export type Temporary_StorageMinOrderByAggregateInput = {
    record_id?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
  }

  export type Report_TemplatesCountOrderByAggregateInput = {
    record_id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    company?: SortOrder
    created_at?: SortOrder
  }

  export type Report_TemplatesMaxOrderByAggregateInput = {
    record_id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    company?: SortOrder
    created_at?: SortOrder
  }

  export type Report_TemplatesMinOrderByAggregateInput = {
    record_id?: SortOrder
    name?: SortOrder
    data?: SortOrder
    company?: SortOrder
    created_at?: SortOrder
  }

  export type Dashboard_TemplatesCountOrderByAggregateInput = {
    record_id?: SortOrder
    data?: SortOrder
    company?: SortOrder
    created_at?: SortOrder
  }

  export type Dashboard_TemplatesMaxOrderByAggregateInput = {
    record_id?: SortOrder
    data?: SortOrder
    company?: SortOrder
    created_at?: SortOrder
  }

  export type Dashboard_TemplatesMinOrderByAggregateInput = {
    record_id?: SortOrder
    data?: SortOrder
    company?: SortOrder
    created_at?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    user_id?: SortOrder
    filetype?: SortOrder
    linkedType?: SortOrder
    fileName?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    user_id?: SortOrder
    filetype?: SortOrder
    linkedType?: SortOrder
    fileName?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    user_id?: SortOrder
    filetype?: SortOrder
    linkedType?: SortOrder
    fileName?: SortOrder
    createdAt?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutCompany_managingInput = {
    create?: XOR<UserCreateWithoutCompany_managingInput, UserUncheckedCreateWithoutCompany_managingInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompany_managingInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMacrovesta_managingInput = {
    create?: XOR<UserCreateWithoutMacrovesta_managingInput, UserUncheckedCreateWithoutMacrovesta_managingInput>
    connectOrCreate?: UserCreateOrConnectWithoutMacrovesta_managingInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutSelected_companyInput = {
    create?: XOR<Enumerable<UserCreateWithoutSelected_companyInput>, Enumerable<UserUncheckedCreateWithoutSelected_companyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSelected_companyInput>
    createMany?: UserCreateManySelected_companyInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type producer_production_estimatesCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<producer_production_estimatesCreateWithoutCompanyInput>, Enumerable<producer_production_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_production_estimatesCreateOrConnectWithoutCompanyInput>
    createMany?: producer_production_estimatesCreateManyCompanyInputEnvelope
    connect?: Enumerable<producer_production_estimatesWhereUniqueInput>
  }

  export type producer_cost_estimatesCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<producer_cost_estimatesCreateWithoutCompanyInput>, Enumerable<producer_cost_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_cost_estimatesCreateOrConnectWithoutCompanyInput>
    createMany?: producer_cost_estimatesCreateManyCompanyInputEnvelope
    connect?: Enumerable<producer_cost_estimatesWhereUniqueInput>
  }

  export type producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<producer_commercialisation_estimatesCreateWithoutCompanyInput>, Enumerable<producer_commercialisation_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_commercialisation_estimatesCreateOrConnectWithoutCompanyInput>
    createMany?: producer_commercialisation_estimatesCreateManyCompanyInputEnvelope
    connect?: Enumerable<producer_commercialisation_estimatesWhereUniqueInput>
  }

  export type strategy_logCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<strategy_logCreateWithoutCompanyInput>, Enumerable<strategy_logUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<strategy_logCreateOrConnectWithoutCompanyInput>
    createMany?: strategy_logCreateManyCompanyInputEnvelope
    connect?: Enumerable<strategy_logWhereUniqueInput>
  }

  export type fixed_cottonCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<fixed_cottonCreateWithoutCompanyInput>, Enumerable<fixed_cottonUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<fixed_cottonCreateOrConnectWithoutCompanyInput>
    createMany?: fixed_cottonCreateManyCompanyInputEnvelope
    connect?: Enumerable<fixed_cottonWhereUniqueInput>
  }

  export type unfixed_cottonCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<unfixed_cottonCreateWithoutCompanyInput>, Enumerable<unfixed_cottonUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<unfixed_cottonCreateOrConnectWithoutCompanyInput>
    createMany?: unfixed_cottonCreateManyCompanyInputEnvelope
    connect?: Enumerable<unfixed_cottonWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutSelected_companyInput = {
    create?: XOR<Enumerable<UserCreateWithoutSelected_companyInput>, Enumerable<UserUncheckedCreateWithoutSelected_companyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSelected_companyInput>
    createMany?: UserCreateManySelected_companyInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<producer_production_estimatesCreateWithoutCompanyInput>, Enumerable<producer_production_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_production_estimatesCreateOrConnectWithoutCompanyInput>
    createMany?: producer_production_estimatesCreateManyCompanyInputEnvelope
    connect?: Enumerable<producer_production_estimatesWhereUniqueInput>
  }

  export type producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<producer_cost_estimatesCreateWithoutCompanyInput>, Enumerable<producer_cost_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_cost_estimatesCreateOrConnectWithoutCompanyInput>
    createMany?: producer_cost_estimatesCreateManyCompanyInputEnvelope
    connect?: Enumerable<producer_cost_estimatesWhereUniqueInput>
  }

  export type producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<producer_commercialisation_estimatesCreateWithoutCompanyInput>, Enumerable<producer_commercialisation_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_commercialisation_estimatesCreateOrConnectWithoutCompanyInput>
    createMany?: producer_commercialisation_estimatesCreateManyCompanyInputEnvelope
    connect?: Enumerable<producer_commercialisation_estimatesWhereUniqueInput>
  }

  export type strategy_logUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<strategy_logCreateWithoutCompanyInput>, Enumerable<strategy_logUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<strategy_logCreateOrConnectWithoutCompanyInput>
    createMany?: strategy_logCreateManyCompanyInputEnvelope
    connect?: Enumerable<strategy_logWhereUniqueInput>
  }

  export type fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<fixed_cottonCreateWithoutCompanyInput>, Enumerable<fixed_cottonUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<fixed_cottonCreateOrConnectWithoutCompanyInput>
    createMany?: fixed_cottonCreateManyCompanyInputEnvelope
    connect?: Enumerable<fixed_cottonWhereUniqueInput>
  }

  export type unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<unfixed_cottonCreateWithoutCompanyInput>, Enumerable<unfixed_cottonUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<unfixed_cottonCreateOrConnectWithoutCompanyInput>
    createMany?: unfixed_cottonCreateManyCompanyInputEnvelope
    connect?: Enumerable<unfixed_cottonWhereUniqueInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneWithoutCompany_managingNestedInput = {
    create?: XOR<UserCreateWithoutCompany_managingInput, UserUncheckedCreateWithoutCompany_managingInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompany_managingInput
    upsert?: UserUpsertWithoutCompany_managingInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCompany_managingInput, UserUncheckedUpdateWithoutCompany_managingInput>
  }

  export type UserUpdateOneWithoutMacrovesta_managingNestedInput = {
    create?: XOR<UserCreateWithoutMacrovesta_managingInput, UserUncheckedCreateWithoutMacrovesta_managingInput>
    connectOrCreate?: UserCreateOrConnectWithoutMacrovesta_managingInput
    upsert?: UserUpsertWithoutMacrovesta_managingInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMacrovesta_managingInput, UserUncheckedUpdateWithoutMacrovesta_managingInput>
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUpdateManyWithoutSelected_companyNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutSelected_companyInput>, Enumerable<UserUncheckedCreateWithoutSelected_companyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSelected_companyInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutSelected_companyInput>
    createMany?: UserCreateManySelected_companyInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutSelected_companyInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutSelected_companyInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type producer_production_estimatesUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<producer_production_estimatesCreateWithoutCompanyInput>, Enumerable<producer_production_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_production_estimatesCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<producer_production_estimatesUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: producer_production_estimatesCreateManyCompanyInputEnvelope
    set?: Enumerable<producer_production_estimatesWhereUniqueInput>
    disconnect?: Enumerable<producer_production_estimatesWhereUniqueInput>
    delete?: Enumerable<producer_production_estimatesWhereUniqueInput>
    connect?: Enumerable<producer_production_estimatesWhereUniqueInput>
    update?: Enumerable<producer_production_estimatesUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<producer_production_estimatesUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<producer_production_estimatesScalarWhereInput>
  }

  export type producer_cost_estimatesUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<producer_cost_estimatesCreateWithoutCompanyInput>, Enumerable<producer_cost_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_cost_estimatesCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<producer_cost_estimatesUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: producer_cost_estimatesCreateManyCompanyInputEnvelope
    set?: Enumerable<producer_cost_estimatesWhereUniqueInput>
    disconnect?: Enumerable<producer_cost_estimatesWhereUniqueInput>
    delete?: Enumerable<producer_cost_estimatesWhereUniqueInput>
    connect?: Enumerable<producer_cost_estimatesWhereUniqueInput>
    update?: Enumerable<producer_cost_estimatesUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<producer_cost_estimatesUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<producer_cost_estimatesScalarWhereInput>
  }

  export type producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<producer_commercialisation_estimatesCreateWithoutCompanyInput>, Enumerable<producer_commercialisation_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_commercialisation_estimatesCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<producer_commercialisation_estimatesUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: producer_commercialisation_estimatesCreateManyCompanyInputEnvelope
    set?: Enumerable<producer_commercialisation_estimatesWhereUniqueInput>
    disconnect?: Enumerable<producer_commercialisation_estimatesWhereUniqueInput>
    delete?: Enumerable<producer_commercialisation_estimatesWhereUniqueInput>
    connect?: Enumerable<producer_commercialisation_estimatesWhereUniqueInput>
    update?: Enumerable<producer_commercialisation_estimatesUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<producer_commercialisation_estimatesUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<producer_commercialisation_estimatesScalarWhereInput>
  }

  export type strategy_logUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<strategy_logCreateWithoutCompanyInput>, Enumerable<strategy_logUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<strategy_logCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<strategy_logUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: strategy_logCreateManyCompanyInputEnvelope
    set?: Enumerable<strategy_logWhereUniqueInput>
    disconnect?: Enumerable<strategy_logWhereUniqueInput>
    delete?: Enumerable<strategy_logWhereUniqueInput>
    connect?: Enumerable<strategy_logWhereUniqueInput>
    update?: Enumerable<strategy_logUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<strategy_logUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<strategy_logScalarWhereInput>
  }

  export type fixed_cottonUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<fixed_cottonCreateWithoutCompanyInput>, Enumerable<fixed_cottonUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<fixed_cottonCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<fixed_cottonUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: fixed_cottonCreateManyCompanyInputEnvelope
    set?: Enumerable<fixed_cottonWhereUniqueInput>
    disconnect?: Enumerable<fixed_cottonWhereUniqueInput>
    delete?: Enumerable<fixed_cottonWhereUniqueInput>
    connect?: Enumerable<fixed_cottonWhereUniqueInput>
    update?: Enumerable<fixed_cottonUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<fixed_cottonUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<fixed_cottonScalarWhereInput>
  }

  export type unfixed_cottonUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<unfixed_cottonCreateWithoutCompanyInput>, Enumerable<unfixed_cottonUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<unfixed_cottonCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<unfixed_cottonUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: unfixed_cottonCreateManyCompanyInputEnvelope
    set?: Enumerable<unfixed_cottonWhereUniqueInput>
    disconnect?: Enumerable<unfixed_cottonWhereUniqueInput>
    delete?: Enumerable<unfixed_cottonWhereUniqueInput>
    connect?: Enumerable<unfixed_cottonWhereUniqueInput>
    update?: Enumerable<unfixed_cottonUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<unfixed_cottonUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<unfixed_cottonScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutSelected_companyNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutSelected_companyInput>, Enumerable<UserUncheckedCreateWithoutSelected_companyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSelected_companyInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutSelected_companyInput>
    createMany?: UserCreateManySelected_companyInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutSelected_companyInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutSelected_companyInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<producer_production_estimatesCreateWithoutCompanyInput>, Enumerable<producer_production_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_production_estimatesCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<producer_production_estimatesUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: producer_production_estimatesCreateManyCompanyInputEnvelope
    set?: Enumerable<producer_production_estimatesWhereUniqueInput>
    disconnect?: Enumerable<producer_production_estimatesWhereUniqueInput>
    delete?: Enumerable<producer_production_estimatesWhereUniqueInput>
    connect?: Enumerable<producer_production_estimatesWhereUniqueInput>
    update?: Enumerable<producer_production_estimatesUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<producer_production_estimatesUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<producer_production_estimatesScalarWhereInput>
  }

  export type producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<producer_cost_estimatesCreateWithoutCompanyInput>, Enumerable<producer_cost_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_cost_estimatesCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<producer_cost_estimatesUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: producer_cost_estimatesCreateManyCompanyInputEnvelope
    set?: Enumerable<producer_cost_estimatesWhereUniqueInput>
    disconnect?: Enumerable<producer_cost_estimatesWhereUniqueInput>
    delete?: Enumerable<producer_cost_estimatesWhereUniqueInput>
    connect?: Enumerable<producer_cost_estimatesWhereUniqueInput>
    update?: Enumerable<producer_cost_estimatesUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<producer_cost_estimatesUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<producer_cost_estimatesScalarWhereInput>
  }

  export type producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<producer_commercialisation_estimatesCreateWithoutCompanyInput>, Enumerable<producer_commercialisation_estimatesUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<producer_commercialisation_estimatesCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<producer_commercialisation_estimatesUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: producer_commercialisation_estimatesCreateManyCompanyInputEnvelope
    set?: Enumerable<producer_commercialisation_estimatesWhereUniqueInput>
    disconnect?: Enumerable<producer_commercialisation_estimatesWhereUniqueInput>
    delete?: Enumerable<producer_commercialisation_estimatesWhereUniqueInput>
    connect?: Enumerable<producer_commercialisation_estimatesWhereUniqueInput>
    update?: Enumerable<producer_commercialisation_estimatesUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<producer_commercialisation_estimatesUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<producer_commercialisation_estimatesScalarWhereInput>
  }

  export type strategy_logUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<strategy_logCreateWithoutCompanyInput>, Enumerable<strategy_logUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<strategy_logCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<strategy_logUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: strategy_logCreateManyCompanyInputEnvelope
    set?: Enumerable<strategy_logWhereUniqueInput>
    disconnect?: Enumerable<strategy_logWhereUniqueInput>
    delete?: Enumerable<strategy_logWhereUniqueInput>
    connect?: Enumerable<strategy_logWhereUniqueInput>
    update?: Enumerable<strategy_logUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<strategy_logUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<strategy_logScalarWhereInput>
  }

  export type fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<fixed_cottonCreateWithoutCompanyInput>, Enumerable<fixed_cottonUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<fixed_cottonCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<fixed_cottonUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: fixed_cottonCreateManyCompanyInputEnvelope
    set?: Enumerable<fixed_cottonWhereUniqueInput>
    disconnect?: Enumerable<fixed_cottonWhereUniqueInput>
    delete?: Enumerable<fixed_cottonWhereUniqueInput>
    connect?: Enumerable<fixed_cottonWhereUniqueInput>
    update?: Enumerable<fixed_cottonUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<fixed_cottonUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<fixed_cottonScalarWhereInput>
  }

  export type unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<unfixed_cottonCreateWithoutCompanyInput>, Enumerable<unfixed_cottonUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<unfixed_cottonCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<unfixed_cottonUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: unfixed_cottonCreateManyCompanyInputEnvelope
    set?: Enumerable<unfixed_cottonWhereUniqueInput>
    disconnect?: Enumerable<unfixed_cottonWhereUniqueInput>
    delete?: Enumerable<unfixed_cottonWhereUniqueInput>
    connect?: Enumerable<unfixed_cottonWhereUniqueInput>
    update?: Enumerable<unfixed_cottonUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<unfixed_cottonUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<unfixed_cottonScalarWhereInput>
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutSelected_usersInput = {
    create?: XOR<CompanyCreateWithoutSelected_usersInput, CompanyUncheckedCreateWithoutSelected_usersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSelected_usersInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutCompany_managerInput = {
    create?: XOR<CompanyCreateWithoutCompany_managerInput, CompanyUncheckedCreateWithoutCompany_managerInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompany_managerInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyCreateNestedManyWithoutMacrovesta_managerInput = {
    create?: XOR<Enumerable<CompanyCreateWithoutMacrovesta_managerInput>, Enumerable<CompanyUncheckedCreateWithoutMacrovesta_managerInput>>
    connectOrCreate?: Enumerable<CompanyCreateOrConnectWithoutMacrovesta_managerInput>
    createMany?: CompanyCreateManyMacrovesta_managerInputEnvelope
    connect?: Enumerable<CompanyWhereUniqueInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type MarketplaceAgentCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<MarketplaceAgentCreateWithoutAgentInput>, Enumerable<MarketplaceAgentUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<MarketplaceAgentCreateOrConnectWithoutAgentInput>
    createMany?: MarketplaceAgentCreateManyAgentInputEnvelope
    connect?: Enumerable<MarketplaceAgentWhereUniqueInput>
  }

  export type MarketplaceBuyerCreateNestedManyWithoutBuyerInput = {
    create?: XOR<Enumerable<MarketplaceBuyerCreateWithoutBuyerInput>, Enumerable<MarketplaceBuyerUncheckedCreateWithoutBuyerInput>>
    connectOrCreate?: Enumerable<MarketplaceBuyerCreateOrConnectWithoutBuyerInput>
    createMany?: MarketplaceBuyerCreateManyBuyerInputEnvelope
    connect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
  }

  export type MarketplaceCreateNestedManyWithoutReserved_by_userInput = {
    create?: XOR<Enumerable<MarketplaceCreateWithoutReserved_by_userInput>, Enumerable<MarketplaceUncheckedCreateWithoutReserved_by_userInput>>
    connectOrCreate?: Enumerable<MarketplaceCreateOrConnectWithoutReserved_by_userInput>
    createMany?: MarketplaceCreateManyReserved_by_userInputEnvelope
    connect?: Enumerable<MarketplaceWhereUniqueInput>
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type CompanyUncheckedCreateNestedOneWithoutCompany_managerInput = {
    create?: XOR<CompanyCreateWithoutCompany_managerInput, CompanyUncheckedCreateWithoutCompany_managerInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompany_managerInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput = {
    create?: XOR<Enumerable<CompanyCreateWithoutMacrovesta_managerInput>, Enumerable<CompanyUncheckedCreateWithoutMacrovesta_managerInput>>
    connectOrCreate?: Enumerable<CompanyCreateOrConnectWithoutMacrovesta_managerInput>
    createMany?: CompanyCreateManyMacrovesta_managerInputEnvelope
    connect?: Enumerable<CompanyWhereUniqueInput>
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: Enumerable<AccountWhereUniqueInput>
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<MarketplaceAgentCreateWithoutAgentInput>, Enumerable<MarketplaceAgentUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<MarketplaceAgentCreateOrConnectWithoutAgentInput>
    createMany?: MarketplaceAgentCreateManyAgentInputEnvelope
    connect?: Enumerable<MarketplaceAgentWhereUniqueInput>
  }

  export type MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<Enumerable<MarketplaceBuyerCreateWithoutBuyerInput>, Enumerable<MarketplaceBuyerUncheckedCreateWithoutBuyerInput>>
    connectOrCreate?: Enumerable<MarketplaceBuyerCreateOrConnectWithoutBuyerInput>
    createMany?: MarketplaceBuyerCreateManyBuyerInputEnvelope
    connect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
  }

  export type MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput = {
    create?: XOR<Enumerable<MarketplaceCreateWithoutReserved_by_userInput>, Enumerable<MarketplaceUncheckedCreateWithoutReserved_by_userInput>>
    connectOrCreate?: Enumerable<MarketplaceCreateOrConnectWithoutReserved_by_userInput>
    createMany?: MarketplaceCreateManyReserved_by_userInputEnvelope
    connect?: Enumerable<MarketplaceWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateOneWithoutSelected_usersNestedInput = {
    create?: XOR<CompanyCreateWithoutSelected_usersInput, CompanyUncheckedCreateWithoutSelected_usersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSelected_usersInput
    upsert?: CompanyUpsertWithoutSelected_usersInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutSelected_usersInput, CompanyUncheckedUpdateWithoutSelected_usersInput>
  }

  export type CompanyUpdateOneWithoutCompany_managerNestedInput = {
    create?: XOR<CompanyCreateWithoutCompany_managerInput, CompanyUncheckedCreateWithoutCompany_managerInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompany_managerInput
    upsert?: CompanyUpsertWithoutCompany_managerInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutCompany_managerInput, CompanyUncheckedUpdateWithoutCompany_managerInput>
  }

  export type CompanyUpdateManyWithoutMacrovesta_managerNestedInput = {
    create?: XOR<Enumerable<CompanyCreateWithoutMacrovesta_managerInput>, Enumerable<CompanyUncheckedCreateWithoutMacrovesta_managerInput>>
    connectOrCreate?: Enumerable<CompanyCreateOrConnectWithoutMacrovesta_managerInput>
    upsert?: Enumerable<CompanyUpsertWithWhereUniqueWithoutMacrovesta_managerInput>
    createMany?: CompanyCreateManyMacrovesta_managerInputEnvelope
    set?: Enumerable<CompanyWhereUniqueInput>
    disconnect?: Enumerable<CompanyWhereUniqueInput>
    delete?: Enumerable<CompanyWhereUniqueInput>
    connect?: Enumerable<CompanyWhereUniqueInput>
    update?: Enumerable<CompanyUpdateWithWhereUniqueWithoutMacrovesta_managerInput>
    updateMany?: Enumerable<CompanyUpdateManyWithWhereWithoutMacrovesta_managerInput>
    deleteMany?: Enumerable<CompanyScalarWhereInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type MarketplaceAgentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<MarketplaceAgentCreateWithoutAgentInput>, Enumerable<MarketplaceAgentUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<MarketplaceAgentCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<MarketplaceAgentUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: MarketplaceAgentCreateManyAgentInputEnvelope
    set?: Enumerable<MarketplaceAgentWhereUniqueInput>
    disconnect?: Enumerable<MarketplaceAgentWhereUniqueInput>
    delete?: Enumerable<MarketplaceAgentWhereUniqueInput>
    connect?: Enumerable<MarketplaceAgentWhereUniqueInput>
    update?: Enumerable<MarketplaceAgentUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<MarketplaceAgentUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<MarketplaceAgentScalarWhereInput>
  }

  export type MarketplaceBuyerUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<Enumerable<MarketplaceBuyerCreateWithoutBuyerInput>, Enumerable<MarketplaceBuyerUncheckedCreateWithoutBuyerInput>>
    connectOrCreate?: Enumerable<MarketplaceBuyerCreateOrConnectWithoutBuyerInput>
    upsert?: Enumerable<MarketplaceBuyerUpsertWithWhereUniqueWithoutBuyerInput>
    createMany?: MarketplaceBuyerCreateManyBuyerInputEnvelope
    set?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    disconnect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    delete?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    connect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    update?: Enumerable<MarketplaceBuyerUpdateWithWhereUniqueWithoutBuyerInput>
    updateMany?: Enumerable<MarketplaceBuyerUpdateManyWithWhereWithoutBuyerInput>
    deleteMany?: Enumerable<MarketplaceBuyerScalarWhereInput>
  }

  export type MarketplaceUpdateManyWithoutReserved_by_userNestedInput = {
    create?: XOR<Enumerable<MarketplaceCreateWithoutReserved_by_userInput>, Enumerable<MarketplaceUncheckedCreateWithoutReserved_by_userInput>>
    connectOrCreate?: Enumerable<MarketplaceCreateOrConnectWithoutReserved_by_userInput>
    upsert?: Enumerable<MarketplaceUpsertWithWhereUniqueWithoutReserved_by_userInput>
    createMany?: MarketplaceCreateManyReserved_by_userInputEnvelope
    set?: Enumerable<MarketplaceWhereUniqueInput>
    disconnect?: Enumerable<MarketplaceWhereUniqueInput>
    delete?: Enumerable<MarketplaceWhereUniqueInput>
    connect?: Enumerable<MarketplaceWhereUniqueInput>
    update?: Enumerable<MarketplaceUpdateWithWhereUniqueWithoutReserved_by_userInput>
    updateMany?: Enumerable<MarketplaceUpdateManyWithWhereWithoutReserved_by_userInput>
    deleteMany?: Enumerable<MarketplaceScalarWhereInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput = {
    create?: XOR<CompanyCreateWithoutCompany_managerInput, CompanyUncheckedCreateWithoutCompany_managerInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompany_managerInput
    upsert?: CompanyUpsertWithoutCompany_managerInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutCompany_managerInput, CompanyUncheckedUpdateWithoutCompany_managerInput>
  }

  export type CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput = {
    create?: XOR<Enumerable<CompanyCreateWithoutMacrovesta_managerInput>, Enumerable<CompanyUncheckedCreateWithoutMacrovesta_managerInput>>
    connectOrCreate?: Enumerable<CompanyCreateOrConnectWithoutMacrovesta_managerInput>
    upsert?: Enumerable<CompanyUpsertWithWhereUniqueWithoutMacrovesta_managerInput>
    createMany?: CompanyCreateManyMacrovesta_managerInputEnvelope
    set?: Enumerable<CompanyWhereUniqueInput>
    disconnect?: Enumerable<CompanyWhereUniqueInput>
    delete?: Enumerable<CompanyWhereUniqueInput>
    connect?: Enumerable<CompanyWhereUniqueInput>
    update?: Enumerable<CompanyUpdateWithWhereUniqueWithoutMacrovesta_managerInput>
    updateMany?: Enumerable<CompanyUpdateManyWithWhereWithoutMacrovesta_managerInput>
    deleteMany?: Enumerable<CompanyScalarWhereInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AccountCreateWithoutUserInput>, Enumerable<AccountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AccountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AccountUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AccountCreateManyUserInputEnvelope
    set?: Enumerable<AccountWhereUniqueInput>
    disconnect?: Enumerable<AccountWhereUniqueInput>
    delete?: Enumerable<AccountWhereUniqueInput>
    connect?: Enumerable<AccountWhereUniqueInput>
    update?: Enumerable<AccountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AccountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AccountScalarWhereInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SessionCreateWithoutUserInput>, Enumerable<SessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SessionCreateManyUserInputEnvelope
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    connect?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<MarketplaceAgentCreateWithoutAgentInput>, Enumerable<MarketplaceAgentUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<MarketplaceAgentCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<MarketplaceAgentUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: MarketplaceAgentCreateManyAgentInputEnvelope
    set?: Enumerable<MarketplaceAgentWhereUniqueInput>
    disconnect?: Enumerable<MarketplaceAgentWhereUniqueInput>
    delete?: Enumerable<MarketplaceAgentWhereUniqueInput>
    connect?: Enumerable<MarketplaceAgentWhereUniqueInput>
    update?: Enumerable<MarketplaceAgentUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<MarketplaceAgentUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<MarketplaceAgentScalarWhereInput>
  }

  export type MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<Enumerable<MarketplaceBuyerCreateWithoutBuyerInput>, Enumerable<MarketplaceBuyerUncheckedCreateWithoutBuyerInput>>
    connectOrCreate?: Enumerable<MarketplaceBuyerCreateOrConnectWithoutBuyerInput>
    upsert?: Enumerable<MarketplaceBuyerUpsertWithWhereUniqueWithoutBuyerInput>
    createMany?: MarketplaceBuyerCreateManyBuyerInputEnvelope
    set?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    disconnect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    delete?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    connect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    update?: Enumerable<MarketplaceBuyerUpdateWithWhereUniqueWithoutBuyerInput>
    updateMany?: Enumerable<MarketplaceBuyerUpdateManyWithWhereWithoutBuyerInput>
    deleteMany?: Enumerable<MarketplaceBuyerScalarWhereInput>
  }

  export type MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput = {
    create?: XOR<Enumerable<MarketplaceCreateWithoutReserved_by_userInput>, Enumerable<MarketplaceUncheckedCreateWithoutReserved_by_userInput>>
    connectOrCreate?: Enumerable<MarketplaceCreateOrConnectWithoutReserved_by_userInput>
    upsert?: Enumerable<MarketplaceUpsertWithWhereUniqueWithoutReserved_by_userInput>
    createMany?: MarketplaceCreateManyReserved_by_userInputEnvelope
    set?: Enumerable<MarketplaceWhereUniqueInput>
    disconnect?: Enumerable<MarketplaceWhereUniqueInput>
    delete?: Enumerable<MarketplaceWhereUniqueInput>
    connect?: Enumerable<MarketplaceWhereUniqueInput>
    update?: Enumerable<MarketplaceUpdateWithWhereUniqueWithoutReserved_by_userInput>
    updateMany?: Enumerable<MarketplaceUpdateManyWithWhereWithoutReserved_by_userInput>
    deleteMany?: Enumerable<MarketplaceScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserCreateNestedOneWithoutMarketplaceInput = {
    create?: XOR<UserCreateWithoutMarketplaceInput, UserUncheckedCreateWithoutMarketplaceInput>
    connectOrCreate?: UserCreateOrConnectWithoutMarketplaceInput
    connect?: UserWhereUniqueInput
  }

  export type MarketplaceAgentCreateNestedManyWithoutMarketplaceInput = {
    create?: XOR<Enumerable<MarketplaceAgentCreateWithoutMarketplaceInput>, Enumerable<MarketplaceAgentUncheckedCreateWithoutMarketplaceInput>>
    connectOrCreate?: Enumerable<MarketplaceAgentCreateOrConnectWithoutMarketplaceInput>
    createMany?: MarketplaceAgentCreateManyMarketplaceInputEnvelope
    connect?: Enumerable<MarketplaceAgentWhereUniqueInput>
  }

  export type MarketplaceBuyerCreateNestedManyWithoutMarketplaceInput = {
    create?: XOR<Enumerable<MarketplaceBuyerCreateWithoutMarketplaceInput>, Enumerable<MarketplaceBuyerUncheckedCreateWithoutMarketplaceInput>>
    connectOrCreate?: Enumerable<MarketplaceBuyerCreateOrConnectWithoutMarketplaceInput>
    createMany?: MarketplaceBuyerCreateManyMarketplaceInputEnvelope
    connect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
  }

  export type MarketplaceAgentUncheckedCreateNestedManyWithoutMarketplaceInput = {
    create?: XOR<Enumerable<MarketplaceAgentCreateWithoutMarketplaceInput>, Enumerable<MarketplaceAgentUncheckedCreateWithoutMarketplaceInput>>
    connectOrCreate?: Enumerable<MarketplaceAgentCreateOrConnectWithoutMarketplaceInput>
    createMany?: MarketplaceAgentCreateManyMarketplaceInputEnvelope
    connect?: Enumerable<MarketplaceAgentWhereUniqueInput>
  }

  export type MarketplaceBuyerUncheckedCreateNestedManyWithoutMarketplaceInput = {
    create?: XOR<Enumerable<MarketplaceBuyerCreateWithoutMarketplaceInput>, Enumerable<MarketplaceBuyerUncheckedCreateWithoutMarketplaceInput>>
    connectOrCreate?: Enumerable<MarketplaceBuyerCreateOrConnectWithoutMarketplaceInput>
    createMany?: MarketplaceBuyerCreateManyMarketplaceInputEnvelope
    connect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutMarketplaceNestedInput = {
    create?: XOR<UserCreateWithoutMarketplaceInput, UserUncheckedCreateWithoutMarketplaceInput>
    connectOrCreate?: UserCreateOrConnectWithoutMarketplaceInput
    upsert?: UserUpsertWithoutMarketplaceInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMarketplaceInput, UserUncheckedUpdateWithoutMarketplaceInput>
  }

  export type MarketplaceAgentUpdateManyWithoutMarketplaceNestedInput = {
    create?: XOR<Enumerable<MarketplaceAgentCreateWithoutMarketplaceInput>, Enumerable<MarketplaceAgentUncheckedCreateWithoutMarketplaceInput>>
    connectOrCreate?: Enumerable<MarketplaceAgentCreateOrConnectWithoutMarketplaceInput>
    upsert?: Enumerable<MarketplaceAgentUpsertWithWhereUniqueWithoutMarketplaceInput>
    createMany?: MarketplaceAgentCreateManyMarketplaceInputEnvelope
    set?: Enumerable<MarketplaceAgentWhereUniqueInput>
    disconnect?: Enumerable<MarketplaceAgentWhereUniqueInput>
    delete?: Enumerable<MarketplaceAgentWhereUniqueInput>
    connect?: Enumerable<MarketplaceAgentWhereUniqueInput>
    update?: Enumerable<MarketplaceAgentUpdateWithWhereUniqueWithoutMarketplaceInput>
    updateMany?: Enumerable<MarketplaceAgentUpdateManyWithWhereWithoutMarketplaceInput>
    deleteMany?: Enumerable<MarketplaceAgentScalarWhereInput>
  }

  export type MarketplaceBuyerUpdateManyWithoutMarketplaceNestedInput = {
    create?: XOR<Enumerable<MarketplaceBuyerCreateWithoutMarketplaceInput>, Enumerable<MarketplaceBuyerUncheckedCreateWithoutMarketplaceInput>>
    connectOrCreate?: Enumerable<MarketplaceBuyerCreateOrConnectWithoutMarketplaceInput>
    upsert?: Enumerable<MarketplaceBuyerUpsertWithWhereUniqueWithoutMarketplaceInput>
    createMany?: MarketplaceBuyerCreateManyMarketplaceInputEnvelope
    set?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    disconnect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    delete?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    connect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    update?: Enumerable<MarketplaceBuyerUpdateWithWhereUniqueWithoutMarketplaceInput>
    updateMany?: Enumerable<MarketplaceBuyerUpdateManyWithWhereWithoutMarketplaceInput>
    deleteMany?: Enumerable<MarketplaceBuyerScalarWhereInput>
  }

  export type MarketplaceAgentUncheckedUpdateManyWithoutMarketplaceNestedInput = {
    create?: XOR<Enumerable<MarketplaceAgentCreateWithoutMarketplaceInput>, Enumerable<MarketplaceAgentUncheckedCreateWithoutMarketplaceInput>>
    connectOrCreate?: Enumerable<MarketplaceAgentCreateOrConnectWithoutMarketplaceInput>
    upsert?: Enumerable<MarketplaceAgentUpsertWithWhereUniqueWithoutMarketplaceInput>
    createMany?: MarketplaceAgentCreateManyMarketplaceInputEnvelope
    set?: Enumerable<MarketplaceAgentWhereUniqueInput>
    disconnect?: Enumerable<MarketplaceAgentWhereUniqueInput>
    delete?: Enumerable<MarketplaceAgentWhereUniqueInput>
    connect?: Enumerable<MarketplaceAgentWhereUniqueInput>
    update?: Enumerable<MarketplaceAgentUpdateWithWhereUniqueWithoutMarketplaceInput>
    updateMany?: Enumerable<MarketplaceAgentUpdateManyWithWhereWithoutMarketplaceInput>
    deleteMany?: Enumerable<MarketplaceAgentScalarWhereInput>
  }

  export type MarketplaceBuyerUncheckedUpdateManyWithoutMarketplaceNestedInput = {
    create?: XOR<Enumerable<MarketplaceBuyerCreateWithoutMarketplaceInput>, Enumerable<MarketplaceBuyerUncheckedCreateWithoutMarketplaceInput>>
    connectOrCreate?: Enumerable<MarketplaceBuyerCreateOrConnectWithoutMarketplaceInput>
    upsert?: Enumerable<MarketplaceBuyerUpsertWithWhereUniqueWithoutMarketplaceInput>
    createMany?: MarketplaceBuyerCreateManyMarketplaceInputEnvelope
    set?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    disconnect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    delete?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    connect?: Enumerable<MarketplaceBuyerWhereUniqueInput>
    update?: Enumerable<MarketplaceBuyerUpdateWithWhereUniqueWithoutMarketplaceInput>
    updateMany?: Enumerable<MarketplaceBuyerUpdateManyWithWhereWithoutMarketplaceInput>
    deleteMany?: Enumerable<MarketplaceBuyerScalarWhereInput>
  }

  export type MarketplaceCreateNestedOneWithoutAgentsInput = {
    create?: XOR<MarketplaceCreateWithoutAgentsInput, MarketplaceUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: MarketplaceCreateOrConnectWithoutAgentsInput
    connect?: MarketplaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAgentsInput = {
    create?: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentsInput
    connect?: UserWhereUniqueInput
  }

  export type MarketplaceUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<MarketplaceCreateWithoutAgentsInput, MarketplaceUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: MarketplaceCreateOrConnectWithoutAgentsInput
    upsert?: MarketplaceUpsertWithoutAgentsInput
    connect?: MarketplaceWhereUniqueInput
    update?: XOR<MarketplaceUpdateWithoutAgentsInput, MarketplaceUncheckedUpdateWithoutAgentsInput>
  }

  export type UserUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentsInput
    upsert?: UserUpsertWithoutAgentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAgentsInput, UserUncheckedUpdateWithoutAgentsInput>
  }

  export type UserCreateNestedOneWithoutBuyersInput = {
    create?: XOR<UserCreateWithoutBuyersInput, UserUncheckedCreateWithoutBuyersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuyersInput
    connect?: UserWhereUniqueInput
  }

  export type MarketplaceCreateNestedOneWithoutBuyersInput = {
    create?: XOR<MarketplaceCreateWithoutBuyersInput, MarketplaceUncheckedCreateWithoutBuyersInput>
    connectOrCreate?: MarketplaceCreateOrConnectWithoutBuyersInput
    connect?: MarketplaceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBuyersNestedInput = {
    create?: XOR<UserCreateWithoutBuyersInput, UserUncheckedCreateWithoutBuyersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuyersInput
    upsert?: UserUpsertWithoutBuyersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBuyersInput, UserUncheckedUpdateWithoutBuyersInput>
  }

  export type MarketplaceUpdateOneRequiredWithoutBuyersNestedInput = {
    create?: XOR<MarketplaceCreateWithoutBuyersInput, MarketplaceUncheckedCreateWithoutBuyersInput>
    connectOrCreate?: MarketplaceCreateOrConnectWithoutBuyersInput
    upsert?: MarketplaceUpsertWithoutBuyersInput
    connect?: MarketplaceWhereUniqueInput
    update?: XOR<MarketplaceUpdateWithoutBuyersInput, MarketplaceUncheckedUpdateWithoutBuyersInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CompanyCreateNestedOneWithoutFixed_cottonInput = {
    create?: XOR<CompanyCreateWithoutFixed_cottonInput, CompanyUncheckedCreateWithoutFixed_cottonInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFixed_cottonInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutFixed_cottonNestedInput = {
    create?: XOR<CompanyCreateWithoutFixed_cottonInput, CompanyUncheckedCreateWithoutFixed_cottonInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFixed_cottonInput
    upsert?: CompanyUpsertWithoutFixed_cottonInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutFixed_cottonInput, CompanyUncheckedUpdateWithoutFixed_cottonInput>
  }

  export type CompanyCreateNestedOneWithoutUnfixed_cottonInput = {
    create?: XOR<CompanyCreateWithoutUnfixed_cottonInput, CompanyUncheckedCreateWithoutUnfixed_cottonInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUnfixed_cottonInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutUnfixed_cottonNestedInput = {
    create?: XOR<CompanyCreateWithoutUnfixed_cottonInput, CompanyUncheckedCreateWithoutUnfixed_cottonInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUnfixed_cottonInput
    upsert?: CompanyUpsertWithoutUnfixed_cottonInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutUnfixed_cottonInput, CompanyUncheckedUpdateWithoutUnfixed_cottonInput>
  }

  export type CompanyCreateNestedOneWithoutStrategy_logInput = {
    create?: XOR<CompanyCreateWithoutStrategy_logInput, CompanyUncheckedCreateWithoutStrategy_logInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStrategy_logInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutStrategy_logNestedInput = {
    create?: XOR<CompanyCreateWithoutStrategy_logInput, CompanyUncheckedCreateWithoutStrategy_logInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStrategy_logInput
    upsert?: CompanyUpsertWithoutStrategy_logInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutStrategy_logInput, CompanyUncheckedUpdateWithoutStrategy_logInput>
  }

  export type CompanyCreateNestedOneWithoutProducer_production_estimatesInput = {
    create?: XOR<CompanyCreateWithoutProducer_production_estimatesInput, CompanyUncheckedCreateWithoutProducer_production_estimatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProducer_production_estimatesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutProducer_production_estimatesNestedInput = {
    create?: XOR<CompanyCreateWithoutProducer_production_estimatesInput, CompanyUncheckedCreateWithoutProducer_production_estimatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProducer_production_estimatesInput
    upsert?: CompanyUpsertWithoutProducer_production_estimatesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutProducer_production_estimatesInput, CompanyUncheckedUpdateWithoutProducer_production_estimatesInput>
  }

  export type CompanyCreateNestedOneWithoutProducer_cost_estimatesInput = {
    create?: XOR<CompanyCreateWithoutProducer_cost_estimatesInput, CompanyUncheckedCreateWithoutProducer_cost_estimatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProducer_cost_estimatesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutProducer_cost_estimatesNestedInput = {
    create?: XOR<CompanyCreateWithoutProducer_cost_estimatesInput, CompanyUncheckedCreateWithoutProducer_cost_estimatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProducer_cost_estimatesInput
    upsert?: CompanyUpsertWithoutProducer_cost_estimatesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutProducer_cost_estimatesInput, CompanyUncheckedUpdateWithoutProducer_cost_estimatesInput>
  }

  export type CompanyCreateNestedOneWithoutProducer_commercialisation_estimatesInput = {
    create?: XOR<CompanyCreateWithoutProducer_commercialisation_estimatesInput, CompanyUncheckedCreateWithoutProducer_commercialisation_estimatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProducer_commercialisation_estimatesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutProducer_commercialisation_estimatesNestedInput = {
    create?: XOR<CompanyCreateWithoutProducer_commercialisation_estimatesInput, CompanyUncheckedCreateWithoutProducer_commercialisation_estimatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProducer_commercialisation_estimatesInput
    upsert?: CompanyUpsertWithoutProducer_commercialisation_estimatesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutProducer_commercialisation_estimatesInput, CompanyUncheckedUpdateWithoutProducer_commercialisation_estimatesInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    selected_company?: CompanyCreateNestedOneWithoutSelected_usersInput
    company_managing?: CompanyCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyCreateNestedManyWithoutMacrovesta_managerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company_managing?: CompanyUncheckedCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    selected_company?: CompanyUpdateOneWithoutSelected_usersNestedInput
    company_managing?: CompanyUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUpdateManyWithoutMacrovesta_managerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company_managing?: CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    selected_company?: CompanyCreateNestedOneWithoutSelected_usersInput
    company_managing?: CompanyCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company_managing?: CompanyUncheckedCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    selected_company?: CompanyUpdateOneWithoutSelected_usersNestedInput
    company_managing?: CompanyUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company_managing?: CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCompany_managingInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    selected_company?: CompanyCreateNestedOneWithoutSelected_usersInput
    macrovesta_managing?: CompanyCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompany_managingInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    macrovesta_managing?: CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompany_managingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompany_managingInput, UserUncheckedCreateWithoutCompany_managingInput>
  }

  export type UserCreateWithoutMacrovesta_managingInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    selected_company?: CompanyCreateNestedOneWithoutSelected_usersInput
    company_managing?: CompanyCreateNestedOneWithoutCompany_managerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMacrovesta_managingInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company_managing?: CompanyUncheckedCreateNestedOneWithoutCompany_managerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMacrovesta_managingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMacrovesta_managingInput, UserUncheckedCreateWithoutMacrovesta_managingInput>
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    selected_company?: CompanyCreateNestedOneWithoutSelected_usersInput
    company_managing?: CompanyCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company_managing?: CompanyUncheckedCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: Enumerable<UserCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSelected_companyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    company_managing?: CompanyCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSelected_companyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company_managing?: CompanyUncheckedCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSelected_companyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSelected_companyInput, UserUncheckedCreateWithoutSelected_companyInput>
  }

  export type UserCreateManySelected_companyInputEnvelope = {
    data: Enumerable<UserCreateManySelected_companyInput>
    skipDuplicates?: boolean
  }

  export type producer_production_estimatesCreateWithoutCompanyInput = {
    record_id?: string
    season: string
    production_estimate: Decimal | DecimalJsLike | number | string
    yield_estimate: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_production_estimatesUncheckedCreateWithoutCompanyInput = {
    record_id?: string
    season: string
    production_estimate: Decimal | DecimalJsLike | number | string
    yield_estimate: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_production_estimatesCreateOrConnectWithoutCompanyInput = {
    where: producer_production_estimatesWhereUniqueInput
    create: XOR<producer_production_estimatesCreateWithoutCompanyInput, producer_production_estimatesUncheckedCreateWithoutCompanyInput>
  }

  export type producer_production_estimatesCreateManyCompanyInputEnvelope = {
    data: Enumerable<producer_production_estimatesCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type producer_cost_estimatesCreateWithoutCompanyInput = {
    record_id?: string
    season: string
    cost_estimate_dollar_per_hectare: Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_cost_estimatesUncheckedCreateWithoutCompanyInput = {
    record_id?: string
    season: string
    cost_estimate_dollar_per_hectare: Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_cost_estimatesCreateOrConnectWithoutCompanyInput = {
    where: producer_cost_estimatesWhereUniqueInput
    create: XOR<producer_cost_estimatesCreateWithoutCompanyInput, producer_cost_estimatesUncheckedCreateWithoutCompanyInput>
  }

  export type producer_cost_estimatesCreateManyCompanyInputEnvelope = {
    data: Enumerable<producer_cost_estimatesCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type producer_commercialisation_estimatesCreateWithoutCompanyInput = {
    record_id?: string
    season: string
    percentage_sold: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_commercialisation_estimatesUncheckedCreateWithoutCompanyInput = {
    record_id?: string
    season: string
    percentage_sold: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_commercialisation_estimatesCreateOrConnectWithoutCompanyInput = {
    where: producer_commercialisation_estimatesWhereUniqueInput
    create: XOR<producer_commercialisation_estimatesCreateWithoutCompanyInput, producer_commercialisation_estimatesUncheckedCreateWithoutCompanyInput>
  }

  export type producer_commercialisation_estimatesCreateManyCompanyInputEnvelope = {
    data: Enumerable<producer_commercialisation_estimatesCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type strategy_logCreateWithoutCompanyInput = {
    record_id?: string
    title?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type strategy_logUncheckedCreateWithoutCompanyInput = {
    record_id?: string
    title?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type strategy_logCreateOrConnectWithoutCompanyInput = {
    where: strategy_logWhereUniqueInput
    create: XOR<strategy_logCreateWithoutCompanyInput, strategy_logUncheckedCreateWithoutCompanyInput>
  }

  export type strategy_logCreateManyCompanyInputEnvelope = {
    data: Enumerable<strategy_logCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type fixed_cottonCreateWithoutCompanyInput = {
    record_id?: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: Decimal | DecimalJsLike | number | string | null
    amount_fixed?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
  }

  export type fixed_cottonUncheckedCreateWithoutCompanyInput = {
    record_id?: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: Decimal | DecimalJsLike | number | string | null
    amount_fixed?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
  }

  export type fixed_cottonCreateOrConnectWithoutCompanyInput = {
    where: fixed_cottonWhereUniqueInput
    create: XOR<fixed_cottonCreateWithoutCompanyInput, fixed_cottonUncheckedCreateWithoutCompanyInput>
  }

  export type fixed_cottonCreateManyCompanyInputEnvelope = {
    data: Enumerable<fixed_cottonCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type unfixed_cottonCreateWithoutCompanyInput = {
    record_id?: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fix_by: Date | string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    amount_remaining?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
  }

  export type unfixed_cottonUncheckedCreateWithoutCompanyInput = {
    record_id?: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fix_by: Date | string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    amount_remaining?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
  }

  export type unfixed_cottonCreateOrConnectWithoutCompanyInput = {
    where: unfixed_cottonWhereUniqueInput
    create: XOR<unfixed_cottonCreateWithoutCompanyInput, unfixed_cottonUncheckedCreateWithoutCompanyInput>
  }

  export type unfixed_cottonCreateManyCompanyInputEnvelope = {
    data: Enumerable<unfixed_cottonCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCompany_managingInput = {
    update: XOR<UserUpdateWithoutCompany_managingInput, UserUncheckedUpdateWithoutCompany_managingInput>
    create: XOR<UserCreateWithoutCompany_managingInput, UserUncheckedCreateWithoutCompany_managingInput>
  }

  export type UserUpdateWithoutCompany_managingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    selected_company?: CompanyUpdateOneWithoutSelected_usersNestedInput
    macrovesta_managing?: CompanyUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompany_managingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_managing?: CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMacrovesta_managingInput = {
    update: XOR<UserUpdateWithoutMacrovesta_managingInput, UserUncheckedUpdateWithoutMacrovesta_managingInput>
    create: XOR<UserCreateWithoutMacrovesta_managingInput, UserUncheckedCreateWithoutMacrovesta_managingInput>
  }

  export type UserUpdateWithoutMacrovesta_managingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    selected_company?: CompanyUpdateOneWithoutSelected_usersNestedInput
    company_managing?: CompanyUpdateOneWithoutCompany_managerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMacrovesta_managingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company_managing?: CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    emailVerified?: DateTimeNullableFilter | Date | string | null
    role?: StringNullableFilter | string | null
    company_id?: StringNullableFilter | string | null
    selected_company_id?: StringNullableFilter | string | null
    submittedSurvey?: BoolNullableFilter | boolean | null
    image?: StringNullableFilter | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutSelected_companyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSelected_companyInput, UserUncheckedUpdateWithoutSelected_companyInput>
    create: XOR<UserCreateWithoutSelected_companyInput, UserUncheckedCreateWithoutSelected_companyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSelected_companyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSelected_companyInput, UserUncheckedUpdateWithoutSelected_companyInput>
  }

  export type UserUpdateManyWithWhereWithoutSelected_companyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSelected_usersInput>
  }

  export type producer_production_estimatesUpsertWithWhereUniqueWithoutCompanyInput = {
    where: producer_production_estimatesWhereUniqueInput
    update: XOR<producer_production_estimatesUpdateWithoutCompanyInput, producer_production_estimatesUncheckedUpdateWithoutCompanyInput>
    create: XOR<producer_production_estimatesCreateWithoutCompanyInput, producer_production_estimatesUncheckedCreateWithoutCompanyInput>
  }

  export type producer_production_estimatesUpdateWithWhereUniqueWithoutCompanyInput = {
    where: producer_production_estimatesWhereUniqueInput
    data: XOR<producer_production_estimatesUpdateWithoutCompanyInput, producer_production_estimatesUncheckedUpdateWithoutCompanyInput>
  }

  export type producer_production_estimatesUpdateManyWithWhereWithoutCompanyInput = {
    where: producer_production_estimatesScalarWhereInput
    data: XOR<producer_production_estimatesUpdateManyMutationInput, producer_production_estimatesUncheckedUpdateManyWithoutProducer_production_estimatesInput>
  }

  export type producer_production_estimatesScalarWhereInput = {
    AND?: Enumerable<producer_production_estimatesScalarWhereInput>
    OR?: Enumerable<producer_production_estimatesScalarWhereInput>
    NOT?: Enumerable<producer_production_estimatesScalarWhereInput>
    record_id?: StringFilter | string
    company_id?: StringFilter | string
    season?: StringFilter | string
    production_estimate?: DecimalFilter | Decimal | DecimalJsLike | number | string
    yield_estimate?: DecimalFilter | Decimal | DecimalJsLike | number | string
    added_by?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
  }

  export type producer_cost_estimatesUpsertWithWhereUniqueWithoutCompanyInput = {
    where: producer_cost_estimatesWhereUniqueInput
    update: XOR<producer_cost_estimatesUpdateWithoutCompanyInput, producer_cost_estimatesUncheckedUpdateWithoutCompanyInput>
    create: XOR<producer_cost_estimatesCreateWithoutCompanyInput, producer_cost_estimatesUncheckedCreateWithoutCompanyInput>
  }

  export type producer_cost_estimatesUpdateWithWhereUniqueWithoutCompanyInput = {
    where: producer_cost_estimatesWhereUniqueInput
    data: XOR<producer_cost_estimatesUpdateWithoutCompanyInput, producer_cost_estimatesUncheckedUpdateWithoutCompanyInput>
  }

  export type producer_cost_estimatesUpdateManyWithWhereWithoutCompanyInput = {
    where: producer_cost_estimatesScalarWhereInput
    data: XOR<producer_cost_estimatesUpdateManyMutationInput, producer_cost_estimatesUncheckedUpdateManyWithoutProducer_cost_estimatesInput>
  }

  export type producer_cost_estimatesScalarWhereInput = {
    AND?: Enumerable<producer_cost_estimatesScalarWhereInput>
    OR?: Enumerable<producer_cost_estimatesScalarWhereInput>
    NOT?: Enumerable<producer_cost_estimatesScalarWhereInput>
    record_id?: StringFilter | string
    company_id?: StringFilter | string
    season?: StringFilter | string
    cost_estimate_dollar_per_hectare?: DecimalFilter | Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound?: DecimalFilter | Decimal | DecimalJsLike | number | string
    added_by?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
  }

  export type producer_commercialisation_estimatesUpsertWithWhereUniqueWithoutCompanyInput = {
    where: producer_commercialisation_estimatesWhereUniqueInput
    update: XOR<producer_commercialisation_estimatesUpdateWithoutCompanyInput, producer_commercialisation_estimatesUncheckedUpdateWithoutCompanyInput>
    create: XOR<producer_commercialisation_estimatesCreateWithoutCompanyInput, producer_commercialisation_estimatesUncheckedCreateWithoutCompanyInput>
  }

  export type producer_commercialisation_estimatesUpdateWithWhereUniqueWithoutCompanyInput = {
    where: producer_commercialisation_estimatesWhereUniqueInput
    data: XOR<producer_commercialisation_estimatesUpdateWithoutCompanyInput, producer_commercialisation_estimatesUncheckedUpdateWithoutCompanyInput>
  }

  export type producer_commercialisation_estimatesUpdateManyWithWhereWithoutCompanyInput = {
    where: producer_commercialisation_estimatesScalarWhereInput
    data: XOR<producer_commercialisation_estimatesUpdateManyMutationInput, producer_commercialisation_estimatesUncheckedUpdateManyWithoutProducer_commercialisation_estimatesInput>
  }

  export type producer_commercialisation_estimatesScalarWhereInput = {
    AND?: Enumerable<producer_commercialisation_estimatesScalarWhereInput>
    OR?: Enumerable<producer_commercialisation_estimatesScalarWhereInput>
    NOT?: Enumerable<producer_commercialisation_estimatesScalarWhereInput>
    record_id?: StringFilter | string
    company_id?: StringFilter | string
    season?: StringFilter | string
    percentage_sold?: DecimalFilter | Decimal | DecimalJsLike | number | string
    added_by?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
  }

  export type strategy_logUpsertWithWhereUniqueWithoutCompanyInput = {
    where: strategy_logWhereUniqueInput
    update: XOR<strategy_logUpdateWithoutCompanyInput, strategy_logUncheckedUpdateWithoutCompanyInput>
    create: XOR<strategy_logCreateWithoutCompanyInput, strategy_logUncheckedCreateWithoutCompanyInput>
  }

  export type strategy_logUpdateWithWhereUniqueWithoutCompanyInput = {
    where: strategy_logWhereUniqueInput
    data: XOR<strategy_logUpdateWithoutCompanyInput, strategy_logUncheckedUpdateWithoutCompanyInput>
  }

  export type strategy_logUpdateManyWithWhereWithoutCompanyInput = {
    where: strategy_logScalarWhereInput
    data: XOR<strategy_logUpdateManyMutationInput, strategy_logUncheckedUpdateManyWithoutStrategy_logInput>
  }

  export type strategy_logScalarWhereInput = {
    AND?: Enumerable<strategy_logScalarWhereInput>
    OR?: Enumerable<strategy_logScalarWhereInput>
    NOT?: Enumerable<strategy_logScalarWhereInput>
    record_id?: StringFilter | string
    company_id?: StringFilter | string
    title?: StringNullableFilter | string | null
    text?: StringNullableFilter | string | null
    added_by?: StringNullableFilter | string | null
    date_created?: DateTimeFilter | Date | string
  }

  export type fixed_cottonUpsertWithWhereUniqueWithoutCompanyInput = {
    where: fixed_cottonWhereUniqueInput
    update: XOR<fixed_cottonUpdateWithoutCompanyInput, fixed_cottonUncheckedUpdateWithoutCompanyInput>
    create: XOR<fixed_cottonCreateWithoutCompanyInput, fixed_cottonUncheckedCreateWithoutCompanyInput>
  }

  export type fixed_cottonUpdateWithWhereUniqueWithoutCompanyInput = {
    where: fixed_cottonWhereUniqueInput
    data: XOR<fixed_cottonUpdateWithoutCompanyInput, fixed_cottonUncheckedUpdateWithoutCompanyInput>
  }

  export type fixed_cottonUpdateManyWithWhereWithoutCompanyInput = {
    where: fixed_cottonScalarWhereInput
    data: XOR<fixed_cottonUpdateManyMutationInput, fixed_cottonUncheckedUpdateManyWithoutFixed_cottonInput>
  }

  export type fixed_cottonScalarWhereInput = {
    AND?: Enumerable<fixed_cottonScalarWhereInput>
    OR?: Enumerable<fixed_cottonScalarWhereInput>
    NOT?: Enumerable<fixed_cottonScalarWhereInput>
    company_id?: StringFilter | string
    record_id?: StringFilter | string
    contract_number?: StringFilter | string
    futures_month?: StringFilter | string
    basis?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    amount_fixed?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
  }

  export type unfixed_cottonUpsertWithWhereUniqueWithoutCompanyInput = {
    where: unfixed_cottonWhereUniqueInput
    update: XOR<unfixed_cottonUpdateWithoutCompanyInput, unfixed_cottonUncheckedUpdateWithoutCompanyInput>
    create: XOR<unfixed_cottonCreateWithoutCompanyInput, unfixed_cottonUncheckedCreateWithoutCompanyInput>
  }

  export type unfixed_cottonUpdateWithWhereUniqueWithoutCompanyInput = {
    where: unfixed_cottonWhereUniqueInput
    data: XOR<unfixed_cottonUpdateWithoutCompanyInput, unfixed_cottonUncheckedUpdateWithoutCompanyInput>
  }

  export type unfixed_cottonUpdateManyWithWhereWithoutCompanyInput = {
    where: unfixed_cottonScalarWhereInput
    data: XOR<unfixed_cottonUpdateManyMutationInput, unfixed_cottonUncheckedUpdateManyWithoutUnfixed_cottonInput>
  }

  export type unfixed_cottonScalarWhereInput = {
    AND?: Enumerable<unfixed_cottonScalarWhereInput>
    OR?: Enumerable<unfixed_cottonScalarWhereInput>
    NOT?: Enumerable<unfixed_cottonScalarWhereInput>
    record_id?: StringFilter | string
    company_id?: StringFilter | string
    contract_number?: StringFilter | string
    futures_month?: StringFilter | string
    basis?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    fix_by?: DateTimeFilter | Date | string
    total_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    amount_remaining?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
  }

  export type CompanyCreateWithoutUsersInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager?: UserCreateNestedOneWithoutCompany_managingInput
    macrovesta_manager?: UserCreateNestedOneWithoutMacrovesta_managingInput
    selected_users?: UserCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    macrovesta_manager_id?: string | null
    selected_users?: UserUncheckedCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logUncheckedCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type CompanyCreateWithoutSelected_usersInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager?: UserCreateNestedOneWithoutCompany_managingInput
    macrovesta_manager?: UserCreateNestedOneWithoutMacrovesta_managingInput
    users?: UserCreateNestedManyWithoutCompanyInput
    producer_production_estimates?: producer_production_estimatesCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSelected_usersInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    macrovesta_manager_id?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    producer_production_estimates?: producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logUncheckedCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSelected_usersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSelected_usersInput, CompanyUncheckedCreateWithoutSelected_usersInput>
  }

  export type CompanyCreateWithoutCompany_managerInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    macrovesta_manager?: UserCreateNestedOneWithoutMacrovesta_managingInput
    users?: UserCreateNestedManyWithoutCompanyInput
    selected_users?: UserCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCompany_managerInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    macrovesta_manager_id?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    selected_users?: UserUncheckedCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logUncheckedCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCompany_managerInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCompany_managerInput, CompanyUncheckedCreateWithoutCompany_managerInput>
  }

  export type CompanyCreateWithoutMacrovesta_managerInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager?: UserCreateNestedOneWithoutCompany_managingInput
    users?: UserCreateNestedManyWithoutCompanyInput
    selected_users?: UserCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutMacrovesta_managerInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    selected_users?: UserUncheckedCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logUncheckedCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutMacrovesta_managerInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutMacrovesta_managerInput, CompanyUncheckedCreateWithoutMacrovesta_managerInput>
  }

  export type CompanyCreateManyMacrovesta_managerInputEnvelope = {
    data: Enumerable<CompanyCreateManyMacrovesta_managerInput>
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: Enumerable<AccountCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: Enumerable<SessionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type MarketplaceAgentCreateWithoutAgentInput = {
    record_id?: string
    date_created?: Date | string
    marketplace: MarketplaceCreateNestedOneWithoutAgentsInput
  }

  export type MarketplaceAgentUncheckedCreateWithoutAgentInput = {
    record_id?: string
    marketplace_id: string
    date_created?: Date | string
  }

  export type MarketplaceAgentCreateOrConnectWithoutAgentInput = {
    where: MarketplaceAgentWhereUniqueInput
    create: XOR<MarketplaceAgentCreateWithoutAgentInput, MarketplaceAgentUncheckedCreateWithoutAgentInput>
  }

  export type MarketplaceAgentCreateManyAgentInputEnvelope = {
    data: Enumerable<MarketplaceAgentCreateManyAgentInput>
    skipDuplicates?: boolean
  }

  export type MarketplaceBuyerCreateWithoutBuyerInput = {
    record_id?: string
    date_created?: Date | string
    marketplace: MarketplaceCreateNestedOneWithoutBuyersInput
  }

  export type MarketplaceBuyerUncheckedCreateWithoutBuyerInput = {
    record_id?: string
    marketplace_id: string
    date_created?: Date | string
  }

  export type MarketplaceBuyerCreateOrConnectWithoutBuyerInput = {
    where: MarketplaceBuyerWhereUniqueInput
    create: XOR<MarketplaceBuyerCreateWithoutBuyerInput, MarketplaceBuyerUncheckedCreateWithoutBuyerInput>
  }

  export type MarketplaceBuyerCreateManyBuyerInputEnvelope = {
    data: Enumerable<MarketplaceBuyerCreateManyBuyerInput>
    skipDuplicates?: boolean
  }

  export type MarketplaceCreateWithoutReserved_by_userInput = {
    record_id?: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url?: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created?: Date | string
    expiry_date?: Date | string
    agents?: MarketplaceAgentCreateNestedManyWithoutMarketplaceInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutMarketplaceInput
  }

  export type MarketplaceUncheckedCreateWithoutReserved_by_userInput = {
    record_id?: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url?: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created?: Date | string
    expiry_date?: Date | string
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutMarketplaceInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutMarketplaceInput
  }

  export type MarketplaceCreateOrConnectWithoutReserved_by_userInput = {
    where: MarketplaceWhereUniqueInput
    create: XOR<MarketplaceCreateWithoutReserved_by_userInput, MarketplaceUncheckedCreateWithoutReserved_by_userInput>
  }

  export type MarketplaceCreateManyReserved_by_userInputEnvelope = {
    data: Enumerable<MarketplaceCreateManyReserved_by_userInput>
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    record_id?: string
    title: string
    description: string
    is_read: boolean
    date_created?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    record_id?: string
    title: string
    description: string
    is_read: boolean
    date_created?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: Enumerable<NotificationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager?: UserUpdateOneWithoutCompany_managingNestedInput
    macrovesta_manager?: UserUpdateOneWithoutMacrovesta_managingNestedInput
    selected_users?: UserUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_users?: UserUncheckedUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUncheckedUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUpsertWithoutSelected_usersInput = {
    update: XOR<CompanyUpdateWithoutSelected_usersInput, CompanyUncheckedUpdateWithoutSelected_usersInput>
    create: XOR<CompanyCreateWithoutSelected_usersInput, CompanyUncheckedCreateWithoutSelected_usersInput>
  }

  export type CompanyUpdateWithoutSelected_usersInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager?: UserUpdateOneWithoutCompany_managingNestedInput
    macrovesta_manager?: UserUpdateOneWithoutMacrovesta_managingNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    producer_production_estimates?: producer_production_estimatesUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSelected_usersInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    producer_production_estimates?: producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUncheckedUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUpsertWithoutCompany_managerInput = {
    update: XOR<CompanyUpdateWithoutCompany_managerInput, CompanyUncheckedUpdateWithoutCompany_managerInput>
    create: XOR<CompanyCreateWithoutCompany_managerInput, CompanyUncheckedCreateWithoutCompany_managerInput>
  }

  export type CompanyUpdateWithoutCompany_managerInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    macrovesta_manager?: UserUpdateOneWithoutMacrovesta_managingNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCompany_managerInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUncheckedUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUncheckedUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUpsertWithWhereUniqueWithoutMacrovesta_managerInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutMacrovesta_managerInput, CompanyUncheckedUpdateWithoutMacrovesta_managerInput>
    create: XOR<CompanyCreateWithoutMacrovesta_managerInput, CompanyUncheckedCreateWithoutMacrovesta_managerInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutMacrovesta_managerInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutMacrovesta_managerInput, CompanyUncheckedUpdateWithoutMacrovesta_managerInput>
  }

  export type CompanyUpdateManyWithWhereWithoutMacrovesta_managerInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutMacrovesta_managingInput>
  }

  export type CompanyScalarWhereInput = {
    AND?: Enumerable<CompanyScalarWhereInput>
    OR?: Enumerable<CompanyScalarWhereInput>
    NOT?: Enumerable<CompanyScalarWhereInput>
    record_id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    tier?: StringFilter | string
    access_to_marketplace?: BoolNullableFilter | boolean | null
    created_at?: DateTimeFilter | Date | string
    company_manager_id?: StringNullableFilter | string | null
    macrovesta_manager_id?: StringNullableFilter | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type AccountScalarWhereInput = {
    AND?: Enumerable<AccountScalarWhereInput>
    OR?: Enumerable<AccountScalarWhereInput>
    NOT?: Enumerable<AccountScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    providerAccountId?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutSessionsInput>
  }

  export type SessionScalarWhereInput = {
    AND?: Enumerable<SessionScalarWhereInput>
    OR?: Enumerable<SessionScalarWhereInput>
    NOT?: Enumerable<SessionScalarWhereInput>
    id?: StringFilter | string
    sessionToken?: StringFilter | string
    userId?: StringFilter | string
    expires?: DateTimeFilter | Date | string
  }

  export type MarketplaceAgentUpsertWithWhereUniqueWithoutAgentInput = {
    where: MarketplaceAgentWhereUniqueInput
    update: XOR<MarketplaceAgentUpdateWithoutAgentInput, MarketplaceAgentUncheckedUpdateWithoutAgentInput>
    create: XOR<MarketplaceAgentCreateWithoutAgentInput, MarketplaceAgentUncheckedCreateWithoutAgentInput>
  }

  export type MarketplaceAgentUpdateWithWhereUniqueWithoutAgentInput = {
    where: MarketplaceAgentWhereUniqueInput
    data: XOR<MarketplaceAgentUpdateWithoutAgentInput, MarketplaceAgentUncheckedUpdateWithoutAgentInput>
  }

  export type MarketplaceAgentUpdateManyWithWhereWithoutAgentInput = {
    where: MarketplaceAgentScalarWhereInput
    data: XOR<MarketplaceAgentUpdateManyMutationInput, MarketplaceAgentUncheckedUpdateManyWithoutAgentsInput>
  }

  export type MarketplaceAgentScalarWhereInput = {
    AND?: Enumerable<MarketplaceAgentScalarWhereInput>
    OR?: Enumerable<MarketplaceAgentScalarWhereInput>
    NOT?: Enumerable<MarketplaceAgentScalarWhereInput>
    record_id?: StringFilter | string
    marketplace_id?: StringFilter | string
    agent_id?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
  }

  export type MarketplaceBuyerUpsertWithWhereUniqueWithoutBuyerInput = {
    where: MarketplaceBuyerWhereUniqueInput
    update: XOR<MarketplaceBuyerUpdateWithoutBuyerInput, MarketplaceBuyerUncheckedUpdateWithoutBuyerInput>
    create: XOR<MarketplaceBuyerCreateWithoutBuyerInput, MarketplaceBuyerUncheckedCreateWithoutBuyerInput>
  }

  export type MarketplaceBuyerUpdateWithWhereUniqueWithoutBuyerInput = {
    where: MarketplaceBuyerWhereUniqueInput
    data: XOR<MarketplaceBuyerUpdateWithoutBuyerInput, MarketplaceBuyerUncheckedUpdateWithoutBuyerInput>
  }

  export type MarketplaceBuyerUpdateManyWithWhereWithoutBuyerInput = {
    where: MarketplaceBuyerScalarWhereInput
    data: XOR<MarketplaceBuyerUpdateManyMutationInput, MarketplaceBuyerUncheckedUpdateManyWithoutBuyersInput>
  }

  export type MarketplaceBuyerScalarWhereInput = {
    AND?: Enumerable<MarketplaceBuyerScalarWhereInput>
    OR?: Enumerable<MarketplaceBuyerScalarWhereInput>
    NOT?: Enumerable<MarketplaceBuyerScalarWhereInput>
    record_id?: StringFilter | string
    marketplace_id?: StringFilter | string
    buyer_id?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
  }

  export type MarketplaceUpsertWithWhereUniqueWithoutReserved_by_userInput = {
    where: MarketplaceWhereUniqueInput
    update: XOR<MarketplaceUpdateWithoutReserved_by_userInput, MarketplaceUncheckedUpdateWithoutReserved_by_userInput>
    create: XOR<MarketplaceCreateWithoutReserved_by_userInput, MarketplaceUncheckedCreateWithoutReserved_by_userInput>
  }

  export type MarketplaceUpdateWithWhereUniqueWithoutReserved_by_userInput = {
    where: MarketplaceWhereUniqueInput
    data: XOR<MarketplaceUpdateWithoutReserved_by_userInput, MarketplaceUncheckedUpdateWithoutReserved_by_userInput>
  }

  export type MarketplaceUpdateManyWithWhereWithoutReserved_by_userInput = {
    where: MarketplaceScalarWhereInput
    data: XOR<MarketplaceUpdateManyMutationInput, MarketplaceUncheckedUpdateManyWithoutMarketplaceInput>
  }

  export type MarketplaceScalarWhereInput = {
    AND?: Enumerable<MarketplaceScalarWhereInput>
    OR?: Enumerable<MarketplaceScalarWhereInput>
    NOT?: Enumerable<MarketplaceScalarWhereInput>
    record_id?: StringFilter | string
    product?: StringFilter | string
    category?: StringFilter | string
    quantity?: FloatFilter | number
    quality?: StringFilter | string
    description?: StringFilter | string
    image_url?: StringNullableFilter | string | null
    price_usd?: FloatFilter | number
    added_by?: StringFilter | string
    hvi_file?: StringFilter | string
    shipment?: StringFilter | string
    payment_terms?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
    expiry_date?: DateTimeFilter | Date | string
    reserved_by?: StringNullableFilter | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: Enumerable<NotificationScalarWhereInput>
    OR?: Enumerable<NotificationScalarWhereInput>
    NOT?: Enumerable<NotificationScalarWhereInput>
    record_id?: StringFilter | string
    title?: StringFilter | string
    description?: StringFilter | string
    is_read?: BoolFilter | boolean
    user_id?: StringFilter | string
    date_created?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    selected_company?: CompanyCreateNestedOneWithoutSelected_usersInput
    company_managing?: CompanyCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceCreateNestedManyWithoutReserved_by_userInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company_managing?: CompanyUncheckedCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    selected_company?: CompanyUpdateOneWithoutSelected_usersNestedInput
    company_managing?: CompanyUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUpdateManyWithoutReserved_by_userNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company_managing?: CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput
  }

  export type UserCreateWithoutMarketplaceInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    selected_company?: CompanyCreateNestedOneWithoutSelected_usersInput
    company_managing?: CompanyCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutBuyerInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMarketplaceInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company_managing?: CompanyUncheckedCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMarketplaceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMarketplaceInput, UserUncheckedCreateWithoutMarketplaceInput>
  }

  export type MarketplaceAgentCreateWithoutMarketplaceInput = {
    record_id?: string
    date_created?: Date | string
    agent: UserCreateNestedOneWithoutAgentsInput
  }

  export type MarketplaceAgentUncheckedCreateWithoutMarketplaceInput = {
    record_id?: string
    agent_id: string
    date_created?: Date | string
  }

  export type MarketplaceAgentCreateOrConnectWithoutMarketplaceInput = {
    where: MarketplaceAgentWhereUniqueInput
    create: XOR<MarketplaceAgentCreateWithoutMarketplaceInput, MarketplaceAgentUncheckedCreateWithoutMarketplaceInput>
  }

  export type MarketplaceAgentCreateManyMarketplaceInputEnvelope = {
    data: Enumerable<MarketplaceAgentCreateManyMarketplaceInput>
    skipDuplicates?: boolean
  }

  export type MarketplaceBuyerCreateWithoutMarketplaceInput = {
    record_id?: string
    date_created?: Date | string
    buyer: UserCreateNestedOneWithoutBuyersInput
  }

  export type MarketplaceBuyerUncheckedCreateWithoutMarketplaceInput = {
    record_id?: string
    buyer_id: string
    date_created?: Date | string
  }

  export type MarketplaceBuyerCreateOrConnectWithoutMarketplaceInput = {
    where: MarketplaceBuyerWhereUniqueInput
    create: XOR<MarketplaceBuyerCreateWithoutMarketplaceInput, MarketplaceBuyerUncheckedCreateWithoutMarketplaceInput>
  }

  export type MarketplaceBuyerCreateManyMarketplaceInputEnvelope = {
    data: Enumerable<MarketplaceBuyerCreateManyMarketplaceInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMarketplaceInput = {
    update: XOR<UserUpdateWithoutMarketplaceInput, UserUncheckedUpdateWithoutMarketplaceInput>
    create: XOR<UserCreateWithoutMarketplaceInput, UserUncheckedCreateWithoutMarketplaceInput>
  }

  export type UserUpdateWithoutMarketplaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    selected_company?: CompanyUpdateOneWithoutSelected_usersNestedInput
    company_managing?: CompanyUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutBuyerNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMarketplaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company_managing?: CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MarketplaceAgentUpsertWithWhereUniqueWithoutMarketplaceInput = {
    where: MarketplaceAgentWhereUniqueInput
    update: XOR<MarketplaceAgentUpdateWithoutMarketplaceInput, MarketplaceAgentUncheckedUpdateWithoutMarketplaceInput>
    create: XOR<MarketplaceAgentCreateWithoutMarketplaceInput, MarketplaceAgentUncheckedCreateWithoutMarketplaceInput>
  }

  export type MarketplaceAgentUpdateWithWhereUniqueWithoutMarketplaceInput = {
    where: MarketplaceAgentWhereUniqueInput
    data: XOR<MarketplaceAgentUpdateWithoutMarketplaceInput, MarketplaceAgentUncheckedUpdateWithoutMarketplaceInput>
  }

  export type MarketplaceAgentUpdateManyWithWhereWithoutMarketplaceInput = {
    where: MarketplaceAgentScalarWhereInput
    data: XOR<MarketplaceAgentUpdateManyMutationInput, MarketplaceAgentUncheckedUpdateManyWithoutAgentsInput>
  }

  export type MarketplaceBuyerUpsertWithWhereUniqueWithoutMarketplaceInput = {
    where: MarketplaceBuyerWhereUniqueInput
    update: XOR<MarketplaceBuyerUpdateWithoutMarketplaceInput, MarketplaceBuyerUncheckedUpdateWithoutMarketplaceInput>
    create: XOR<MarketplaceBuyerCreateWithoutMarketplaceInput, MarketplaceBuyerUncheckedCreateWithoutMarketplaceInput>
  }

  export type MarketplaceBuyerUpdateWithWhereUniqueWithoutMarketplaceInput = {
    where: MarketplaceBuyerWhereUniqueInput
    data: XOR<MarketplaceBuyerUpdateWithoutMarketplaceInput, MarketplaceBuyerUncheckedUpdateWithoutMarketplaceInput>
  }

  export type MarketplaceBuyerUpdateManyWithWhereWithoutMarketplaceInput = {
    where: MarketplaceBuyerScalarWhereInput
    data: XOR<MarketplaceBuyerUpdateManyMutationInput, MarketplaceBuyerUncheckedUpdateManyWithoutBuyersInput>
  }

  export type MarketplaceCreateWithoutAgentsInput = {
    record_id?: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url?: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created?: Date | string
    expiry_date?: Date | string
    reserved_by_user?: UserCreateNestedOneWithoutMarketplaceInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutMarketplaceInput
  }

  export type MarketplaceUncheckedCreateWithoutAgentsInput = {
    record_id?: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url?: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created?: Date | string
    expiry_date?: Date | string
    reserved_by?: string | null
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutMarketplaceInput
  }

  export type MarketplaceCreateOrConnectWithoutAgentsInput = {
    where: MarketplaceWhereUniqueInput
    create: XOR<MarketplaceCreateWithoutAgentsInput, MarketplaceUncheckedCreateWithoutAgentsInput>
  }

  export type UserCreateWithoutAgentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    selected_company?: CompanyCreateNestedOneWithoutSelected_usersInput
    company_managing?: CompanyCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    buyers?: MarketplaceBuyerCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company_managing?: CompanyUncheckedCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    buyers?: MarketplaceBuyerUncheckedCreateNestedManyWithoutBuyerInput
    Marketplace?: MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
  }

  export type MarketplaceUpsertWithoutAgentsInput = {
    update: XOR<MarketplaceUpdateWithoutAgentsInput, MarketplaceUncheckedUpdateWithoutAgentsInput>
    create: XOR<MarketplaceCreateWithoutAgentsInput, MarketplaceUncheckedCreateWithoutAgentsInput>
  }

  export type MarketplaceUpdateWithoutAgentsInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reserved_by_user?: UserUpdateOneWithoutMarketplaceNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutMarketplaceNestedInput
  }

  export type MarketplaceUncheckedUpdateWithoutAgentsInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reserved_by?: NullableStringFieldUpdateOperationsInput | string | null
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutMarketplaceNestedInput
  }

  export type UserUpsertWithoutAgentsInput = {
    update: XOR<UserUpdateWithoutAgentsInput, UserUncheckedUpdateWithoutAgentsInput>
    create: XOR<UserCreateWithoutAgentsInput, UserUncheckedCreateWithoutAgentsInput>
  }

  export type UserUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    selected_company?: CompanyUpdateOneWithoutSelected_usersNestedInput
    company_managing?: CompanyUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company_managing?: CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBuyersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company?: CompanyCreateNestedOneWithoutUsersInput
    selected_company?: CompanyCreateNestedOneWithoutSelected_usersInput
    company_managing?: CompanyCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentCreateNestedManyWithoutAgentInput
    Marketplace?: MarketplaceCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBuyersInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
    company_managing?: CompanyUncheckedCreateNestedOneWithoutCompany_managerInput
    macrovesta_managing?: CompanyUncheckedCreateNestedManyWithoutMacrovesta_managerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutAgentInput
    Marketplace?: MarketplaceUncheckedCreateNestedManyWithoutReserved_by_userInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBuyersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuyersInput, UserUncheckedCreateWithoutBuyersInput>
  }

  export type MarketplaceCreateWithoutBuyersInput = {
    record_id?: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url?: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created?: Date | string
    expiry_date?: Date | string
    reserved_by_user?: UserCreateNestedOneWithoutMarketplaceInput
    agents?: MarketplaceAgentCreateNestedManyWithoutMarketplaceInput
  }

  export type MarketplaceUncheckedCreateWithoutBuyersInput = {
    record_id?: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url?: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created?: Date | string
    expiry_date?: Date | string
    reserved_by?: string | null
    agents?: MarketplaceAgentUncheckedCreateNestedManyWithoutMarketplaceInput
  }

  export type MarketplaceCreateOrConnectWithoutBuyersInput = {
    where: MarketplaceWhereUniqueInput
    create: XOR<MarketplaceCreateWithoutBuyersInput, MarketplaceUncheckedCreateWithoutBuyersInput>
  }

  export type UserUpsertWithoutBuyersInput = {
    update: XOR<UserUpdateWithoutBuyersInput, UserUncheckedUpdateWithoutBuyersInput>
    create: XOR<UserCreateWithoutBuyersInput, UserUncheckedCreateWithoutBuyersInput>
  }

  export type UserUpdateWithoutBuyersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    selected_company?: CompanyUpdateOneWithoutSelected_usersNestedInput
    company_managing?: CompanyUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutAgentNestedInput
    Marketplace?: MarketplaceUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBuyersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company_managing?: CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput
    Marketplace?: MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MarketplaceUpsertWithoutBuyersInput = {
    update: XOR<MarketplaceUpdateWithoutBuyersInput, MarketplaceUncheckedUpdateWithoutBuyersInput>
    create: XOR<MarketplaceCreateWithoutBuyersInput, MarketplaceUncheckedCreateWithoutBuyersInput>
  }

  export type MarketplaceUpdateWithoutBuyersInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reserved_by_user?: UserUpdateOneWithoutMarketplaceNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutMarketplaceNestedInput
  }

  export type MarketplaceUncheckedUpdateWithoutBuyersInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reserved_by?: NullableStringFieldUpdateOperationsInput | string | null
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutMarketplaceNestedInput
  }

  export type CompanyCreateWithoutFixed_cottonInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager?: UserCreateNestedOneWithoutCompany_managingInput
    macrovesta_manager?: UserCreateNestedOneWithoutMacrovesta_managingInput
    users?: UserCreateNestedManyWithoutCompanyInput
    selected_users?: UserCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFixed_cottonInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    macrovesta_manager_id?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    selected_users?: UserUncheckedCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logUncheckedCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFixed_cottonInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFixed_cottonInput, CompanyUncheckedCreateWithoutFixed_cottonInput>
  }

  export type CompanyUpsertWithoutFixed_cottonInput = {
    update: XOR<CompanyUpdateWithoutFixed_cottonInput, CompanyUncheckedUpdateWithoutFixed_cottonInput>
    create: XOR<CompanyCreateWithoutFixed_cottonInput, CompanyUncheckedCreateWithoutFixed_cottonInput>
  }

  export type CompanyUpdateWithoutFixed_cottonInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager?: UserUpdateOneWithoutCompany_managingNestedInput
    macrovesta_manager?: UserUpdateOneWithoutMacrovesta_managingNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFixed_cottonInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUncheckedUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUncheckedUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutUnfixed_cottonInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager?: UserCreateNestedOneWithoutCompany_managingInput
    macrovesta_manager?: UserCreateNestedOneWithoutMacrovesta_managingInput
    users?: UserCreateNestedManyWithoutCompanyInput
    selected_users?: UserCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUnfixed_cottonInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    macrovesta_manager_id?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    selected_users?: UserUncheckedCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logUncheckedCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUnfixed_cottonInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUnfixed_cottonInput, CompanyUncheckedCreateWithoutUnfixed_cottonInput>
  }

  export type CompanyUpsertWithoutUnfixed_cottonInput = {
    update: XOR<CompanyUpdateWithoutUnfixed_cottonInput, CompanyUncheckedUpdateWithoutUnfixed_cottonInput>
    create: XOR<CompanyCreateWithoutUnfixed_cottonInput, CompanyUncheckedCreateWithoutUnfixed_cottonInput>
  }

  export type CompanyUpdateWithoutUnfixed_cottonInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager?: UserUpdateOneWithoutCompany_managingNestedInput
    macrovesta_manager?: UserUpdateOneWithoutMacrovesta_managingNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUnfixed_cottonInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUncheckedUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUncheckedUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutStrategy_logInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager?: UserCreateNestedOneWithoutCompany_managingInput
    macrovesta_manager?: UserCreateNestedOneWithoutMacrovesta_managingInput
    users?: UserCreateNestedManyWithoutCompanyInput
    selected_users?: UserCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutStrategy_logInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    macrovesta_manager_id?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    selected_users?: UserUncheckedCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutStrategy_logInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutStrategy_logInput, CompanyUncheckedCreateWithoutStrategy_logInput>
  }

  export type CompanyUpsertWithoutStrategy_logInput = {
    update: XOR<CompanyUpdateWithoutStrategy_logInput, CompanyUncheckedUpdateWithoutStrategy_logInput>
    create: XOR<CompanyCreateWithoutStrategy_logInput, CompanyUncheckedCreateWithoutStrategy_logInput>
  }

  export type CompanyUpdateWithoutStrategy_logInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager?: UserUpdateOneWithoutCompany_managingNestedInput
    macrovesta_manager?: UserUpdateOneWithoutMacrovesta_managingNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutStrategy_logInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUncheckedUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutProducer_production_estimatesInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager?: UserCreateNestedOneWithoutCompany_managingInput
    macrovesta_manager?: UserCreateNestedOneWithoutMacrovesta_managingInput
    users?: UserCreateNestedManyWithoutCompanyInput
    selected_users?: UserCreateNestedManyWithoutSelected_companyInput
    producer_cost_estimates?: producer_cost_estimatesCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProducer_production_estimatesInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    macrovesta_manager_id?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    selected_users?: UserUncheckedCreateNestedManyWithoutSelected_companyInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logUncheckedCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProducer_production_estimatesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProducer_production_estimatesInput, CompanyUncheckedCreateWithoutProducer_production_estimatesInput>
  }

  export type CompanyUpsertWithoutProducer_production_estimatesInput = {
    update: XOR<CompanyUpdateWithoutProducer_production_estimatesInput, CompanyUncheckedUpdateWithoutProducer_production_estimatesInput>
    create: XOR<CompanyCreateWithoutProducer_production_estimatesInput, CompanyUncheckedCreateWithoutProducer_production_estimatesInput>
  }

  export type CompanyUpdateWithoutProducer_production_estimatesInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager?: UserUpdateOneWithoutCompany_managingNestedInput
    macrovesta_manager?: UserUpdateOneWithoutMacrovesta_managingNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUpdateManyWithoutSelected_companyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProducer_production_estimatesInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUncheckedUpdateManyWithoutSelected_companyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUncheckedUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutProducer_cost_estimatesInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager?: UserCreateNestedOneWithoutCompany_managingInput
    macrovesta_manager?: UserCreateNestedOneWithoutMacrovesta_managingInput
    users?: UserCreateNestedManyWithoutCompanyInput
    selected_users?: UserCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProducer_cost_estimatesInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    macrovesta_manager_id?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    selected_users?: UserUncheckedCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logUncheckedCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProducer_cost_estimatesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProducer_cost_estimatesInput, CompanyUncheckedCreateWithoutProducer_cost_estimatesInput>
  }

  export type CompanyUpsertWithoutProducer_cost_estimatesInput = {
    update: XOR<CompanyUpdateWithoutProducer_cost_estimatesInput, CompanyUncheckedUpdateWithoutProducer_cost_estimatesInput>
    create: XOR<CompanyCreateWithoutProducer_cost_estimatesInput, CompanyUncheckedCreateWithoutProducer_cost_estimatesInput>
  }

  export type CompanyUpdateWithoutProducer_cost_estimatesInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager?: UserUpdateOneWithoutCompany_managingNestedInput
    macrovesta_manager?: UserUpdateOneWithoutMacrovesta_managingNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProducer_cost_estimatesInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUncheckedUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUncheckedUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutProducer_commercialisation_estimatesInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager?: UserCreateNestedOneWithoutCompany_managingInput
    macrovesta_manager?: UserCreateNestedOneWithoutMacrovesta_managingInput
    users?: UserCreateNestedManyWithoutCompanyInput
    selected_users?: UserCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProducer_commercialisation_estimatesInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
    macrovesta_manager_id?: string | null
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    selected_users?: UserUncheckedCreateNestedManyWithoutSelected_companyInput
    producer_production_estimates?: producer_production_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedCreateNestedManyWithoutCompanyInput
    strategy_log?: strategy_logUncheckedCreateNestedManyWithoutCompanyInput
    fixed_cotton?: fixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
    unfixed_cotton?: unfixed_cottonUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProducer_commercialisation_estimatesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProducer_commercialisation_estimatesInput, CompanyUncheckedCreateWithoutProducer_commercialisation_estimatesInput>
  }

  export type CompanyUpsertWithoutProducer_commercialisation_estimatesInput = {
    update: XOR<CompanyUpdateWithoutProducer_commercialisation_estimatesInput, CompanyUncheckedUpdateWithoutProducer_commercialisation_estimatesInput>
    create: XOR<CompanyCreateWithoutProducer_commercialisation_estimatesInput, CompanyUncheckedCreateWithoutProducer_commercialisation_estimatesInput>
  }

  export type CompanyUpdateWithoutProducer_commercialisation_estimatesInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager?: UserUpdateOneWithoutCompany_managingNestedInput
    macrovesta_manager?: UserUpdateOneWithoutMacrovesta_managingNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProducer_commercialisation_estimatesInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    macrovesta_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUncheckedUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUncheckedUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    selected_company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
  }

  export type UserCreateManySelected_companyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    role?: string | null
    company_id?: string | null
    submittedSurvey?: boolean | null
    image?: string | null
  }

  export type producer_production_estimatesCreateManyCompanyInput = {
    record_id?: string
    season: string
    production_estimate: Decimal | DecimalJsLike | number | string
    yield_estimate: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_cost_estimatesCreateManyCompanyInput = {
    record_id?: string
    season: string
    cost_estimate_dollar_per_hectare: Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type producer_commercialisation_estimatesCreateManyCompanyInput = {
    record_id?: string
    season: string
    percentage_sold: Decimal | DecimalJsLike | number | string
    added_by?: string | null
    date_created?: Date | string
  }

  export type strategy_logCreateManyCompanyInput = {
    record_id?: string
    title?: string | null
    text?: string | null
    added_by?: string | null
    date_created?: Date | string
  }

  export type fixed_cottonCreateManyCompanyInput = {
    record_id?: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: Decimal | DecimalJsLike | number | string | null
    amount_fixed?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
  }

  export type unfixed_cottonCreateManyCompanyInput = {
    record_id?: string
    contract_number: string
    futures_month: string
    basis?: Decimal | DecimalJsLike | number | string | null
    fix_by: Date | string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    amount_remaining?: Decimal | DecimalJsLike | number | string | null
    added_by: string
    date_created?: Date | string
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company?: CompanyUpdateOneWithoutSelected_usersNestedInput
    company_managing?: CompanyUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company_managing?: CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    selected_company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutSelected_companyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneWithoutUsersNestedInput
    company_managing?: CompanyUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSelected_companyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    company_managing?: CompanyUncheckedUpdateOneWithoutCompany_managerNestedInput
    macrovesta_managing?: CompanyUncheckedUpdateManyWithoutMacrovesta_managerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutAgentNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutBuyerNestedInput
    Marketplace?: MarketplaceUncheckedUpdateManyWithoutReserved_by_userNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSelected_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedSurvey?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type producer_production_estimatesUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    production_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yield_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_production_estimatesUncheckedUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    production_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yield_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_production_estimatesUncheckedUpdateManyWithoutProducer_production_estimatesInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    production_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    yield_estimate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_cost_estimatesUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    cost_estimate_dollar_per_hectare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_cost_estimatesUncheckedUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    cost_estimate_dollar_per_hectare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_cost_estimatesUncheckedUpdateManyWithoutProducer_cost_estimatesInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    cost_estimate_dollar_per_hectare?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost_estimate_cent_per_pound?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_commercialisation_estimatesUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    percentage_sold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_commercialisation_estimatesUncheckedUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    percentage_sold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type producer_commercialisation_estimatesUncheckedUpdateManyWithoutProducer_commercialisation_estimatesInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    percentage_sold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type strategy_logUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type strategy_logUncheckedUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type strategy_logUncheckedUpdateManyWithoutStrategy_logInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: NullableStringFieldUpdateOperationsInput | string | null
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fixed_cottonUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fixed_cottonUncheckedUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fixed_cottonUncheckedUpdateManyWithoutFixed_cottonInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fixed_price_without_basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_fixed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unfixed_cottonUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fix_by?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_remaining?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unfixed_cottonUncheckedUpdateWithoutCompanyInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fix_by?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_remaining?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unfixed_cottonUncheckedUpdateManyWithoutUnfixed_cottonInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    contract_number?: StringFieldUpdateOperationsInput | string
    futures_month?: StringFieldUpdateOperationsInput | string
    basis?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fix_by?: DateTimeFieldUpdateOperationsInput | Date | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_remaining?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    added_by?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateManyMacrovesta_managerInput = {
    record_id?: string
    name: string
    type: string
    tier: string
    access_to_marketplace?: boolean | null
    created_at?: Date | string
    company_manager_id?: string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type MarketplaceAgentCreateManyAgentInput = {
    record_id?: string
    marketplace_id: string
    date_created?: Date | string
  }

  export type MarketplaceBuyerCreateManyBuyerInput = {
    record_id?: string
    marketplace_id: string
    date_created?: Date | string
  }

  export type MarketplaceCreateManyReserved_by_userInput = {
    record_id?: string
    product: string
    category: string
    quantity: number
    quality: string
    description: string
    image_url?: string | null
    price_usd: number
    added_by: string
    hvi_file: string
    shipment: string
    payment_terms: string
    date_created?: Date | string
    expiry_date?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    record_id?: string
    title: string
    description: string
    is_read: boolean
    date_created?: Date | string
  }

  export type CompanyUpdateWithoutMacrovesta_managerInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager?: UserUpdateOneWithoutCompany_managingNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutMacrovesta_managerInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    selected_users?: UserUncheckedUpdateManyWithoutSelected_companyNestedInput
    producer_production_estimates?: producer_production_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_cost_estimates?: producer_cost_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    producer_commercialisation_estimates?: producer_commercialisation_estimatesUncheckedUpdateManyWithoutCompanyNestedInput
    strategy_log?: strategy_logUncheckedUpdateManyWithoutCompanyNestedInput
    fixed_cotton?: fixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
    unfixed_cotton?: unfixed_cottonUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutMacrovesta_managingInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    access_to_marketplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_manager_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceAgentUpdateWithoutAgentInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: MarketplaceUpdateOneRequiredWithoutAgentsNestedInput
  }

  export type MarketplaceAgentUncheckedUpdateWithoutAgentInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    marketplace_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceAgentUncheckedUpdateManyWithoutAgentsInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    marketplace_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceBuyerUpdateWithoutBuyerInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: MarketplaceUpdateOneRequiredWithoutBuyersNestedInput
  }

  export type MarketplaceBuyerUncheckedUpdateWithoutBuyerInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    marketplace_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceBuyerUncheckedUpdateManyWithoutBuyersInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    marketplace_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceUpdateWithoutReserved_by_userInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: MarketplaceAgentUpdateManyWithoutMarketplaceNestedInput
    buyers?: MarketplaceBuyerUpdateManyWithoutMarketplaceNestedInput
  }

  export type MarketplaceUncheckedUpdateWithoutReserved_by_userInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: MarketplaceAgentUncheckedUpdateManyWithoutMarketplaceNestedInput
    buyers?: MarketplaceBuyerUncheckedUpdateManyWithoutMarketplaceNestedInput
  }

  export type MarketplaceUncheckedUpdateManyWithoutMarketplaceInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    product?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    quality?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price_usd?: FloatFieldUpdateOperationsInput | number
    added_by?: StringFieldUpdateOperationsInput | string
    hvi_file?: StringFieldUpdateOperationsInput | string
    shipment?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutNotificationInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceAgentCreateManyMarketplaceInput = {
    record_id?: string
    agent_id: string
    date_created?: Date | string
  }

  export type MarketplaceBuyerCreateManyMarketplaceInput = {
    record_id?: string
    buyer_id: string
    date_created?: Date | string
  }

  export type MarketplaceAgentUpdateWithoutMarketplaceInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: UserUpdateOneRequiredWithoutAgentsNestedInput
  }

  export type MarketplaceAgentUncheckedUpdateWithoutMarketplaceInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceBuyerUpdateWithoutMarketplaceInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: UserUpdateOneRequiredWithoutBuyersNestedInput
  }

  export type MarketplaceBuyerUncheckedUpdateWithoutMarketplaceInput = {
    record_id?: StringFieldUpdateOperationsInput | string
    buyer_id?: StringFieldUpdateOperationsInput | string
    date_created?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}